---
title: "Untitled"
output: html_document
date: "2024-08-19"
---
---
title: "HMP_2_free_virome"
author: "Anshul Sinha"
date: "7/4/2023"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



```{r}

library(rlang)
library(data.table)
library(tidyr)
library(dplyr)
library(RColorBrewer)
library(ggplot2)
library(microbiome)

library(microViz)
library(phyloseq)

```


```{r}

#Reading in the Sam tools Coverage 

sam_tools_cov_hmp2_vir1 <- read.table("/Users/anshulsinha/Desktop/IBD_prophages_aim/bioinformatics_aim/bioinformatics_HMP_2/virome_data_08_2024/concatenated_samtools3.tsv", sep="\t", header=TRUE, fill=TRUE, quote="")



#sam_tools_cov_hmp2_vir1 <- read.table("/Users/anshulsinha/Desktop/IBD_prophages_aim/bioinformatics_aim/bioinformatics_HMP_2/free_virome/free_virome_09_23/samtools/samtools.txt", header = TRUE, sep = "\t")

colnames(sam_tools_cov_hmp2_vir1) <- c("contig_name_filename", "startpos", "endpos", "numreads", "covbases", "coverage",  "meandepth", "meanbaseq", "meanmapq")


sam_tools_cov_hmp2_vir1 <- sam_tools_cov_hmp2_vir1  %>%
  separate(contig_name_filename, c("filename", "contigname"), ":")
tail(sam_tools_cov_hmp2_vir1)





#remove unecessary part of filename with "sam_tools_cov"
sam_tools_cov_hmp2_vir1$filename  <- substr(sam_tools_cov_hmp2_vir1$filename, 1, nchar(sam_tools_cov_hmp2_vir1$filename) - 14)
sam_tools_cov_hmp2_vir1$filename  <- substr(sam_tools_cov_hmp2_vir1$filename, 1, nchar(sam_tools_cov_hmp2_vir1$filename) - 14)


length(unique(sam_tools_cov_hmp2_vir1$filename))
names_list <- unique(sam_tools_cov_hmp2_vir1$filename)

list_filenames <- write.csv(names_list, "/Users/anshulsinha/Desktop/PBF_manuscript/data/metaphlan/sample_list/sample_list_phf.csv")
###STOCKDALE CUTOFFS###




#first have to read in the checkV ouput for contig length 
#checkV_virome <- read.table("/Users/anshulsinha/Desktop/IBD_prophages_aim/bioinformatics_aim/bioinformatics_HMP_2/free_virome/free_virome_09_23/checkV/quality_summary.tsv", sep = "\t", header = TRUE)

checkV_virome <- read.table("/Users/anshulsinha/Desktop/IBD_prophages_aim/bioinformatics_aim/bioinformatics_HMP_2/virome_data_08_2024/quality_summary.tsv", sep = "\t", header = TRUE)



checkV_virome <- checkV_virome  %>%
  select(contig_id, contig_length)


colnames(checkV_virome) <- c("contigname", "contig_length")


#remove leading spaces 
sam_tools_cov_hmp2_vir1$contigname <- trimws(sam_tools_cov_hmp2_vir1$contigname, "left")
checkV_virome$contigname <- trimws(checkV_virome$contigname, "left")


#remove trailing spaces 

sam_tools_cov_hmp2_vir1$contigname <- trimws(sam_tools_cov_hmp2_vir1$contigname, "left")
checkV_virome$contigname <- trimws(checkV_virome$contigname, "left")


sam_tools_cov_hmp2_vir <- left_join(sam_tools_cov_hmp2_vir1, checkV_virome, by= "contigname")



#Stockdale cuttoffs - 6,369,157 5 hits before 

sam_tools_cov_hmp2_vir <- sam_tools_cov_hmp2_vir[sam_tools_cov_hmp2_vir$numreads > 10,]


#1,680,670 now 

#subset based on contig length
# calculated breadth of coverage for Bowtie2 mapped reads spanned 50% of contigs <5kb, 30% of contigs ≥5kb and <20kb, or 10% of contigs ≥20kb59,60.


#<5kb
sam_tools_cov_hmp2_vir_5 <- sam_tools_cov_hmp2_vir[sam_tools_cov_hmp2_vir$contig_length < 5000,]
#12,763 entries before cutoff
sam_tools_cov_hmp2_vir_5 <- sam_tools_cov_hmp2_vir_5[sam_tools_cov_hmp2_vir_5$coverage > 50,]
#4,578 after 





#between 5 and 20
sam_tools_cov_hmp2_vir_5_20_1 <- sam_tools_cov_hmp2_vir[sam_tools_cov_hmp2_vir$contig_length >= 5000 ,]
sam_tools_cov_hmp2_vir_5_20_2 <- sam_tools_cov_hmp2_vir_5_20_1[sam_tools_cov_hmp2_vir_5_20_1$contig_length < 20000,]
#105,249 before 

 sam_tools_cov_hmp2_vir_5_20_2 <- sam_tools_cov_hmp2_vir_5_20_2[sam_tools_cov_hmp2_vir_5_20_2$coverage > 30,]

 #24,953 after
 
 
#Above 20 
 
 #1,562,666
 sam_tools_cov_hmp2_20 <- sam_tools_cov_hmp2_vir[sam_tools_cov_hmp2_vir$contig_length >= 20000,]
sam_tools_cov_hmp2_20 <- sam_tools_cov_hmp2_20[sam_tools_cov_hmp2_20$coverage > 10,]


#585,639 after 


sam_tools_cov_hmp2_vir <- rbind(sam_tools_cov_hmp2_vir_5, sam_tools_cov_hmp2_vir_5_20_2, sam_tools_cov_hmp2_20 )
#615,170 hits after!







#######iPHoP##########

hmp2_vir_iphop <- read.csv("/Users/anshulsinha/Desktop/IBD_prophages_aim/bioinformatics_aim/bioinformatics_HMP_2/virome_data_08_2024/Host_prediction_to_genome_m90.csv", header = TRUE, sep = ",")


#hmp2_vir_iphop <- read.csv("/Users/anshulsinha/Desktop/IBD_prophages_aim/bioinformatics_aim/bioinformatics_HMP_2/free_virome/free_virome_09_23/iPHoP/Host_prediction_to_genome_m90.csv", header = TRUE, sep = ",")



#Turn this into a data table 

hmp2_vir_iphop <-as.data.table(hmp2_vir_iphop)

hmp2_vir_iphop
#iPhoP gives several outputs for each contig - filter to give the highest confidence 

#If two values have the same confidence score, it'll just take the top value. 

hmp2_vir_iphop <- hmp2_vir_iphop %>%
  group_by(Virus) %>%
  dplyr::slice(which.max(Confidence.score))



colnames(hmp2_vir_iphop)[1] <- c("contigname")




#Separate taxonomic levels 
hmp2_vir_iphop <-  hmp2_vir_iphop %>% 
  separate(Host.taxonomy, into = c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species"), sep = ";")
hmp2_vir_iphop

names(hmp2_vir_iphop)[1] <- "contigname"
hmp2_vir_iphop


hmp2_vir_iphop <- hmp2_vir_iphop %>%
    mutate(Phylum = recode(Phylum, p__Firmicutes_A = 'p__Firmicutes', p__Firmicutes_B = 'p__Firmicutes', p__Firmicutes_C = 'p__Firmicutes'))
hmp2_vir_iphop





#Read in Bacphlip
  

hmp2_bacphlip <-  read.table("/Users/anshulsinha/Desktop/IBD_prophages_aim/bioinformatics_aim/bioinformatics_HMP_2/virome_data_08_2024/dereplicated_phages.tsv", header = TRUE, sep = "\t")


#Assign Temperate vs. Virulent based on confidence scores 
  
hmp2_bacphlip$Lifestyle <- ifelse(hmp2_bacphlip$Temperate > 0.5, "Temperate", "Virulent")
hmp2_bacphlip
colnames(hmp2_bacphlip)[1] <- c("contigname")


#ALSO - if the contig name contains "fragment" - call it a temperate phage 


library(dplyr)
library(stringr)


hmp2_bacphlip <- hmp2_bacphlip %>%
  mutate(Lifestyle = if_else(str_detect(contigname, "fragment") & Lifestyle == "Virulent", 
                             "Temperate", 
                             Lifestyle))


table(hmp2_bacphlip$Lifestyle)



#remove leading spaces 
sam_tools_cov_hmp2_vir$contigname <- trimws(sam_tools_cov_hmp2_vir$contigname, "left")
hmp2_bacphlip$contigname <- trimws(hmp2_bacphlip$contigname, "left")
hmp2_vir_iphop$contigname <- trimws(hmp2_vir_iphop$contigname, "left")


#remove trailing spaces 

sam_tools_cov_hmp2_vir$contigname <- trimws(sam_tools_cov_hmp2_vir$contigname, "right")
hmp2_bacphlip$contigname <- trimws(hmp2_bacphlip$contigname, "right")
hmp2_vir_iphop$contigname <- trimws(hmp2_vir_iphop$contigname, "right")



length(unique(sam_tools_cov_hmp2_vir$filename))
sam_tools_cov_hmp2_vir

```

```{r}
#bacphlip sanity check 
  

hmp2_bacphlip2 <-  read.table("/Users/anshulsinha/Desktop/IBD_prophages_aim/bioinformatics_aim/bioinformatics_HMP_2/virome_data_08_2024/dereplicated_phages.tsv", header = TRUE, sep = "\t")


#Assign Temperate vs. Virulent based on confidence scores 
  
hmp2_bacphlip2$Lifestyle <- ifelse(hmp2_bacphlip2$Temperate > 0.5, "Temperate", "Virulent")
hmp2_bacphlip2
colnames(hmp2_bacphlip2)[1] <- c("contigname")

table(hmp2_bacphlip2$Lifestyle) #1,881 temperate, 2005 virulent 

#what is the breakdown of fragments incorrectly called virulent

contigs_with_fragment2 <- hmp2_bacphlip2[grep("_fragment", hmp2_bacphlip2$contigname), ]

names_fragment <- contigs_with_fragment2$contigname

907/3870*100

table(contigs_with_fragment2$Lifestyle) #295 fragments called virulent by bacphlip 
#for our own purposes, lets stick with all 907 as VIBRANT-predicted proviruses 


#ALSO - if the contig name contains "fragment" - call it a temperate phage 


library(dplyr)
library(stringr)


hmp2_bacphlip <- hmp2_bacphlip %>%
  mutate(Lifestyle = if_else(str_detect(contigname, "fragment") & Lifestyle == "Virulent", 
                             "Temperate", 
                             Lifestyle))






```




```{r}
#Join the dataframes - this step will be important for later when I want to filter the sam tools output by "Virulent" or "Temperate"


df_hmp_virome_1 <- left_join(sam_tools_cov_hmp2_vir, hmp2_bacphlip , by="contigname")

df_hmp_virome_2 <- left_join(df_hmp_virome_1, hmp2_vir_iphop, by="contigname")



#metadata
metadata_df <- read.csv("/Users/anshulsinha/Desktop/IBD_prophages_aim/bioinformatics_aim/bioinformatics_HMP_2/prop_stats_outputs/combined_metadata.csv", header = TRUE)
metadata_df
names(metadata_df)[names(metadata_df) == 'Sample_name'] <- 'filename'


#remove samples that have no dysbiosis scores- this brings us to 1595 samples 
metadata_df <- metadata_df[complete.cases(metadata_df$dysbiosis_binary), ]








df_hmp_virome <- left_join(df_hmp_virome_1, metadata_df, by="filename")

df_hmp_virome <- df_hmp_virome[complete.cases(df_hmp_virome$dysbiosis_binary), ]


unique(df_hmp_virome$Participant.ID)
tail(df_hmp_virome)


#filter for just the Temperate and Virulent Viromes 


df_hmp_temperate <- df_hmp_virome[df_hmp_virome$Lifestyle == "Temperate",]


df_hmp_virulent <- df_hmp_virome[df_hmp_virome$Lifestyle == "Virulent",]


#These can be used to convert to phyloseq OTU tables since they've already been filtered for depth and coverage % cutoffs




```

```{r}
#I want to calculate the % rel abundance for temperate phages and add it to the metadata 
#step1 - calculate the mean depth sum for each sample 

library(dplyr)
 df_sum_sample <- sam_tools_cov_hmp2_vir %>%
    group_by(filename) %>%
    summarise(length_normalized_read_count = sum(meandepth))

#step 2 -calcuate the mean depth sum for just the temperate virome and calculate the relab


 df_sum_sample_temp <- df_hmp_temperate %>%
    group_by(filename) %>%
    summarise(temp_length_normalized_read_count = sum(meandepth))

 #step 3- left join the two above 
 
 temp_rel_ab_df <- left_join(df_sum_sample, df_sum_sample_temp, by = "filename")
 temp_rel_ab_df$temp_relab <- temp_rel_ab_df$temp_length_normalized_read_count/temp_rel_ab_df$length_normalized_read_count
temp_rel_ab_df


#step 4 left join back with the metadata 

metadata_df <- left_join(metadata_df, temp_rel_ab_df, by = "filename")


```






```{r}
#unique_sample_names <-  unique(hmp2_free_vir_samplenames$filename)

```






```{r}
library(phyloseq)
library(dplyr)

#Creating a function that converts the samtools outputs to a matrix that can be used by Phyloseq 
#option to choose "meandepth" (length normalized read counts) or raw read counts "numreads"

ps_otu_tab_maker <- function(sam_tools_output, reads) {
  
  
  
  #read in and select necessary columns for ps 
  
sam_tools_output_1 <- sam_tools_output %>%
  select(filename, contigname, reads)
sam_tools_output_1




if(reads == "meandepth") {
sam_tools_output_1$meandepth <- round(sam_tools_output_1$meandepth, 0)
}  
  else
{sam_tools_output_1$numreads <- round(sam_tools_output_1$numreads, 0)

}  







#round the decimals - necssary for ps 
#sam_tools_output_1$meandepth <- round(sam_tools_output_1$meandepth, 0)

#sam_tools_output_1


# turn this into a correct format for ps 


sam_tools_output_2 <- sam_tools_output_1 %>%
                 pivot_wider(names_from = filename, values_from = reads)

#replace nas in the df with 0 

sam_tools_output_2[is.na(sam_tools_output_2)] = 0
#sam_tools_output_2

#make the contig column the rownames
 sam_tools_output_3 <- sam_tools_output_2 %>%
  tibble::column_to_rownames("contigname") 
 
# Convert to matrix

sam_tools_matrix <- as.matrix(sam_tools_output_3)
 sam_tools_matrix


}


otu_tab_whole_vir <-  ps_otu_tab_maker(df_hmp_virome, reads = "meandepth")
otu_tab_temp_vir <-ps_otu_tab_maker(df_hmp_temperate, reads = "meandepth")
otu_tab_vir_vir <- ps_otu_tab_maker(df_hmp_virulent, reads = "meandepth")

otu_tab_whole_vir_reads <-  ps_otu_tab_maker(df_hmp_virome, reads = "numreads")
as.data.frame(head(otu_tab_whole_vir))
```




```{r}

#now work on taxonomy for phyloseq - need the same rownames as the abundance (contigname on the x-axis)

#There are two taxonomy tables I need to create depending on the phyloseq objects I create. Due to limitations in MicroViz, I cant include the IPhoP and BacPhlip Taxonomy info in the same PS object (makes visualization difficult)

#For 3 PS objects (whole virome, temperate, virulent) I'll use the IPhoP taxonomy
# For the 1 PS object where I compare Virulent and Temperate phage rel abundance/diversity, I'll use the bacphlip taxonomy



#IPHoP only includes the contigs with hits, so I need to first include all contigs by making a list of them using the bacphlip df then left join with the iPHoP df


  
hmp2_vir_names <- hmp2_bacphlip %>%
  select(contigname)
hmp2_vir_names

df_hmp_iphop_all_1 <- left_join(hmp2_vir_names, hmp2_vir_iphop, by="contigname")

#also add in the bacphlip info here...  will be useful to include in phyloseq

df_hmp_iphop_all <- left_join(df_hmp_iphop_all_1, hmp2_bacphlip, by="contigname")


table(hmp2_bacphlip$Lifestyle)



# assign first column as rownames
#rownames(df_hmp_free_iphop_all) <- df_hmp_free_iphop_all[, 1]

# remove first column

#df_hmp_free_iphop_all <-  df_hmp_free_iphop_all[, -1, drop = FALSE]


# remove uncessary columns: For IPhop taxa only phyloseq object 

df_hmp_iphop_all_taxa_only <- select(df_hmp_iphop_all, -c("Confidence.score", "Additional.methods", "Virulent", "Temperate", "Lifestyle", "Host.genome"))

df_hmp_iphop_all_taxa_only <- df_hmp_iphop_all_taxa_only %>% 
tibble::column_to_rownames("contigname")


#Breakdown of iPHoP hits 

table(df_hmp_iphop_all_taxa_only$Main.method, useNA = "always")
table(df_hmp_iphop_all_taxa_only$Family, useNA = "always")
df_hmp_iphop_all_taxa_only <- as.matrix(df_hmp_iphop_all_taxa_only)


# remove uncessary columns: For lifestyle info  phyloseq object (see below) - removing all IPhoP taxonomy 



df_hmp_iphop_all_lifestyle <- select(df_hmp_iphop_all, -c("Main.method","Confidence.score", "Additional.methods", "Virulent", "Temperate", "Host.genome", "Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species"))

df_hmp_iphop_all_lifestyle <- df_hmp_iphop_all_lifestyle %>% 
tibble::column_to_rownames("contigname")

df_hmp_iphop_all_lifestyle <- as.matrix(df_hmp_iphop_all_lifestyle)






#now for the X phyloseq object - I want to append the phyla names with the lifestyle info (Ie- Proteobacteria_Virulent) #Do this without appendeing the NA's- important for agglomeration later 
df_hmp_iphop_all_combined_taxa_names  <- df_hmp_iphop_all

df_hmp_iphop_all_combined_taxa_names$Kingdom <- ifelse(is.na(df_hmp_iphop_all_combined_taxa_names$Kingdom), df_hmp_iphop_all_combined_taxa_names$Kingdom, paste0(df_hmp_iphop_all_combined_taxa_names$Kingdom, sep = "_", df_hmp_iphop_all_combined_taxa_names$Lifestyle))


df_hmp_iphop_all_combined_taxa_names$Phylum <- ifelse(is.na(df_hmp_iphop_all_combined_taxa_names$Phylum), df_hmp_iphop_all_combined_taxa_names$Phylum, paste0(df_hmp_iphop_all_combined_taxa_names$Phylum, sep = "_", df_hmp_iphop_all_combined_taxa_names$Lifestyle))



df_hmp_iphop_all_combined_taxa_names$Class <- ifelse(is.na(df_hmp_iphop_all_combined_taxa_names$Class), df_hmp_iphop_all_combined_taxa_names$Class, paste0(df_hmp_iphop_all_combined_taxa_names$Class, sep = "_", df_hmp_iphop_all_combined_taxa_names$Lifestyle))



df_hmp_iphop_all_combined_taxa_names$Order <- ifelse(is.na(df_hmp_iphop_all_combined_taxa_names$Order), df_hmp_iphop_all_combined_taxa_names$Order, paste0(df_hmp_iphop_all_combined_taxa_names$Order, sep = "_", df_hmp_iphop_all_combined_taxa_names$Lifestyle))



df_hmp_iphop_all_combined_taxa_names$Family <- ifelse(is.na(df_hmp_iphop_all_combined_taxa_names$Family), df_hmp_iphop_all_combined_taxa_names$Family, paste0(df_hmp_iphop_all_combined_taxa_names$Family, sep = "_", df_hmp_iphop_all_combined_taxa_names$Lifestyle))



df_hmp_iphop_all_combined_taxa_names$Genus <- ifelse(is.na(df_hmp_iphop_all_combined_taxa_names$Genus), df_hmp_iphop_all_combined_taxa_names$Genus, paste0(df_hmp_iphop_all_combined_taxa_names$Genus, sep = "_", df_hmp_iphop_all_combined_taxa_names$Lifestyle))

df_hmp_iphop_all_combined_taxa_names$Species <- ifelse(is.na(df_hmp_iphop_all_combined_taxa_names$Species), df_hmp_iphop_all_combined_taxa_names$Species, paste0(df_hmp_iphop_all_combined_taxa_names$Species, sep = "_", df_hmp_iphop_all_combined_taxa_names$Lifestyle))


unique(df_hmp_iphop_all_combined_taxa_names$Family)


# remove uncessary columns: For IPhop taxa only phyloseq object 

df_hmp_iphop_all_combined_taxa_names <- select(df_hmp_iphop_all_combined_taxa_names, -c("Confidence.score", "Additional.methods", "Virulent", "Temperate", "Lifestyle", "Host.genome"))



df_hmp_iphop_all_combined_taxa_names

df_hmp_iphop_all_combined_taxa_names <- df_hmp_iphop_all_combined_taxa_names %>% 
tibble::column_to_rownames("contigname")

df_hmp_iphop_all_combined_taxa_names <- as.matrix(df_hmp_iphop_all_combined_taxa_names)





```



```{r}
#metadata make the sample names the rownames
#remove the duplicate samples so that there are the same number of samples as in the samtools cov 
#Ill be able to use the same metadata for all PS objects 



hmp2_samplenames <- sam_tools_cov_hmp2_vir %>%
  select(filename)

unique_sample_names <-  unique(hmp2_samplenames$filename)

unique_sample_names <- as.data.frame(unique_sample_names)
colnames(unique_sample_names) <- "filename"


#now left join
hmp2_metadata_phylo <- left_join(unique_sample_names,metadata_df, by="filename")
hmp2_metadata_phylo

#remove those that don't have dysbiosis scores

hmp2_metadata_phylo <- hmp2_metadata_phylo[complete.cases(hmp2_metadata_phylo$dysbiosis_binary), ]
#Before Creating PS Object, change factor levels 




hmp2_metadata_phylo$dysbiosis_binary <- factor(hmp2_metadata_phylo$dysbiosis_binary, levels=c("No", "Yes"))

hmp2_metadata_phylo$diagnosis.x <- factor(hmp2_metadata_phylo$diagnosis.x, levels=c("nonIBD", "CD", "UC"))


hmp2_metadata_phylo.dup <- hmp2_metadata_phylo[!duplicated(hmp2_metadata_phylo$Participant.ID),]
table(hmp2_metadata_phylo.dup$diagnosis.x)

hist(hmp2_metadata_phylo$length_normalized_read_count)

```


```{r}
#create a phylo tree ! since iPHoP uses a phylo tree
library(ape)

#TREE.gtdb.r202 <- read_tree("/Users/anshul.sinha/Downloads/bac120_r202.tree")

```







```{r}
#Now Create the 1st Phyloseq Object 
#Comparing the whole virome- with IPhoP taxonomy 


library("phyloseq")
OTU_HMP2 = otu_table(otu_tab_whole_vir, taxa_are_rows = TRUE)
TAX_HMP2 = tax_table(df_hmp_iphop_all_taxa_only)
META_HMP2 <- sample_data(hmp2_metadata_phylo)
sample_names(META_HMP2) <- hmp2_metadata_phylo$filename
physeqhmp2whole_vir_i = phyloseq(OTU_HMP2, TAX_HMP2, META_HMP2)
physeqhmp2whole_vir_i


```



```{r}
#  The 2nd Phyloseq Object 

#Comparing the whole virome- with IPhoP taxonomy appended with the Bacphlip taxa info 


library("phyloseq")
OTU_HMP2_2 = otu_table(otu_tab_whole_vir, taxa_are_rows = TRUE)
TAX_HMP2_2 = tax_table(df_hmp_iphop_all_combined_taxa_names)
META_HMP2_2 <- sample_data(hmp2_metadata_phylo)
sample_names(META_HMP2_2) <- hmp2_metadata_phylo$filename



physeqhmp2whole_vir_i_comb = phyloseq(OTU_HMP2_2, TAX_HMP2_2, META_HMP2_2)
physeqhmp2whole_vir_i_comb


```




```{r}
#Now Creating the 3rd Phyloseq Object 
#Note that it's going to be easier to create a phyloseq object that either contains or doesn't contain lifestyle info for each contig 

#this PS compares the whole virome but is useful for comparing temperate vs. virulent phages 


library("phyloseq")
OTU_HMP2_3 = otu_table(otu_tab_whole_vir, taxa_are_rows = TRUE)
TAX_HMP2_3 = tax_table(df_hmp_iphop_all_lifestyle )
META_HMP2_3 <- sample_data(hmp2_metadata_phylo)
sample_names(META_HMP2_3) <- hmp2_metadata_phylo$filename


physeqhmp2wholevir_lifestyle = phyloseq(OTU_HMP2_3, TAX_HMP2_3, META_HMP2_3)
physeqhmp2wholevir_lifestyle





```




```{r}
# Creating the 4th Phyloseq Object 


#this PS compares the IPHOP taxonomy and diversity of just the temperate virome  


library("phyloseq")
OTU_HMP2_4= otu_table(otu_tab_temp_vir, taxa_are_rows = TRUE)
TAX_HMP2_4 = tax_table(df_hmp_iphop_all_taxa_only)
META_HMP2_4 <- sample_data(hmp2_metadata_phylo)
sample_names(META_HMP2_4) <- hmp2_metadata_phylo$filename


physeqhmp2tempvir = phyloseq(OTU_HMP2_4, TAX_HMP2_4, META_HMP2_4)
physeqhmp2tempvir


```



```{r}
# Creating the 5th Phyloseq Object 


#this PS compares the IPHOP taxonomy and diversity of just the virulent virome  


library("phyloseq")
OTU_HMP2_5= otu_table(otu_tab_vir_vir, taxa_are_rows = TRUE)
TAX_HMP2_5= tax_table(df_hmp_iphop_all_taxa_only)
META_HMP2_5 <- sample_data(hmp2_metadata_phylo)
sample_names(META_HMP2_5) <- hmp2_metadata_phylo$filename


physeqhmp2vir = phyloseq(OTU_HMP2_5, TAX_HMP2_5, META_HMP2_5)
physeqhmp2vir
physeqhmp2tempvir


```

```{r}
#creating a 6th PS object - whole virome but with raw reads (not legnth normalized reads ) - for DESEQ2 - 



library("phyloseq")
OTU_HMP2_reads = otu_table(otu_tab_whole_vir_reads, taxa_are_rows = TRUE)
TAX_HMP2_reads = tax_table(df_hmp_iphop_all_taxa_only)
META_HMP2_reads <- sample_data(hmp2_metadata_phylo)
sample_names(META_HMP2_reads) <- hmp2_metadata_phylo$filename


physeqhmp2whole_vir_i_reads = phyloseq(OTU_HMP2_reads, TAX_HMP2_reads, META_HMP2_reads)
physeqhmp2whole_vir_i_reads







```




```{r}
#creating a 7th PS object - whole virome but with raw reads (not legnth normalized reads ) - for DESEQ2 - where family names are expanded to contain _virulent or _temperate


library("phyloseq")
OTU_HMP2_reads_comb_fam = otu_table(otu_tab_whole_vir_reads, taxa_are_rows = TRUE)
TAX_HMP2_reads_comb_fam = tax_table(df_hmp_iphop_all_combined_taxa_names)
META_HMP2_reads_comb_fam <- sample_data(hmp2_metadata_phylo)
sample_names(META_HMP2_reads_comb_fam) <- hmp2_metadata_phylo$filename


physeqhmp2whole_vir_i_reads_combfam = phyloseq(OTU_HMP2_reads_comb_fam, TAX_HMP2_reads_comb_fam, META_HMP2_reads_comb_fam)





```







```{r}
# #FUNCTIONS 
# 
# #FUN #1 - Creating a function that does that creates a grouped taxa barplot at a given taxonomic level 
# #Note that this function groups all the unknowns together for plotting 
# #returns a LIST with the modified ps object AND the plot 
# #Ps = ps object, rank=taxa rank = group_var=group variable to group the plot by,
# 
# library(stringr)
# 
# grouped_unknown_taxa <- function(ps, rank, group_var) {
#   
#   #usingui  q2  the anon_unique=False to agglomerate all the unknowns together 
# 
# fixed_taxa_anon_unique <- ps %>%
#    tax_fix(unknowns = "NA", anon_unique = FALSE)
# 
# #This changes the name to of all unclassified taxa to "unclassified kingdom' - rename this 
# 
# #export PS
# tax.cleanup_anon_unique <- data.frame(tax_table(fixed_taxa_anon_unique))
# 
# 
# 
# 
# tax.cleanup_anon_unique$Phylum <- str_replace(tax.cleanup_anon_unique$Phylum, "unclassified Kingdom", "Unknown")
# tax.cleanup_anon_unique$Order <- str_replace(tax.cleanup_anon_unique$Order, "unclassified Kingdom", "Unknown")
# tax.cleanup_anon_unique$Class <- str_replace(tax.cleanup_anon_unique$Class, "unclassified Kingdom", "Unknown")
# tax.cleanup_anon_unique$Family <- str_replace(tax.cleanup_anon_unique$Family, "unclassified Kingdom", "Unknown")
# tax.cleanup_anon_unique$Genus <- str_replace(tax.cleanup_anon_unique$Genus, "unclassified Kingdom", "Unknown")
# tax.cleanup_anon_unique$Species <- str_replace(tax.cleanup_anon_unique$Species, "unclassified Kingdom", "Unknown")
# 
# 
# #return the tax table to the PS
# tax_table(fixed_taxa_anon_unique) <- as.matrix(tax.cleanup_anon_unique)
# 
# 
# 
# #grouping by group_var 
# grouped_ps <- merge_samples2(fixed_taxa_anon_unique, group = group_var) 
# 
# 
# #grouped bar plot 
# grouped_bp <- comp_barplot(grouped_ps, tax_level = rank, n_taxa =10, sample_order = "bray")
# 
# 
# 
# list <- list("bp" = grouped_bp, "ps" = fixed_taxa_anon_unique)
# 
# 
# return(list)
# 
# }
# 
# 
# ```
# 
# 
# 
# 
# 
# ```{r}
# #using above function generate plots for diagnosis, dybsiosis, patient
# grouped_unknown_taxa_diagfam  <- grouped_unknown_taxa(physeqhmp2whole_vir_i, rank = "Family", group_var = "diagnosis.x") 
# 
# 
# grouped_unknown_taxa_diagfam$bp
# grouped_unknown_taxa_dysbfam <- grouped_unknown_taxa(physeqhmp2whole_vir_i, rank = "Family", group_var = "dysbiosis_binary") 
# grouped_unknown_taxa_dysbfam$bp
# grouped_unknown_taxa_patientfamn <- grouped_unknown_taxa(physeqhmp2whole_vir_i, rank = "Family", group_var = "Participant.ID") 
# grouped_unknown_taxa_patientfamn$bp 
# 
# 
# #using above function generate plots for diagnosis, dybsiosis, patient
# grouped_unknown_taxa_diagphy  <- grouped_unknown_taxa(physeqhmp2whole_vir_i, rank = "Phylum", group_var = "diagnosis.x") 
# grouped_unknown_taxa_diagphy$bp
# grouped_unknown_taxa_dysbphy <- grouped_unknown_taxa(physeqhmp2whole_vir_i, rank = "Phylum", group_var = "dysbiosis_binary") 
# grouped_unknown_taxa_dysbphy$bp
# grouped_unknown_taxa_patientphy <- grouped_unknown_taxa(physeqhmp2whole_vir_i, rank = "Phylum", group_var = "Participant.ID") 
# grouped_unknown_taxa_patientphy$bp 



```





```{r}

# 
# #Investigating the proportion of unknown taxa using the ps object above (at Family Level)
#  unknownps <- grouped_unknown_taxa_diagfam$ps
#  
#   #tax_glom to family level and covert to relab
#   unknownpsfam <- tax_glom(unknownps, taxrank="Family", NArm = FALSE)  %>%
#   tax_transform("compositional")
#   
#   
#   #convert tax_table to df
#   #convert to df
#   #note that the rownames will randomly pick a vOTU as the "representative" agglomerated Family :tax_glom is behaving as expected https://github.com/joey711/phyloseq/issues/477
#   tax_table_fam <- data.frame(tax_table(unknownpsfam))
#   library(tibble)
# tax_table_fam <- tibble::rownames_to_column(tax_table_fam, "contigname")
#   
#   #now do the same with the otu table 
# 
#   
#   unknownps_df_fam <- data.frame(otu_table(unknownpsfam))
#   
#   #rownames to colnames 
#   unknownps_df_fam <- tibble::rownames_to_column(unknownps_df_fam, "contigname")
#   
#   #left join 
#   
#   joinedunknownps_df_fam <- left_join(tax_table_fam, unknownps_df_fam, by = "contigname" )
#   #remove everything except Family
#   joinedunknownps_df_fam <- select(joinedunknownps_df_fam, -c("Kingdom", "Phylum", "Class", "Order", "Genus", "Species", "unique", "contigname"))
# 
# fam_var <- joinedunknownps_df_fam[,-1]
# rownames(fam_var) <- joinedunknownps_df_fam[,1]
# joinedunknownps_df_fam <- fam_var
# 
# #remove column "Main.method"
# 
# joinedunknownps_df_fam <- joinedunknownps_df_fam %>% select(-Main.method)
# 
# 
# joinedunknownps_df_fam <- as.matrix(joinedunknownps_df_fam)
# 
# # Calculate the mean of the row
# mean_value <- mean(joinedunknownps_df_fam["Unknown",])
# print(mean_value)*100
# # [1] 2
# 
# # Calculate the median of the row
# median_value <- median(joinedunknownps_df_fam["Unknown",])
# print(median_value)*100
# ```
# 
# 
# 
# 
# 
# ```{r}
# #FUNCTION #2 
# 
# #Ordination PCoA using a Bray or Unifrac Distance 
# #Here, the data is normalized "compositionally"
# #See discussion on normalization methods in README doc 
# # Will also peform a tax aggolomeration at a specified taxonomic level\
# #Note- the way this is coded, will not include NA taxonomic - Ok since only about 7% of the rel ab is unknown taxonomy
# #group_var indicates what colour the plots should be 
# 
# 
# 
# #Important: If you need to agglomerate, tax_glom == "TRUE" if not, "FALSE"- if false just put NA for rank 
# #distance = distance metric ie - "bray"
# #group_var = paramter for plotting (ie- subject )
# 
# 
# PcoA_comp_fun <- function(ps, tax_glom, rank, group_var, distance) {
# 
#   
#   #Conditional statement to deal with whether we want to agglomerate or not
#   
#   execpart <- tax_glom
# 
# if(execpart) {
# ps1 <- tax_glom(ps, taxrank=rank, NArm = TRUE) 
# }  
#   else
# { ps1 <- ps
#   }  
# #before visualization, I need to use the fix_taxa to remove NAs and name with the unclassified with the contig name 
# #Try the same thing but at the family level 
# 
# fixed_taxa <- ps1 %>%
#  tax_fix(unknowns = "NA")
# 
# fixed_taxa_transformed <- fixed_taxa  %>%
#   tax_transform("compositional") 
#   
# tax_transform_relab_ps1_dist <- fixed_taxa_transformed  %>% 
#   dist_calc(distance)
#     
# tax_transform_relab_ps1_ord <- tax_transform_relab_ps1_dist  %>% 
#   ord_calc("PCoA") 
# 
#  ord_plot(tax_transform_relab_ps1_ord, color = group_var, size = 2, interactive = TRUE) + 
#    scale_colour_brewer(palette = "Dark2")
#  
#  
#  
# }
# 
# 
# #FUNCTION TO CALCULATE PERMANOVA  
# #same arguments as above, group_var for permanova variable to test 
# 
# 
# PCoA_comp_fun_perm_Bray <- function(ps, tax_glom, phyrank, group_var) {
#   
#   #same  steps as above for 
#  execpart <- tax_glom
# if(execpart) {
# ps1 <- tax_glom(ps, taxrank=phyrank, NArm = TRUE) 
# 
# fixed_taxa <- ps1 %>%
#  tax_fix(unknowns = "NA")
# 
# #I have to add the "rank" here so that labels will show up on the tax plot
# fixed_taxa_transformed <- fixed_taxa  %>%
#   tax_transform("compositional") 
# 
# }  
#   else
# { ps1 <- ps
# 
# fixed_taxa <- ps1 %>%
#  tax_fix(unknowns = "NA")
# 
# fixed_taxa_transformed <- fixed_taxa  %>%
#   tax_transform("compositional") 
# }  
#  
#  #calculate bray distance on  normalized counts 
# b_dists <- fixed_taxa_transformed %>%
#   dist_calc("bray")
# 
# b_dists_perm <- b_dists %>%
#   dist_permanova(
#     seed = 1234, # for set.seed to ensure reproducibility of random process
#     n_processes = 1, n_perms = 999, # you should use at least 999!
#     variables = group_var
#   )
#  perm_get(b_dists_perm) %>% as.data.frame()
# 
# }
# 
# 
# 
# 
# 
# 
# ```
# 
# 
# ```{r}
# #using the function above... 
# #bray PCOA at contig level 
# 
# #diagnosis 
# PcoA_comp_fun(physeqhmp2whole_vir_i, tax_glom = 'FALSE', rank = 'NA', group_var = "diagnosis.x", distance = "bray" ) +  stat_ellipse(aes(linetype = diagnosis.x, colour = diagnosis.x), linewidth = 0.8) 
# 
# #dysbiosis
# 
# 
# PcoA_comp_fun(physeqhmp2whole_vir_i, tax_glom = 'FALSE', rank = 'NA', group_var = "dysbiosis_binary", distance = "bray" ) +  stat_ellipse(aes(linetype = dysbiosis_binary, colour = dysbiosis_binary), linewidth = 0.8) 
# 
# 
# 
# 
# 
# #bray PCoA at family level 
# #diagnosis 
# PcoA_comp_fun(physeqhmp2whole_vir_i, tax_glom = 'TRUE', rank = 'Family', group_var = "diagnosis.x", distance = "bray") +  stat_ellipse(aes(linetype = diagnosis.x, colour = diagnosis.x), linewidth = 0.8) 
# #dysbiosis
# PcoA_comp_fun(physeqhmp2whole_vir_i, tax_glom = 'TRUE', rank = 'Family', group_var = "dysbiosis_binary", distance = "bray" ) +  stat_ellipse(aes(linetype = dysbiosis_binary, colour = dysbiosis_binary), linewidth = 0.8) 




#



#PCoA_comp_fun_perm_Bray(physeqhmp2whole_vir_i, tax_glom = 'FALSE', phyrank = 'NA', group_var = "diagnosis.x")
#PCoA_comp_fun_perm_Bray(physeqhmp2whole_vir_i, tax_glom = 'FALSE', phyrank = 'NA', group_var = "participant.ID")

#PCoA_comp_fun_perm_Bray(physeqhmp2whole_vir_i, tax_glom = 'TRUE', phyrank = 'Family', group_var = "diagnosis.x")
#PCoA_comp_fun_perm_Bray(physeqhmp2whole_vir_i, tax_glom = 'TRUE', phyrank = 'Family', group_var = "participant.ID")


#PCoA_comp_fun_perm_Bray(physeqhmp2whole_vir_i, tax_glom = 'FALSE', phyrank = 'NA', group_var = "dysbiosis_binary")
#PCoA_comp_fun_perm_Bray(physeqhmp2whole_vir_i, tax_glom = 'TRUE', phyrank = 'Family', group_var = "dysbiosis_binary")


```


```{r}



```




```{r}
#FUNCTION #3

#Ordination PCA using Aitchison's Distance 
#from the microViz tutorial: T
#1) Transform the microbial data with the centered-log-ratio transformation
#2) Perform PCA with the clr-transformed features (equivalent to Aitchison distance PCoA) - use ord_calc()

#Here, the data is normalized "CLR" as per the microviz tutorial
#See discussion on normalization methods in README doc 
# Will also peform a tax aggolomeration at a specified taxonomic level\
#Note- the way this is coded, will not include NA taxonomic - Ok since only about 7% of the rel ab is unknown taxonomy
#group_var indicates what colour the plots should be 


# the plot_taxa will load taxa associated with Certain variables - can play around with this to control number of taxa loaded, or remove arg to not plot any 


#Important: If you need to agglomerate, tax_glom == "TRUE" if not, "FALSE"- if false just put NA for rank 

# 
# PCA_comp_fun <- function(ps, tax_glom, phyrank, group_var) {
# 
#   
#   #Conditional statement to deal with whether we want to agglomerate or not 
#   #Since we have to use the tax_transform argument, the conditional statement will have to add a few more things 
#   # the rank argument doesnthadnle the "NA rank well" 
#   #Even though we agglomerated, we'll need to include this here, so the plot_taxa labels show up here
#   
#   execpart <- tax_glom
# 
# if(execpart) {
# ps1 <- tax_glom(ps, taxrank=phyrank, NArm = TRUE) 
# 
# fixed_taxa <- ps1 %>%
#  tax_fix(unknowns = "NA")
# 
# #I have to add the "rank" here so that labels will show up on the tax plot
# fixed_taxa_transformed <- fixed_taxa  %>%
#   tax_transform("clr", rank = phyrank) 
# 
# }  
#   else
# { ps1 <- ps
# 
# fixed_taxa <- ps1 %>%
#  tax_fix(unknowns = "NA")
# 
# #I have to add the "rank" here so that labels will show up on the tax plot
# fixed_taxa_transformed <- fixed_taxa  %>%
#   tax_transform("clr") 
#   }  
# 
#   
# #no distance calculation needed for the PCA - uses the CLR-transformed microbial variables directly 
# #PCA 
# tax_transform_relab_ps1_ord <- fixed_taxa_transformed  %>% 
#   ord_calc("PCA") 
# 
# 
# #ord_explore(tax_transform_relab_ps1_ord)
#  ord_plot(tax_transform_relab_ps1_ord, color = group_var, size = 2, interactive = TRUE) +   scale_colour_brewer(palette = "Dark2")
# }
# 
# 
# 
# 
# 
# #FUNCTION TO CALCULATE PERMANOVA on CLR-TRANSFORMED AITCHISON DISTANCE 
# #same arguments as above, group_var for permanova variable to test 
# 
# 
# 
# PCA_comp_fun_perm_aitch <- function(ps, tax_glom, phyrank, group_var) {
#   
#   #same  steps as above for 
#  execpart <- tax_glom
# if(execpart) {
# ps1 <- tax_glom(ps, taxrank=phyrank, NArm = TRUE) 
# 
# fixed_taxa <- ps1 %>%
#  tax_fix(unknowns = "NA")
# 
# 
# 
# }  
#   else
# { ps1 <- ps
# 
# fixed_taxa <- ps1 %>%
#  tax_fix(unknowns = "NA")
# 
# }  
#  
#  #calculate aitchison distance - NOte that unlike the PCA, we are not transforming counts using CLR- see the dist_calc notes, but im guessing that the dist_calc does this itself 
#  aitchison_dists <- fixed_taxa %>%
#   dist_calc("aitchison")
# 
#  aitchison_perm <- aitchison_dists %>%
#   dist_permanova(
#     seed = 1234, # for set.seed to ensure reproducibility of random process
#     n_processes = 1, n_perms = 999, # you should use at least 999!
#     variables = group_var
#   )
#  
#  perm_get(aitchison_perm) %>% as.data.frame()
# 
# }
# 
# 
# ```
# 
# ```{r}
# 
# ## SAME FUNCTION AS ABOVE BUT ONLY USING ROBUST AITCHISON
# #Ordination PCA using Aitchison's Distance 
# #from the microViz tutorial: T
# #1) Transform the microbial data with the centered-log-ratio transformation
# #2) Perform PCA with the rclr-transformed features (equivalent to Aitchison distance PCoA) - use ord_calc()
# 
# #Here, the data is normalized "rCLR" as per the microviz tutorial
# #See discussion on normalization methods in README doc 
# # Will also peform a tax aggolomeration at a specified taxonomic level\
# #Note- the way this is coded, will not include NA taxonomic - Ok since only about 7% of the rel ab is unknown taxonomy
# #group_var indicates what colour the plots should be 
# 
# 
# # the plot_taxa will load taxa associated with Certain variables - can play around with this to control number of taxa loaded, or remove arg to not plot any 
# 
# 
# #Important: If you need to agglomerate, tax_glom == "TRUE" if not, "FALSE"- if false just put NA for rank 
# 
# 
# PCA_comp_fun_raitch <- function(ps, tax_glom, phyrank, group_var) {
# 
#   
#   #Conditional statement to deal with whether we want to agglomerate or not 
#   #Since we have to use the tax_transform argument, the conditional statement will have to add a few more things 
#   # the rank argument doesnthadnle the "NA rank well" 
#   #Even though we agglomerated, we'll need to include this here, so the plot_taxa labels show up here
#   
#   execpart <- tax_glom
# 
# if(execpart) {
# ps1 <- tax_glom(ps, taxrank=phyrank, NArm = TRUE) 
# 
# fixed_taxa <- ps1 %>%
#  tax_fix(unknowns = "NA")
# 
# #I have to add the "rank" here so that labels will show up on the tax plot
# fixed_taxa_transformed <- fixed_taxa  %>%
#   tax_transform(trans ="rclr", rank = phyrank) 
# 
# }  
#   else
# { ps1 <- ps
# 
# fixed_taxa <- ps1 %>%
#  tax_fix(unknowns = "NA")
# 
# fixed_taxa_transformed <- fixed_taxa  %>%
#   tax_transform(trans ="rclr") 
#   }  
# 
#   
# #no distance calculation needed for the PCA - uses the CLR-transformed microbial variables directly 
# #PCA 
# tax_transform_relab_ps1_ord <- fixed_taxa_transformed  %>% 
#   ord_calc("PCA") 
# 
# 
# #ord_explore(tax_transform_relab_ps1_ord)
#  ord_plot(tax_transform_relab_ps1_ord, color = group_var, size = 2, interactive = TRUE) +   scale_colour_brewer(palette = "Dark2")
# }
# 
# 
# 
# 
# 
# #FUNCTION TO CALCULATE PERMANOVA on CLR-TRANSFORMED AITCHISON DISTANCE 
# #same arguments as above, group_var for permanova variable to test 
# 
# 
# 
# PCA_comp_fun_perm_raitch <- function(ps, tax_glom, phyrank, group_var) {
#   
#   #same  steps as above for 
#  execpart <- tax_glom
# if(execpart) {
# ps1 <- tax_glom(ps, taxrank=phyrank, NArm = TRUE) 
# 
# fixed_taxa <- ps1 %>%
#  tax_fix(unknowns = "NA")
# 
# 
# 
# }  
#   else
# { ps1 <- ps
# 
# fixed_taxa <- ps1 %>%
#  tax_fix(unknowns = "NA")
# 
# }  
#  
#  #calculate aitchison distance - NOte that unlike the PCA, we are not transforming counts using CLR- see the dist_calc notes, but im guessing that the dist_calc does this itself 
#  aitchison_dists <- fixed_taxa %>%
#   dist_calc("robust.aitchison")
# 
#  aitchison_perm <- aitchison_dists %>%
#   dist_permanova(
#     seed = 1234, # for set.seed to ensure reproducibility of random process
#     n_processes = 1, n_perms = 999, # you should use at least 999!
#     variables = group_var
#   )
#  
#  perm_get(aitchison_perm) %>% as.data.frame()
# 
# }

```

```{r}
#PCA_comp_fun_raitch(physeqhmp2whole_vir_i, tax_glom = 'FALSE', phyrank = 'NA', group_var = "dysbiosis_binary" ) +  stat_ellipse(aes(linetype = dysbiosis_binary, colour = dysbiosis_binary), linewidth = 0.8, show.legend = FALSE) + scale_color_manual(values = dysbiosis_cols) + theme_bw() + guides(color = guide_legend(title = "Dysbiosis Status")) +  theme(legend.key = element_blank()) 

```




```{r}
#using the function above... 
# #Aitchison PCA at contig level 
# 
 dysbiosis_cols <- c("#FF964F", "#BAB86C")
 diagnosis_cols <- c("#92ddc8", "#5F9EA0", "#FF6961")
# 
# 
# 
# #=diagnosis 
# PCA_comp_fun(physeqhmp2whole_vir_i, tax_glom = 'FALSE', phyrank = 'NA', group_var = "diagnosis.x" )  +  stat_ellipse(aes(linetype = diagnosis.x, colour = diagnosis.x), linewidth = 0.8, show.legend = FALSE) + scale_color_manual(values = diagnosis_cols) + theme_bw() + guides(color = guide_legend(title = "Diagnosis")) +  theme(legend.key = element_blank())  +   theme(legend.text = element_text(size = 12)) +   theme(legend.title = element_text(size = 13))  # Adjust text size of legend title
# 
# 
# #dysbiosis 
# PCA_comp_fun(physeqhmp2whole_vir_i, tax_glom = 'FALSE', phyrank = 'NA', group_var = "dysbiosis_binary" ) +  stat_ellipse(aes(linetype = dysbiosis_binary, colour = dysbiosis_binary), linewidth = 0.8, show.legend = FALSE) + scale_color_manual(values = dysbiosis_cols) + theme_bw() + guides(color = guide_legend(title = "Dysbiosis Status")) +  theme(legend.key = element_blank())   +   theme(legend.text = element_text(size = 12)) +   theme(legend.title = element_text(size = 13))  # Adjust text size of legend title
# 
# #Aitchison PCA at family level 
# #diagnosis 
# PCA_comp_fun(physeqhmp2whole_vir_i, tax_glom = 'TRUE', phyrank = 'Family', group_var = "diagnosis.x") +  stat_ellipse(aes(linetype = diagnosis.x, colour = diagnosis.x), linewidth = 0.8, show.legend = FALSE) + scale_color_manual(values = diagnosis_cols) + theme_bw() + guides(color = guide_legend(title = "Diagnosis")) +  theme(legend.key = element_blank())   +   theme(legend.text = element_text(size = 12)) +   theme(legend.title = element_text(size = 13))  # Adjust text size of legend title
# 
# #dysbiosis
# PCA_comp_fun(physeqhmp2whole_vir_i, tax_glom = 'TRUE', phyrank = 'Family', group_var = "dysbiosis_binary" ) +  stat_ellipse(aes(linetype = dysbiosis_binary, colour = dysbiosis_binary), linewidth = 0.8, show.legend = FALSE) + scale_color_manual(values = dysbiosis_cols) + theme_bw() + guides(color = guide_legend(title = "Dysbiosis Status")) +  theme(legend.key = element_blank())   +   theme(legend.text = element_text(size = 12)) +   theme(legend.title = element_text(size = 13))  # Adjust text size of legend title
# 
# 
# 
# #PERMANOVAS Commenting these because they take a while to run
# #PCA_comp_fun_perm_aitch(physeqhmp2whole_vir_i, tax_glom = 'FALSE', phyrank = 'NA', group_var = "diagnosis.x" ) 
# PCA_comp_fun_perm_aitch(physeqhmp2whole_vir_i, tax_glom = 'FALSE', phyrank = 'NA', group_var = "dysbiosis_binary")
# 
# 
# 
# PCA_comp_fun_perm_aitch(physeqhmp2whole_vir_i, tax_glom = 'TRUE', phyrank = 'Family', group_var = "dysbiosis_binary")
# 
# 
# #PCA_comp_fun_perm_aitch(physeqhmp2whole_vir_i, tax_glom = 'TRUE', phyrank = 'Family', group_var = "diagnosis.x" )
# 
# 
# 
# #PERMANOVAS wihh Participant ID as R2 
# 
# 
# 
# #PCA_comp_fun_perm_aitch(physeqhmp2whole_vir_i, tax_glom = 'FALSE', phyrank = 'NA', group_var = "Participant.ID" ) 
# #PCA_comp_fun_perm_aitch(physeqhmp2whole_vir_i, tax_glom = 'FALSE', phyrank = 'NA', group_var = "Participant.ID" )
# 
# #PCA_comp_fun_perm_aitch(physeqhmp2whole_vir_i, tax_glom = 'TRUE', phyrank = 'Family', group_var = "Participant.ID" )
# #PCA_comp_fun_perm_aitch(physeqhmp2whole_vir_i, tax_glom = 'TRUE', phyrank = 'Family', group_var = "Participant.ID" )
# 

```




```{r}


# 
# library(vegan)
# library(multivariance)
# library(viridis)
#  #calculate aitchison distance - NOte that unlike the PCA, we are not transforming counts using CLR- see the dist_calc notes, but im guessing that the dist_calc does this itself 
# 
# 
# #metadata
# metadata_df <- read.csv("/Users/anshulsinha/Desktop/IBD_prophages_aim/bioinformatics_aim/bioinformatics_HMP_2/prop_stats_outputs/combined_metadata.csv", header = TRUE)
# metadata_df
# names(metadata_df)[names(metadata_df) == 'Sample_name'] <- 'filename'
# 
# 
# #remove samples that have no dysbiosis scores- this brings us to 1595 samples 
# metadata_df <- metadata_df[complete.cases(metadata_df$dysbiosis_binary), ]
# 
# 
# 
# 
# #vOTU level 
# 
# 
# 
# 
# 
# fixed_taxa <- physeqhmp2whole_vir_i %>%
#  tax_fix(unknowns = "NA")
# 
# 
#  
# 
#  aitchison_dists_whole_vir <- fixed_taxa %>%
#   dist_calc("aitchison") %>%
#    dist_get() 
#    
#    
# aitchison_dists_whole_vir <- as.matrix(aitchison_dists_whole_vir)
#  
#  melted_aitch_vOTU <- aitchison_dists_whole_vir  %>%
#    melt()
#  
#  melted_aitch_vOTU
#  
#  
# 
#  colnames(melted_aitch_vOTU) <- c("sample1", "sample2", "dist.aitch.vOTU")
# 
#  
#  ### Family level 
#  
#  
#  fam_ps1 <- tax_glom(physeqhmp2whole_vir_i, taxrank="Family", NArm = TRUE) 
# fixed_taxa_fam <- fam_ps1 %>%
#  tax_fix(unknowns = "NA")
#  fam_ps1
#  
#  
#  
#  aitchison_dists_whole_vir_fam <- fam_ps1 %>%
#   dist_calc("aitchison") %>%
#    dist_get() 
#  
#  
#   melted_aitch_pbf_m <- as.matrix(aitchison_dists_whole_vir_fam)
# 
#   melted_aitch_pbf <- melted_aitch_pbf_m  %>%
#    melt()
#   
#   
#   
#    colnames(melted_aitch_pbf) <- c("sample1", "sample2", "dist.aitch.pbf")
# 
#    melted_aitch_pbf
#    
#    
#    
#    
# # left join the two dist dfs - include participant info in the joined df - change column names and factor 
#    
#    
# dist.merged.all <- left_join(melted_aitch_vOTU %>% select(sample1, sample2, dist.aitch.vOTU), 
#                          melted_aitch_pbf %>% select(sample1, sample2, dist.aitch.pbf), 
#                          by = c("sample1" = "sample1", "sample2" = "sample2")) %>% 
#                        left_join(metadata_df %>% select(Participant.ID, filename), by = c("sample1" = "filename")) %>% 
#                        left_join(metadata_df %>% select(Participant.ID, filename), by = c("sample2" = "filename")) %>% 
#                         melt()
# 
# 
# colnames(dist.merged.all) <- c("sample1", "sample2", "subject1", "subject2", "metric", "value")
# dist.merged.all
# 
# dist.merged.all$metric <- factor(dist.merged.all$metric, levels = c("dist.aitch.vOTU", "dist.aitch.pbf"))
# 
# #Same subject column to allow to dinstinguish between same v same vs. same vs different comparisons. 
# 
# dist.merged.all <- dist.merged.all %>% mutate(same.subject = subject1 == subject2)
# 
# 
# dist.merged.all
# # Remove rows where 'Value' is equal to 0 because this is same v same comparison  
# dist.merged.all <- dist.merged.all[dist.merged.all$value != 0, ]
# dist.merged.all
# 
# 
# 
# #change names 
# 
# 
# dist.merged.all$same.subject = as.character(dist.merged.all$same.subject)
# dist.merged.all$metric = as.character(dist.merged.all$metric)
# 
# 
# 
# 
# dist.merged.all$same.subject[dist.merged.all$same.subject == "TRUE"] = "Intra-Individual"
# dist.merged.all$same.subject[dist.merged.all$same.subject == "FALSE"] = "Inter-Individual"
# 
# 
# dist.merged.all$metric[dist.merged.all$metric == "dist.aitch.vOTU"] = "vOTU"
# dist.merged.all$metric[dist.merged.all$metric == "dist.aitch.pbf"] = "PBF"
# 
# colors <- c("#C3B1E1", "#a0d6b4")
# 
# 
# 
# dist.merged.all$metric <- factor(dist.merged.all$metric, levels = c("vOTU", "PBF"))
# 
# 
# #try to left_join to get data based on diagnosis 
# 
# meta_test <-  hmp2_metadata_phylo
# 
# 
# # Merge the two data frames on a common key
# #df_result <- merge(dist.merged.all, meta_test, by.x = "sample1", by.y = "filename", all.x = TRUE)
# #df_result <- merge(df_result, meta_test, by.x = "sample2", by.y = "filename", all.x = TRUE)
# 
# #dist.merged.all_test <- left_join(meta_test,dist.merged.all, by="sample2")
# 
# 
# #dist.merged.all$ID <- paste(dist.merged.all)
# 
# 
# dist.merged.all
# #confirm that we have duplicate differences # 5,084,856 rows before 
# 
# dist.merged.all.delete <- dist.merged.all
# #creates a column that merges the sample 1 and 2 cols in alph order, collapses the. sample1vs2 and sample2vs1 should have the same thing 
# dist.merged.all.delete$sorted_pair <- apply(dist.merged.all.delete[, c("sample1", "sample2")], 1, function(x) paste(sort(x), collapse = "_"))
# #test shows that for this pair there are two vOTU and two PBF rows with identical values 
# dist.merged.all.delete.test <- dist.merged.all.delete[dist.merged.all.delete$sorted_pair == "C3001_0_CD_P_C3001_12_CD_P",]
# 
# 
# # Group by 'sorted_pair' and 'metric' to keep one row for each combination
# 
# dist.merged.all.delete <- dist.merged.all.delete %>%
#   group_by(sorted_pair, metric) %>%
#   slice(1) %>%  # Keeps the first row for each group
#   ungroup()
# 
# #  2,542,428 rows after
#  5084856/ 2542428
#  #equals exactly 2 
# 
# 
# #test earlier showed  that for this pair there are two vOTU and two PBF rows with identical values 
# dist.merged.all.delete.test.2 <- dist.merged.all.delete[dist.merged.all.delete$sorted_pair == "C3001_0_CD_P_C3001_12_CD_P",]
# #now there's just one per metric 
# 
# 
# 
# 
# 
# # comment out this line to combine all data into 1 plot
#   #geom_line(aes(group = interaction(sample1, sample2)), alpha = 0.2)
# 
# # 
# 
# 
# 
# # ```
# 
# 
# 
# 
# 


# 
# ```{r}
# library(reshape2)
# library(ggplot2)
# 
# 
# ##FOR the wilcoxon, I'll need to first reshape the data 
# 
# 
# 
# 
# dist.merged.all.delete.wider <- dist.merged.all.delete %>%
#   pivot_wider(names_from = metric, values_from = value)
# 
# 
# 
# 
# # Now on just intra -comparisons 
# dist.merged.all_intra <- dist.merged.all.delete.wider[dist.merged.all.delete.wider$same.subject == "Intra-Individual",]
# 
# #intra wilcox test
# wilcox.test(Pair(vOTU, PBF) ~ 1, data = dist.merged.all_intra)
# 
# 
# dist.merged.all_inter <- dist.merged.all.delete.wider[dist.merged.all.delete.wider$same.subject == "Inter-Individual",]
# 
# #inter wilox test 
# wilcox.test(Pair(vOTU, PBF) ~ 1, data = dist.merged.all_inter)
# 
# 
# #now plot with significance stars 
# 
# 
# #removing the test variable x
# rm(x)
# 
# #now plot 
#  dist.merged.all.delete  %>% 
#   ggplot(aes(x = same.subject, y = value, fill = metric)) +
#  geom_violin(scale = "width", aes(fill=metric), alpha = 0.3, position = position_dodge(width = 0.9)) +
#   geom_boxplot(outlier.shape = NA, width = 0.3, aes(fill=metric), color="black", position = position_dodge(width = 0.9)) +
#     annotate("segment", x = 0.75, xend = 1.25, y = 97, yend = 97, 
#            linetype = "solid", color = "black", size = 1) +
#      annotate("text", x = 1, y = 101, label = "****", size = 6, color = "black") +  
# 
#        annotate("segment", x = 1.75, xend = 2.25, y = 84, yend = 84, 
#            linetype = "solid", color = "black", size = 1) +
#      annotate("text", x = 2, y = 88, label = "****", size = 6, color = "black") +  
# 
#   scale_fill_viridis(discrete = T, begin = 0.1, end = 0.7, labels = labels) +
#   scale_colour_viridis(discrete = T, begin = 0.1, end = 0.7, labels = labels) +
#  # geom_jitter(alpha = 0.05) +
#   #scale_fill_brewer(palette = "Set1") + 
#   #facet_wrap(. ~ same.subject, labeller = label_parsed) + 
#    scale_fill_manual(values = colors) +  
#   scale_color_manual(values = colors) +  
#    labs(x = "Comparison", y = "Distance") +
#    labs(fill = "Distance metric") + 
#    scale_x_discrete(labels = c("Inter-individual (across)", "Intra-individual (within)")) +
#   theme_bw() 
# 
# 
# 


```

```{r}
# #I want to also restrict this analyses within certain disease groups
# 
# #step 1 left_join with metadat
# 
# # dist.merged.all.delete.joined <- dist.merged.all.delete
# 
# #step2 create diagnosis cols for sample1 and sample2
# 
# dist.merged.all.delete.joined$diagnosis.1 <- sapply(strsplit(dist.merged.all.delete.joined$sample1, "_"), function(x) x[3])
# 
# 
# dist.merged.all.delete.joined$diagnosis.2 <- sapply(strsplit(dist.merged.all.delete.joined$sample2, "_"), function(x) x[3])
# 
# 
# # now have a condition use info from the metadata to add dysbiosis status 
# 
# hmp2_metadata_phylo.subset <- hmp2_metadata_phylo %>% 
#   select(filename,diagnosis.x, dysbiosis_binary)
# 
# 
# hmp2_metadata_phylo.sample1 <- hmp2_metadata_phylo.subset
# hmp2_metadata_phylo.sample1$sample1.dysbiosis <- hmp2_metadata_phylo.sample1$dysbiosis_binary
# hmp2_metadata_phylo.sample1$sample1 <- hmp2_metadata_phylo.sample1$filename
# 
# 
# hmp2_metadata_phylo.sample2 <- hmp2_metadata_phylo.subset
# hmp2_metadata_phylo.sample2$sample2.dysbiosis <- hmp2_metadata_phylo.sample2$dysbiosis_binary
# hmp2_metadata_phylo.sample2$sample2 <- hmp2_metadata_phylo.sample2$filename
# 
# dist.merged.all.delete.joined.1 <- merge(dist.merged.all.delete.joined, hmp2_metadata_phylo.sample1, by = "sample1")
# dist.merged.all.delete.joined.2 <- merge(dist.merged.all.delete.joined.1, hmp2_metadata_phylo.sample2, by = "sample2")
# dist.merged.all.delete.joined <- dist.merged.all.delete.joined.2
# 
# 
# #how I have the same as above but with diagnosis and dysbiosis info for sample1 and 2
# 
# #now I can ensure all samples have the same diagnosis status or dysbiosis status 
# 
# dist.merged.all.delete.joined.same.diag <- dist.merged.all.delete.joined[dist.merged.all.delete.joined$diagnosis.1 == dist.merged.all.delete.joined$diagnosis.2,]
# dist.merged.all.delete.joined.same.dysb <- dist.merged.all.delete.joined[dist.merged.all.delete.joined$sample1.dysbiosis == dist.merged.all.delete.joined$sample2.dysbiosis,]
# 
# 
# 
# #can now subset for different diagnosis and dysbiosis status 
# 
# dist.merged.all.delete.joined.CD <- dist.merged.all.delete.joined.same.diag[dist.merged.all.delete.joined.same.diag$diagnosis.1 == "CD",]
# dist.merged.all.delete.joined.UC <- dist.merged.all.delete.joined.same.diag[dist.merged.all.delete.joined.same.diag$diagnosis.1 == "UC",]
# dist.merged.all.delete.joined.nonIBD <- dist.merged.all.delete.joined.same.diag[dist.merged.all.delete.joined.same.diag$diagnosis.1 == "nonIBD",]
# 
# 
# dist.merged.all.delete.joined.dysb <- dist.merged.all.delete.joined.same.dysb[dist.merged.all.delete.joined.same.dysb$sample1.dysbiosis == "Yes",]
# dist.merged.all.delete.joined.nodysb <- dist.merged.all.delete.joined.same.dysb[dist.merged.all.delete.joined.same.dysb$sample1.dysbiosis == "No",]
# 
# 
# 





```

```{r}
#plot CD 

# 
# dist.merged.all.delete.wider.CD <- dist.merged.all.delete.joined.CD %>%
#   pivot_wider(names_from = metric, values_from = value)
# 
# 
# 
# 
# # Now on just intra -comparisons 
# dist.merged.all_intra.CD <- dist.merged.all.delete.wider.CD[dist.merged.all.delete.wider.CD$same.subject == "Intra-Individual",]
# 
# #intra wilcox test
# wilcox.test(Pair(vOTU, PBF) ~ 1, data = dist.merged.all_intra.CD)
# 
# 
# dist.merged.all_inter.CD <- dist.merged.all.delete.wider.CD[dist.merged.all.delete.wider.CD$same.subject == "Inter-Individual",]
# 
# #inter wilox test 
# wilcox.test(Pair(vOTU, PBF) ~ 1, data = dist.merged.all_inter.CD)
# 
# 
# #now plot 
#  dist.merged.all.delete.joined.CD  %>% 
#   ggplot(aes(x = same.subject, y = value, fill = metric)) +
#  geom_violin(scale = "width", aes(fill=metric), alpha = 0.3, position = position_dodge(width = 0.9)) +
#   geom_boxplot(outlier.shape = NA, width = 0.3, aes(fill=metric), color="black", position = position_dodge(width = 0.9)) +
#     annotate("segment", x = 0.75, xend = 1.25, y = 97, yend = 97, 
#            linetype = "solid", color = "black", size = 1) +
#      annotate("text", x = 1, y = 101, label = "****", size = 6, color = "black") +  
# 
#        annotate("segment", x = 1.75, xend = 2.25, y = 84, yend = 84, 
#            linetype = "solid", color = "black", size = 1) +
#      annotate("text", x = 2, y = 88, label = "****", size = 6, color = "black") +  
# 
#   scale_fill_viridis(discrete = T, begin = 0.1, end = 0.7, labels = labels) +
#   scale_colour_viridis(discrete = T, begin = 0.1, end = 0.7, labels = labels) +
#  # geom_jitter(alpha = 0.05) +
#   #scale_fill_brewer(palette = "Set1") + 
#   #facet_wrap(. ~ same.subject, labeller = label_parsed) + 
#    scale_fill_manual(values = colors) +  
#   scale_color_manual(values = colors) +  
#    labs(x = "Comparison", y = "Distance") +
#    labs(fill = "Distance metric") + 
#    scale_x_discrete(labels = c("Inter-individual (across)", "Intra-individual (within)")) +
#   theme_bw() + 
#      ggtitle("CD Patients")
# #now plot with significance stars 

```

```{r}
#plot UC

# 
# 
# # Now on just intra -comparisons 
# dist.merged.all_intra.UC <- dist.merged.all.delete.wider.UC[dist.merged.all.delete.wider.UC$same.subject == "Intra-Individual",]
# 
# #intra wilcox test
# wilcox.test(Pair(vOTU, PBF) ~ 1, data = dist.merged.all_intra.UC)
# 
# 
# dist.merged.all_inter.UC <- dist.merged.all.delete.wider.UC[dist.merged.all.delete.wider.UC$same.subject == "Inter-Individual",]
# 
# #inter wilox test 
# wilcox.test(Pair(vOTU, PBF) ~ 1, data = dist.merged.all_inter.UC)
# 
# 
# #now plot 
#  dist.merged.all.delete.joined.UC  %>% 
#   ggplot(aes(x = same.subject, y = value, fill = metric)) +
#  geom_violin(scale = "width", aes(fill=metric), alpha = 0.3, position = position_dodge(width = 0.9)) +
#   geom_boxplot(outlier.shape = NA, width = 0.3, aes(fill=metric), color="black", position = position_dodge(width = 0.9)) +
#     annotate("segment", x = 0.75, xend = 1.25, y = 97, yend = 97, 
#            linetype = "solid", color = "black", size = 1) +
#      annotate("text", x = 1, y = 101, label = "****", size = 6, color = "black") +  
# 
#        annotate("segment", x = 1.75, xend = 2.25, y = 84, yend = 84, 
#            linetype = "solid", color = "black", size = 1) +
#      annotate("text", x = 2, y = 88, label = "****", size = 6, color = "black") +  
# 
#   scale_fill_viridis(discrete = T, begin = 0.1, end = 0.7, labels = labels) +
#   scale_colour_viridis(discrete = T, begin = 0.1, end = 0.7, labels = labels) +
#  # geom_jitter(alpha = 0.05) +
#   #scale_fill_brewer(palette = "Set1") + 
#   #facet_wrap(. ~ same.subject, labeller = label_parsed) + 
#    scale_fill_manual(values = colors) +  
#   scale_color_manual(values = colors) +  
#    labs(x = "Comparison", y = "Distance") +
#    labs(fill = "Distance metric") + 
#    scale_x_discrete(labels = c("Inter-individual (across)", "Intra-individual (within)")) +
#   theme_bw() + 
#      ggtitle("UC Patients")
# #now plot with significance stars 
#  
#  
#  
# ```
# ```{r}
# #plot non IBD
# 37/2
# 
# dist.merged.all.delete.wider.nonIBD <- dist.merged.all.delete.joined.nonIBD %>%
#   pivot_wider(names_from = metric, values_from = value)
# 
# 
# 
# 
# # Now on just intra -comparisons 
# dist.merged.all_intra.nonIBD <- dist.merged.all.delete.wider.nonIBD[dist.merged.all.delete.wider.nonIBD$same.subject == "Intra-Individual",]
# 
# #intra wilcox test
# wilcox.test(Pair(vOTU, PBF) ~ 1, data = dist.merged.all_intra.nonIBD)
# 
# 
# dist.merged.all_inter.nonIBD <- dist.merged.all.delete.wider.nonIBD[dist.merged.all.delete.wider.nonIBD$same.subject == "Inter-Individual",]
# 
# #inter wilox test 
# wilcox.test(Pair(vOTU, PBF) ~ 1, data = dist.merged.all_inter.nonIBD)
# 
# 
# #now plot 
#  dist.merged.all.delete.joined.nonIBD  %>% 
#   ggplot(aes(x = same.subject, y = value, fill = metric)) +
#  geom_violin(scale = "width", aes(fill=metric), alpha = 0.3, position = position_dodge(width = 0.9)) +
#   geom_boxplot(outlier.shape = NA, width = 0.3, aes(fill=metric), color="black", position = position_dodge(width = 0.9)) +
#     annotate("segment", x = 0.75, xend = 1.25, y = 97, yend = 97, 
#            linetype = "solid", color = "black", size = 1) +
#      annotate("text", x = 1, y = 101, label = "****", size = 6, color = "black") +  
# 
#        annotate("segment", x = 1.75, xend = 2.25, y = 84, yend = 84, 
#            linetype = "solid", color = "black", size = 1) +
#      annotate("text", x = 2, y = 88, label = "****", size = 6, color = "black") +  
# 
#   scale_fill_viridis(discrete = T, begin = 0.1, end = 0.7, labels = labels) +
#   scale_colour_viridis(discrete = T, begin = 0.1, end = 0.7, labels = labels) +
#  # geom_jitter(alpha = 0.05) +
#   #scale_fill_brewer(palette = "Set1") + 
#   #facet_wrap(. ~ same.subject, labeller = label_parsed) + 
#    scale_fill_manual(values = colors) +  
#   scale_color_manual(values = colors) +  
#    labs(x = "Comparison", y = "Distance") +
#    labs(fill = "Distance metric") + 
#    scale_x_discrete(labels = c("Inter-individual (across)", "Intra-individual (within)")) +
#   theme_bw() + 
#      ggtitle("Non-IBD Samples")
# 
# #now plot with significance stars 
# 
# ```
# ```{r}
# #plot dysbiotic samples 
# 
# 
# dist.merged.all.delete.wider.dysbiotic.samples <- dist.merged.all.delete.joined.dysb %>%
#   pivot_wider(names_from = metric, values_from = value)
# 
# 
# 
# 
# # Now on just intra -comparisons 
# dist.merged.all_intra.dysb <- dist.merged.all.delete.wider.dysbiotic.samples[dist.merged.all.delete.wider.dysbiotic.samples$same.subject == "Intra-Individual",]
# 
# #intra wilcox test
# wilcox.test(Pair(vOTU, PBF) ~ 1, data = dist.merged.all_intra.dysb)
# 
# 
# dist.merged.all_inter.dysb <- dist.merged.all.delete.wider.dysbiotic.samples[dist.merged.all.delete.wider.dysbiotic.samples$same.subject == "Inter-Individual",]
# 
# #inter wilox test 
# wilcox.test(Pair(vOTU, PBF) ~ 1, data = dist.merged.all_inter.dysb)
# 
# 
# #now plot 
#  plot.dysb <- dist.merged.all.delete.joined.dysb  %>% 
#   ggplot(aes(x = same.subject, y = value, fill = metric)) +
#  geom_violin(scale = "width", aes(fill=metric), alpha = 0.3, position = position_dodge(width = 0.9)) +
#   geom_boxplot(outlier.shape = NA, width = 0.3, aes(fill=metric), color="black", position = position_dodge(width = 0.9)) +
#     annotate("segment", x = 0.75, xend = 1.25, y = 97, yend = 97, 
#            linetype = "solid", color = "black", size = 1) +
#      annotate("text", x = 1, y = 101, label = "****", size = 6, color = "black") +  
# 
#        annotate("segment", x = 1.75, xend = 2.25, y = 84, yend = 84, 
#            linetype = "solid", color = "black", size = 1) +
#      annotate("text", x = 2, y = 88, label = "****", size = 6, color = "black") +  
# 
#   scale_fill_viridis(discrete = T, begin = 0.1, end = 0.7, labels = labels) +
#   scale_colour_viridis(discrete = T, begin = 0.1, end = 0.7, labels = labels) +
#  # geom_jitter(alpha = 0.05) +
#   #scale_fill_brewer(palette = "Set1") + 
#   #facet_wrap(. ~ same.subject, labeller = label_parsed) + 
#    scale_fill_manual(values = colors) +  
#   scale_color_manual(values = colors) +  
#    labs(x = "Comparison", y = "Distance") +
#    labs(fill = "Distance metric") + 
#    scale_x_discrete(labels = c("Inter-individual (across)", "Intra-individual (within)")) +
#   theme_bw() + 
#      ggtitle("Dysbiotic Samples")
# #now plot with significance stars 
# 
# 
# 
#  
#  
 
```

```{r}
# #plot non-dysbiotic samples 
# 
# 
# dist.merged.all.delete.wider.nodysb <- dist.merged.all.delete.joined.nodysb %>%
#   pivot_wider(names_from = metric, values_from = value)
# 
# 
# 
# 
# # Now on just intra -comparisons 
# dist.merged.all_intra.nodysb <- dist.merged.all.delete.wider.nodysb[dist.merged.all.delete.wider.nodysb$same.subject == "Intra-Individual",]
# 
# #intra wilcox test
# wilcox.test(Pair(vOTU, PBF) ~ 1, data = dist.merged.all_intra.nodysb)
# 
# 
# dist.merged.all_inter.nodysb <- dist.merged.all.delete.wider.nodysb[dist.merged.all.delete.wider.nodysb$same.subject == "Inter-Individual",]
# 
# #inter wilox test 
# wilcox.test(Pair(vOTU, PBF) ~ 1, data = dist.merged.all_inter.nodysb)
# 
# 
# #now plot 
# plot.nodysb <- dist.merged.all.delete.joined.nodysb  %>% 
#   ggplot(aes(x = same.subject, y = value, fill = metric)) +
#  geom_violin(scale = "width", aes(fill=metric), alpha = 0.3, position = position_dodge(width = 0.9)) +
#   geom_boxplot(outlier.shape = NA, width = 0.3, aes(fill=metric), color="black", position = position_dodge(width = 0.9)) +
#     annotate("segment", x = 0.75, xend = 1.25, y = 97, yend = 97, 
#            linetype = "solid", color = "black", size = 1) +
#      annotate("text", x = 1, y = 101, label = "****", size = 6, color = "black") +  
# 
#        annotate("segment", x = 1.75, xend = 2.25, y = 84, yend = 84, 
#            linetype = "solid", color = "black", size = 1) +
#      annotate("text", x = 2, y = 88, label = "****", size = 6, color = "black") +  
# 
#   scale_fill_viridis(discrete = T, begin = 0.1, end = 0.7, labels = labels) +
#   scale_colour_viridis(discrete = T, begin = 0.1, end = 0.7, labels = labels) +
#  # geom_jitter(alpha = 0.05) +
#   #scale_fill_brewer(palette = "Set1") + 
#   #facet_wrap(. ~ same.subject, labeller = label_parsed) + 
#    scale_fill_manual(values = colors) +  
#   scale_color_manual(values = colors) +  
#    labs(x = "Comparison", y = "Distance") +
#    labs(fill = "Distance metric") + 
#    scale_x_discrete(labels = c("Inter-individual (across)", "Intra-individual (within)")) +
#   theme_bw() + 
#      ggtitle("Non-Dysbiotic Samples")
# #now plot with significance stars 
```









```{r}
# ####CALCULATE STABILITY ####
# 
# ##DOUBLE CHECK THAT
# 
# 
# #add a metadata column for "time point " - converting week number to time point (ie- week 0,2,9 = 1,2,3)
# 
# test_metadata <- hmp2_metadata_phylo
# test_metadata <- test_metadata[order(test_metadata$Participant.ID, test_metadata$week_num), ]
# test_metadata$time_point <- sequence(rle(test_metadata$Participant.ID)$lengths)
# 
# 
# 
# #Filter for just intra comparisons 
# 
# dist.merged.all.filt.timepoints <- dist.merged.all %>% 
#   #Filter for just intra comparisons 
#   filter(same.subject == "Intra-Individual") %>% 
#   #unclear what this line is doing- ask Michael 
#   filter(!metric %in% c("dist.aitch.filt", "dist.aitch.filt.pbf")) %>% 
#   select(sample1, sample2, metric, value) %>% 
#   left_join(test_metadata %>% select(time_point, filename, Participant.ID), by = c("sample1" = "filename")) %>% 
#   left_join(test_metadata %>% select(time_point, filename, Participant.ID), by = c("sample2" = "filename"), suffix = c(".sample1", ".sample2")) %>% 
#   mutate()
# 
# 
# 
# #class(dist.merged.all.filt.intra$time_point.sample1
# #) <- "numeric"
# #class(dist.merged.all.filt.intra$time_point.sample2) <- "numeric"
# 
# 
# # this is for dates
# dist.merged.all.filt.timepoints2 <- aggregate(value ~ Participant.ID.sample1 + time_point.sample1 + time_point.sample2 + metric, 
#                                              data = dist.merged.all.filt.timepoints, 
#                                              FUN = mean)
# 
# dist.merged.all.filt.timepoints.final <- dist.merged.all.filt.timepoints %>% 
#   mutate(timepoint_after = time_point.sample2 > time_point.sample1) %>%  # Time_point.sample2 > Time_point.sample1
#   filter(timepoint_after) %>% 
#   mutate(timepoint_diff = time_point.sample2 - time_point.sample1) %>% # Time_point.sample2 - Time_point.sample1
#   group_by(Participant.ID.sample1, metric, time_point.sample1) %>% # Time_point.sample1
#   arrange(timepoint_diff) %>% 
#   slice(1)
# 
# 
# # Date.sample2 or Time_point.sample2
# dist.merged.all.filt.timepoints.final %>% ggplot(aes(x = time_point.sample2, y = value, group = metric, color = metric)) +
#   geom_line() +
#   geom_point() +
#   scale_colour_viridis(discrete = T, begin = 0.1, end = 0.7, labels = labels) +
#   #facet_wrap(. ~ Participant.ID.sample1) +
#   #xlim(1,15) +
#   theme_bw()
# 
# 
# 
# 
# test_metadata <- hmp2_metadata_phylo 
# test_metadata <- test_metadata %>%
#   select(Participant.ID, diagnosis.x) 
# 
# 
# colnames(test_metadata) <- c("Participant.ID.sample1", "Diagnosis")
# 
# 
# dist.merged.all.filt.timepoints.final_meta <- left_join(dist.merged.all.filt.timepoints.final, test_metadata, by= "Participant.ID.sample1")
# 
# dist.merged.all.filt.timepoints.final_meta <- unique(dist.merged.all.filt.timepoints.final_meta)
# 
# #AITCHISON DISTANCE IS NOT LIKE BRAY - so Im plotting distance (not stability ie- 1-Bray)
# 
# dist.merged.all.filt.timepoints.final_meta %>% 
#   filter(!metric %in% c("vOTU")) %>% 
#   ggplot(aes(x = Participant.ID.sample1, y = value, group = interaction(Participant.ID.sample1, metric), color = metric)) +
#     geom_violin(scale = "width", aes(fill=metric), alpha = 0.3, position = position_dodge(width = 0.9)) +
#     geom_boxplot(outlier.shape = NA, width = 0.3, aes(fill = metric), color = "black", position = position_dodge(width = 0.9)) +
#     scale_fill_viridis(discrete = T, begin = 0.1, end = 0.3, labels = labels) +  
#     scale_colour_viridis(discrete = T, begin = 0.1, end = 0.3, labels = labels) +
#     theme_bw() +
#     labs(x = "Individual", y = "Stability\n(1 - distance)", color = "Distance metric", fill = "Distance metric") + 
#     facet_wrap(. ~ Diagnosis)
# 
# 
# 
# 
# 
# 
# 
# dist.merged.all.filt.timepoints.final_meta %>% 
#   filter(!metric %in% c("PBF")) %>% 
#   ggplot(aes(x = Participant.ID.sample1, y = value, group = interaction(Participant.ID.sample1, metric), color = metric)) +
#   geom_violin(scale = "width", aes(fill=metric), alpha = 0.3, position = position_dodge(width = 0.9)) +
#     geom_boxplot(outlier.shape = NA, width = 0.3, aes(fill = metric), color = "black", position = position_dodge(width = 0.9)) +
#     scale_fill_viridis(discrete = T, begin = 0.1, end = 0.3, labels = labels) +  
#     scale_colour_viridis(discrete = T, begin = 0.1, end = 0.3, labels = labels) +
#     theme_bw() +
#     labs(x = "Individual", y = "Stability\n(1 - distance)", color = "Distance metric", fill = "Distance metric") + 
#      facet_wrap(. ~ Diagnosis)
# 
# 
# 
# 
# #Filter for just PBF
# 
# dist.merged.all.filt.timepoints.final_meta_PBF <- dist.merged.all.filt.timepoints.final_meta %>% 
#   filter(!metric %in% c("vOTU"))
# 
# 
# #Filter for just vOTU
# 
# 
# dist.merged.all.filt.timepoints.final_meta_votu <- dist.merged.all.filt.timepoints.final_meta %>% 
#   filter(!metric %in% c("PBF"))
# 
# 
# dist.merged.all.filt.timepoints.final_meta_agg_vOTU <-  aggregate(value ~ Diagnosis, data = dist.merged.all.filt.timepoints.final_meta_votu, FUN = mean)
# dist.merged.all.filt.timepoints.final_meta_agg_PBF <-  aggregate(value ~ Diagnosis, data = dist.merged.all.filt.timepoints.final_meta_PBF, FUN = mean)
# 
# 
# 
# #Filter for just vOTU 
# #calculate the Mean value for each individual at the PBF level 
# 
# 
# PBF_grouped <- dist.merged.all.filt.timepoints.final_meta_PBF %>%
# group_by(Participant.ID.sample1) %>%
#     # Calculate the mean of the "Frequency" column for each group
#     summarise_at(vars(value),
#                  list(mean_values = mean)) 
#   
#   
# unique_metadata <- unique(test_metadata)
# unique_metadata <- unique_metadata %>%
#   select(Participant.ID.sample1
# , Diagnosis) 
# 
# 
# PBF_grouped <- left_join(PBF_grouped, unique_metadata, by= "Participant.ID.sample1")
# 
# 
# #write.csv(PBF_grouped, "/Users/anshulsinha/Desktop/IBD_prophages_aim/bioinformatics_aim/bioinformatics_HMP_2/free_virome/free_virome_09_23/diversity_analyses/whole_virome_PBF_instability.csv")
# mean_vals <-  aggregate(mean_values ~ Diagnosis, data = PBF_grouped, FUN = mean)
# 
# 
# #PLOT 
# 
# 
# 
# PBF_grouped %>% 
#   ggplot(aes(x = Diagnosis, y = mean_values, color = Diagnosis)) +
#       geom_boxplot(width = 0.5, colour = "grey35", outlier.shape = NA) +
#       geom_jitter(width = 0.2, alpha = 0.5, aes(color = Diagnosis)) + 
#     theme_bw() +
#     labs(x = "Individual", y = "Instability (Aitchison's Distance Between Consecutive Time Points)", color = "Distance metric", fill = "Distance metric") +
#       scale_color_manual(values = diagnosis_cols) 
# 




```



```{r}

```



```{r}

library(vegan)
library(tidyverse)
library(ggplot2)
library(graphics)
library(cowplot)
###READ COUNT INFO#####


reads_sample <- readcount(physeqhmp2whole_vir_i)



physeqhmp2whole_vir_i

read.counts.df <- as.data.frame(reads_sample)

rownames_to_column(read.counts.df)
colnames(read.counts.df)




ggplot(read.counts.df, aes(x = reads_sample)) + 
    geom_histogram(color = "black", fill = "indianred", binwidth = 350) 

hist(read.counts.df$reads_sample)








## Now lets see if sampling depth is sufficient

#step1 calculate Good's coveage

ps_melt_whole_vir <-  ps_melt(physeqhmp2whole_vir_i) 




 goods.data <- ps_melt_whole_vir %>% 
  group_by(Sample) %>%
  summarise(nseqs= sum(Abundance),
            n_singletons = sum(Abundance == 1), 
            goods = 100*(1- n_singletons/nseqs)) 


  goods.plot <- goods.data %>% 
  ggplot(aes(x=nseqs, y=goods)) +
    geom_point()
  

goods.data <- na.omit(goods.data)

mean(goods.data$goods)

#step2 rarefaction curve  

mat <- as(t(otu_table(physeqhmp2whole_vir_i)), "matrix")
raremax <- min(rowSums(mat))



random_rows <- sample(nrow(mat), 50)
matrix.sub <- mat[random_rows, ]


subset_mat.pre.filt <- mat[1:50, ]

rarecurve(subset_mat.pre.filt, step = 20, sample = raremax, col = "coral", cex = 0.6, label = FALSE, main="Before Filtering")



median(goods.data$goods)

# filter samples that have less than 1500 counts 


subset_1500 <-  subset_samples(physeqhmp2whole_vir_i, length_normalized_read_count > 1500)
mat.1500 <- as(t(otu_table(subset_1500)), "matrix")


random_rows <- sample(nrow(mat.1500), 50)
matrix.sub <- mat.1500[random_rows, ]


#raremax <- min(rowSums(mat))




rarecurve(matrix.sub, step = 20, col = "coral", cex = 0.6, label = FALSE, main = "After Filtering") 

#combine 



#calculate Good's for filtered PS

ps_melt_whole_vir.1500 <-  ps_melt(subset_1500) 


 goods.data.1500 <- ps_melt_whole_vir.1500 %>% 
  group_by(Sample) %>%
  summarise(nseqs= sum(Abundance),
            n_singletons = sum(Abundance == 1), 
            goods = 100*(1- n_singletons/nseqs)) 
  
   
   
  goods.plot.1500 <- goods.data.1500 %>% 
  ggplot(aes(x=nseqs, y=goods)) +
    geom_point() + 
    ylim(0,100)
  
  goods.data.1500 <- na.omit(goods.data.1500)

mean(goods.data.1500$goods)
median(goods.data.1500$goods)


#cowplot both good's 


  goods.plot <- goods.data %>% 
  ggplot(aes(x=nseqs, y=goods)) +
    geom_point() + 
        xlab("Number of Length-Normalized Reads") + 
        ylab("Good's Coverage") +
        ggtitle("Before Filtering")

  
  goods.plot.1500 <- goods.data.1500 %>% 
  ggplot(aes(x=nseqs, y=goods)) +
    geom_point() + 
    ylim(0,100) + 
        xlab("Number of Length-Normalized Reads") + 
        ylab("Good's Coverage") + 
        ggtitle("After Filtering")

    
    
  


goods_plot_combined <- plot_grid(goods.plot, goods.plot.1500)




#COMPARE BREAKDOWN OF SAMPLES BEFORE/AFTER
#What is breakdown of diagnosis/dysbiosis? 

# Count the number of rows per diagnosis
whole.vir.sampledata <-  data.frame(sample_data(physeqhmp2whole_vir_i))



# Count the number of rows per diagnosis
diagnosis_counts <- whole.vir.sampledata %>%
  dplyr::count(diagnosis.x)
  
  

# Calculate the percentage for labels
diagnosis_counts <- diagnosis_counts %>%
  mutate(percentage = n / sum(n) * 100,
         label = paste0(diagnosis.x, ": ", n, " (", round(percentage, 1), "%)"))

# Create the pie chart with labels
diag_pie <- ggplot(diagnosis_counts, aes(x = "", y = n, fill = diagnosis.x)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar(theta = "y") +
  labs(fill = "Diagnosis", y = "Count", x = "") +
  theme_void() +  # Removes axes and background
  theme(legend.position = "right") +
  geom_text(aes(label = label), position = position_stack(vjust = 0.5), size = 3) + 
  ggtitle("Before Filtering")


# Count the number of rows per dysbiosis
dybsiosis_counts <- whole.vir.sampledata %>%
  dplyr::count(dysbiosis_binary)

# Calculate the percentage for labels
dybsiosis_counts <- dybsiosis_counts %>%
  mutate(percentage = n / sum(n) * 100,
         label = paste0(dysbiosis_binary, ": ", n, " (", round(percentage, 1), "%)"))

# Create the pie chart with labels
dysb_pie <- ggplot(dybsiosis_counts, aes(x = "", y = n, fill = dysbiosis_binary)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar(theta = "y") +
  labs(fill = "Dysbiosis", y = "Count", x = "") +
  theme_void() +  # Removes axes and background
  theme(legend.position = "right") +
  geom_text(aes(label = label), position = position_stack(vjust = 0.5), size = 3) + 
  ggtitle("Before Filtering")





#number of reads between groups 
read.counts.df.merged <- read.counts.df %>%
  rownames_to_column(var = "filename") 

read.counts.df.merged <- left_join(read.counts.df.merged,hmp2_metadata_phylo, by="filename")


#Compare disease status vs. Diagnosis Status 

ggplot(read.counts.df.merged, aes(x=diagnosis.x, y=reads_sample, fill = diagnosis.x))+
  geom_boxplot() + 
  theme_minimal()



#disease 
kruskal.test(reads_sample ~ diagnosis.x, data = read.counts.df.merged)
pairwise.wilcox.test(read.counts.df.merged$reads_sample, read.counts.df.merged$diagnosis.x,
                 p.adjust.method = "BH")



#dysbiosis 

ggplot(read.counts.df.merged, aes(x=dysbiosis_binary, y=reads_sample, fill = dysbiosis_binary))+
  geom_boxplot() + 
  theme_minimal()


wilcox.test(reads_sample ~ dysbiosis_binary, data = read.counts.df.merged)



####BEFORE#####
filtered.sampledata <-  data.frame(sample_data(physeqhmp2whole_vir_i))

unique.sampledata <- filtered.sampledata[!duplicated(filtered.sampledata$Participant.ID),]


length(unique(unique.sampledata$Participant.ID)) #130 individuals before filtering 

table(unique.sampledata$diagnosis.x) #27 non IBD, 65 CD, 38 UC before filtering 





####AFTER####

filtered.1500.sampledata <-  data.frame(sample_data(subset_1500))


filtered.1500.taxtab <- data.frame(tax_table(subset_1500))
#get unique number of individuals 

length(unique(filtered.1500.sampledata$Participant.ID)) #115 samples after filtering 

unique.1500 <- filtered.1500.sampledata[!duplicated(filtered.1500.sampledata$Participant.ID),]

table(unique.1500$diagnosis.x) #27 non IBD, 57 CD, 31 UC after filtering 



length(unique(filtered.1500.sampledata$filename)) #1093 samples after filtering 
length(unique(read.counts.df$filename)) #1595 samples before






#COMPARE BREAKDOWN OF SAMPLES BEFORE/AFTER
#What is breakdown of diagnosis/dysbiosis? 
# Count the number of rows per diagnosis


diagnosis_counts.1500 <- filtered.1500.sampledata %>%
  dplyr::count(diagnosis.x)


# Calculate the percentage for labels
diagnosis_counts.1500 <- diagnosis_counts.1500 %>%
  mutate(percentage = n / sum(n) * 100,
         label = paste0(diagnosis.x, ": ", n, " (", round(percentage, 1), "%)"))


# Create the pie chart with labels
diag_pie_after <- ggplot(diagnosis_counts.1500, aes(x = "", y = n, fill = diagnosis.x)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar(theta = "y") +
  labs(fill = "Diagnosis", y = "Count", x = "") +
  theme_void() +  # Removes axes and background
  theme(legend.position = "right") +
   geom_text(aes(label = label), position = position_stack(vjust = 0.5), size = 3) + 
  ggtitle("After Filtering")

# Count the number of rows per dysbi
dysbiosis.counts.1500 <- filtered.1500.sampledata %>%
  dplyr::count(dysbiosis_binary)


# Calculate the percentage for labels
dysbiosis.counts.1500 <- dysbiosis.counts.1500 %>%
  mutate(percentage = n / sum(n) * 100,
         label = paste0(dysbiosis_binary, ": ", n, " (", round(percentage, 1), "%)"))


# Create the pie chart with labels
dysb_pie_after <-  ggplot(dysbiosis.counts.1500, aes(x = "", y = n, fill = dysbiosis_binary)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar(theta = "y") +
  labs(fill = "Dysbiosis", y = "Count", x = "") +
  theme_void() +  # Removes axes and background
  theme(legend.position = "right") +
   geom_text(aes(label = label), position = position_stack(vjust = 0.5), size = 3) + 
  ggtitle("After Filtering")

pie_diag_plot_combined <- plot_grid(diag_pie, diag_pie_after)
pie_diag_plot_combined
pie_dysb_plot_combined <- plot_grid(dysb_pie, dysb_pie_after, align = "v")
pie_dysb_plot_combined

all_combined <- plot_grid(diag_pie, diag_pie_after,dysb_pie, dysb_pie_after, align = "v")
```





```{r}

#Before creating functions to calculate distance and plot PCoAs, let's do a sanity check 


ps1.test <- tax_glom(subset_1500, taxrank="Family", NArm = TRUE) 
ps1.test.2 <- tax_glom(subset_1500, taxrank="Family", NArm = FALSE) 


subset_1500 #3,886 taxa if not tax glomming
ps1.test #74 if I tax glom and remove those that don't have family designations 
ps1.test.2



ps.melt.1500 <- 
unique(tax_table(subset_1500)[,"Family"])


tax_glom(subset_1500, taxrank="Family", NArm = TRUE) 





```


```{r}


#this will tell us how many iphop predictions are in the filtered samples 


filtered.1500.df_hmp_virome <- ps_melt(subset_1500)
filtered.1500.df_hmp_virome$contigname <- filtered.1500.df_hmp_virome$OTU



#get names of those samples 

filtered.1500.sampledata <-  data.frame(sample_data(subset_1500))

sample.names.1500 <- filtered.1500.sampledata$filename

#filter df_hmp_virome for those counts 
filtered.1500.df_hmp_virome <- df_hmp_virome %>%
  filter(filename %in% sample.names.1500)


df_hmp_virome_merged.2 <- left_join(filtered.1500.df_hmp_virome, hmp2_vir_iphop, by="contigname")

length(unique(df_hmp_virome_merged.2$contigname)) ##3,870 vOTUs in those samples!!!!

#what percentage have a Family level prediction

df_hmp_virome_merged.2



df_hmp_virome_merged.2.not.na <- df_hmp_virome_merged.2[!is.na(df_hmp_virome_merged.2$Family),]
length(unique(df_hmp_virome_merged.2.not.na$contigname)) ##3,370 vOTUs in those samples!!!!



3370/3870 
#what percentage of contigs have a prediction. - 87.08% = 87.1%

#how many PHFs
length(unique(df_hmp_virome_merged.2.not.na$Family)) ##74







######
df_unique <- df_hmp_virome_merged.2 %>% distinct(contigname, .keep_all = TRUE)

df_unique.2 <- df_unique %>% mutate_all(~replace(., is.na(.), "unclassified"))

df_unique.2.counts <- df_unique.2 %>% 
  group_by(Family) %>% 
  summarize(count=n_distinct(contigname))


# Summarize the data
df_unique.2.counts.summary <- df_unique.2.counts %>%
  group_by(Family) %>%
  summarize(TotalCount = sum(count)) %>%
  ungroup() %>%
  arrange(desc(TotalCount))

top_families <- df_unique.2.counts.summary %>%
  top_n(11, TotalCount) %>%
  mutate(Family = as.character(Family))



other_count <- df_unique.2.counts.summary %>%
  filter(!Family %in% top_families$Family) %>%
  summarize(Family = "Other", TotalCount = sum(TotalCount))


final_data <- bind_rows(top_families, other_count)

final_data$totalsum <- sum(final_data$TotalCount)

final_data$proportion <- final_data$TotalCount/final_data$totalsum 




ggplot(final_data, aes(x = "", y = proportion, fill = Family)) +
  geom_bar(stat = "identity") +
  labs(y = "Value", fill = "Subcategory") +
scale_y_continuous(labels = scales::percent_format()) +
    scale_fill_manual(values = brewer.pal(12, "Set3")) +
  labs(y = "Relative Proportion", x = "PHF", fill = "KEGG Metabolism Category") +
  theme_minimal() + 
    theme(axis.text.x = element_text(size = 8,angle = 45, hjust = 1, face="italic")) + 
  
  theme(
    legend.key.size = unit(0.2, "cm"),  # Key size
    legend.text = element_text(size = 9)  # Text size
  ) + 
  theme(legend.title = element_text(size = 12, hjust = 0.5))




#Find out what proportion are VIBRANT-predicted proviruses 
#filter by checking which contain "fragment" which VIBRANT uses to append contig names for predicted prophages 

# Filter rows where 'contigname' contains '_fragment'
df_unique_fragment <- df_unique[grep("_fragment", df_unique$contigname), ]


#in total, we have 907 proviruses 

table(df_unique_fragment$Lifestyle)


```








```{r}
#now rarefy and perform distance calculations 
#look at distance 



rarefied.reads.1500 <-  rarefy_even_depth(subset_1500, sample.size = min(sample_sums(subset_1500)),
  rngseed = 1, replace = TRUE, trimOTUs = TRUE, verbose = TRUE)


#Make a function that creates a PcoA plot at the vOTU level 
#Take a phyloseq object and distance matrix and the groups for comparison 
###USE A RAREFIED PS OBJECT IF USING BRAY 
#### USE A NON-RAREFIED PS IF USING AITCH



PCoA_vOTU  <- function(ps, distance, group_var) {

#can directly calculate bray distance from here since we have rarefied 
ps.fixed <- ps %>%
 tax_fix(unknowns = "NA")
  

dist.ps.fixed <- ps.fixed  %>% 
  dist_calc(distance)
    
dist.ps.fixed.ord <- dist.ps.fixed  %>% 
  ord_calc("PCoA") 

 ord_plot(dist.ps.fixed.ord, color = group_var, size = 2, interactive = FALSE) + 
   scale_colour_brewer(palette = "Dark2")
 
  
}


#Make a function that creates a PcoA plot at the vOTU level 
#Take a phyloseq object and distance matrix and the groups for comparison 
###USE A RAREFIED PS OBJECT IF USING BRAY 
#### USE A NON-RAREFIED PS IF USING AITCH
PCoA_PBF  <- function(ps, distance, group_var) {


  
ps1 <- tax_glom(ps, taxrank="Family", NArm = TRUE) 

dist.ps.fixed <- ps1 %>%
 tax_fix(unknowns = "NA") %>%
  dist_calc(distance)
  

  

fixed.ps.dist.ord <- dist.ps.fixed  %>% 
  ord_calc("PCoA")
 
 ord_plot(fixed.ps.dist.ord, color = group_var, size = 2, interactive = FALSE) + 
   scale_colour_brewer(palette = "Dark2")
 
 
}


#use rarefied if using bray, non-rarefied if Aitch
vOTU_perm  <- function(ps, distance, group_var) {

#can directly calculate bray distance from here since we have rarefied 
ps.fixed <- ps %>%
 tax_fix(unknowns = "NA")
  

dist.ps.fixed <- ps.fixed  %>% 
  dist_calc(distance)
    
  perm <- dist.ps.fixed %>%
  dist_permanova(
    seed = 1234, # for set.seed to ensure reproducibility of random process
    n_processes = 1, n_perms = 999, # you should use at least 999!
    variables = group_var
  )
 
 
   perm_get(perm) %>% as.data.frame()

 
  
}


PBF_perm  <- function(ps, distance, group_var) {

#can directly calculate bray distance from here since we have rarefied 


    
ps1 <- tax_glom(ps, taxrank="Family", NArm = TRUE) 

dist.ps.fixed <- ps1 %>%
 tax_fix(unknowns = "NA") %>%
  dist_calc(distance)
  
    
  perm <- dist.ps.fixed %>%
  dist_permanova(
    seed = 1234, # for set.seed to ensure reproducibility of random process
    n_processes = 1, n_perms = 999, # you should use at least 999!
    variables = group_var
  )
 
 
   perm_get(perm) %>% as.data.frame()

 
  
}




tax_glom(rarefied.reads.1500,taxrank="Family", NArm = TRUE )
tax_glom(subset_1500,taxrank="Family", NArm = TRUE )






#vOTU - Bray - Using rarefied DF 
PCoA_vOTU.Bray.Diagnosis <-   PCoA_vOTU(rarefied.reads.1500, "bray", "diagnosis.x")
PCoA_vOTU.Bray.Dysbiosis <-   PCoA_vOTU(rarefied.reads.1500, "bray", "dysbiosis_binary")



#vOTU - Aitchison's - Using non-rarefied DF 


PCoA_vOTU.Aitch.Diagnosis <-   PCoA_vOTU(subset_1500, "aitchison", "diagnosis.x")
PCoA_vOTU.Aitch.Dysbiosis <-   PCoA_vOTU(subset_1500, "aitchison", "dysbiosis_binary")





#PBF - Bray - Using rarefied DF 
PCoA_PBF.Bray.Diagnosis <-   PCoA_PBF(rarefied.reads.1500, "bray", "diagnosis.x")
PCoA_PBF.Bray.Dysbiosis <-   PCoA_PBF(rarefied.reads.1500, "bray", "dysbiosis_binary")







#PBF -  - Using rarefied DF 
PCoA_PBF.Aitchison.Diagnosis <-   PCoA_PBF(subset_1500, "aitchison", "diagnosis.x")
PCoA_PBF.Aitchison.Dysbiosis <-   PCoA_PBF(subset_1500, "aitchison", "dysbiosis_binary")





###Bray_Dysbiosis 
PCoA_vOTU.Bray.Dysbiosis
PCoA_PBF.Bray.Dysbiosis
vOTU_perm(rarefied.reads.1500, "bray", "dysbiosis_binary")
PBF_perm(rarefied.reads.1500, "bray", "dysbiosis_binary")

#Bray_Diagnosis
PCoA_vOTU.Bray.Diagnosis
PCoA_PBF.Bray.Diagnosis
vOTU_perm(rarefied.reads.1500, "bray", "diagnosis.x") 
PBF_perm(rarefied.reads.1500, "bray", "diagnosis.x")

#Aitch Dysbiosis 
PCoA_vOTU.Aitch.Dysbiosis
PCoA_PBF.Aitchison.Dysbiosis
vOTU_perm(subset_1500, "aitchison", "dysbiosis_binary")
PBF_perm(subset_1500, "aitchison", "dysbiosis_binary")


#Aitch Diagnosis 
PCoA_vOTU.Aitch.Diagnosis
PCoA_PBF.Aitchison.Diagnosis
vOTU_perm(subset_1500, "aitchison", "diagnosis.x")
PBF_perm(subset_1500, "aitchison", "diagnosis.x")


###PBF 

PBF_perm(rarefied.reads.1500, "bray", "diagnosis.x")
PBF_perm(rarefied.reads.1500, "bray", "dysbiosis_binary")




 
 
 
```
```{r}
#do similar but for temp and virulent viromes 
physeqhmp2vir
physeqhmp2tempvir

#subsetting for 1500 reads (total - not for just temperate virome - I may want to change this )
subset_1500.temp <-  subset_samples(physeqhmp2tempvir, length_normalized_read_count > 1500)
subset_1500.vir <-  subset_samples(physeqhmp2vir, length_normalized_read_count > 1500)


rarefied.reads.1500.temp <-  rarefy_even_depth(subset_1500.temp, sample.size = min(sample_sums(subset_1500.temp)),
  rngseed = 1, replace = TRUE, trimOTUs = TRUE, verbose = TRUE)


rarefied.reads.1500.vir <-  rarefy_even_depth(subset_1500.vir, sample.size = min(sample_sums(subset_1500.vir)),
  rngseed = 1, replace = TRUE, trimOTUs = TRUE, verbose = TRUE)



vOTU_perm(rarefied.reads.1500.temp, "bray", "dysbiosis_binary")
PBF_perm(rarefied.reads.1500.temp, "bray", "dysbiosis_binary")



PCoA_vOTU.Bray.Diagnosis.temp <-   PCoA_vOTU(rarefied.reads.1500.temp, "bray", "diagnosis.x")
PCoA_vOTU.Bray.Dysbiosis.temp <-   PCoA_vOTU(rarefied.reads.1500.temp, "bray", "dysbiosis_binary")


#PBF - Bray - Using rarefied DF 
PCoA_PBF.Bray.Diagnosis.temp <-   PCoA_PBF(rarefied.reads.1500.temp, "bray", "diagnosis.x")
PCoA_PBF.Bray.Dysbiosis.temp <-   PCoA_PBF(rarefied.reads.1500.temp, "bray", "dysbiosis_binary")




vOTU_perm(rarefied.reads.1500.vir, "bray", "dysbiosis_binary")
PBF_perm(rarefied.reads.1500.vir, "bray", "dysbiosis_binary")



PCoA_vOTU.Bray.Diagnosis.vir <-   PCoA_vOTU(rarefied.reads.1500.vir, "bray", "diagnosis.x")
PCoA_vOTU.Bray.Dysbiosis.vir <-   PCoA_vOTU(rarefied.reads.1500.vir, "bray", "dysbiosis_binary")


#PBF - Bray - Using rarefied DF 
PCoA_PBF.Bray.Diagnosis.vir <-   PCoA_PBF(rarefied.reads.1500.vir, "bray", "diagnosis.x")
PCoA_PBF.Bray.Dysbiosis.vir <-   PCoA_PBF(rarefied.reads.1500.vir, "bray", "dysbiosis_binary")

```




```{r}

library(vegan)
library(multivariance)
library(viridis)


#metadata
metadata_df <- read.csv("/Users/anshulsinha/Desktop/IBD_prophages_aim/bioinformatics_aim/bioinformatics_HMP_2/prop_stats_outputs/combined_metadata.csv", header = TRUE)
metadata_df
names(metadata_df)[names(metadata_df) == 'Sample_name'] <- 'filename'


#remove samples that have no dysbiosis scores- this brings us to 1595 samples 
metadata_df <- metadata_df[complete.cases(metadata_df$dysbiosis_binary), ]



#create a function that generates distance between samples 

dist_calculator <- function(ps, dist, metadata) {
  
  
  
fixed_taxa <- ps %>%
 tax_fix(unknowns = "NA")

  
 dists <- fixed_taxa %>%
  dist_calc(dist) %>%
   dist_get() 
   
     
dists <- as.matrix(dists)
 
 melted_vOTU <- dists  %>%
   melt()
 
 melted_vOTU
  
 

 colnames(melted_vOTU) <- c("sample1", "sample2", "dist.vOTU")

 
  
 fam <- tax_glom(ps, taxrank="Family", NArm = TRUE) 
fixed_taxa_fam <- fam %>%
 tax_fix(unknowns = "NA")
 fam
 
 
 
 dist_fam <- fam %>%
  dist_calc(dist) %>%
   dist_get() 
 
 
  dist_fam <- as.matrix(dist_fam)

  melted_PBF <- dist_fam  %>%
   melt()
  
  
  
   colnames(melted_PBF) <- c("sample1", "sample2", "dist.pbf")

   
   
   dist.merged.all <- left_join(melted_vOTU %>% select(sample1, sample2, dist.vOTU), 
                         melted_PBF %>% select(sample1, sample2, dist.pbf), 
                         by = c("sample1" = "sample1", "sample2" = "sample2")) %>% 
                       left_join(metadata %>% select(Participant.ID, filename), by = c("sample1" = "filename")) %>% 
                       left_join(metadata %>% select(Participant.ID, filename), by = c("sample2" = "filename")) %>% 
                        melt()


colnames(dist.merged.all) <- c("sample1", "sample2", "subject1", "subject2", "metric", "value")
dist.merged.all

dist.merged.all$metric <- factor(dist.merged.all$metric, levels = c("dist.vOTU", "dist.pbf"))

#Same subject column to allow to dinstinguish between same v same vs. same vs different comparisons. 

dist.merged.all <- dist.merged.all %>% mutate(same.subject = subject1 == subject2)


dist.merged.all
# Remove rows where 'Value' is equal to 0 because this is same v same comparison  
dist.merged.all <- dist.merged.all[dist.merged.all$value != 0, ]
dist.merged.all



#change names 


dist.merged.all$same.subject = as.character(dist.merged.all$same.subject)
dist.merged.all$metric = as.character(dist.merged.all$metric)




dist.merged.all$same.subject[dist.merged.all$same.subject == "TRUE"] = "Intra-Individual"
dist.merged.all$same.subject[dist.merged.all$same.subject == "FALSE"] = "Inter-Individual"


dist.merged.all$metric[dist.merged.all$metric == "dist.vOTU"] = "vOTU"
dist.merged.all$metric[dist.merged.all$metric == "dist.pbf"] = "PBF"

colors <- c("#C3B1E1", "#a0d6b4")



dist.merged.all$metric <- factor(dist.merged.all$metric, levels = c("vOTU", "PBF"))



dist.merged.all
#confirm that we have duplicate differences 

dist.merged.all.delete <- dist.merged.all
#creates a column that merges the sample 1 and 2 cols in alph order, collapses the. sample1vs2 and sample2vs1 should have the same thing 
dist.merged.all.delete$sorted_pair <- apply(dist.merged.all.delete[, c("sample1", "sample2")], 1, function(x) paste(sort(x), collapse = "_"))
#test shows that for this pair there are two vOTU and two PBF rows with identical values 
dist.merged.all.delete.test <- dist.merged.all.delete[dist.merged.all.delete$sorted_pair == "C3001_0_CD_P_C3001_12_CD_P",]


# Group by 'sorted_pair' and 'metric' to keep one row for each combination




dist.merged.all.delete <- dist.merged.all.delete %>%
  group_by(sorted_pair, metric) %>%
  dplyr::slice(1) %>%  # Keeps the first row for each group
  ungroup()
   
 
dist.merged.all.delete
}



#create the distance dataframes for aitchison and bray distance 

aitchison_distance_df <- dist_calculator(subset_1500, "aitchison" ,metadata_df)
bray_distance_df <-  dist_calculator(rarefied.reads.1500, "bray" ,metadata_df)

bray_distance_df
   

```
```{r}

#same as above but NOT removing duplicates - will be important for stability analyses below 
dist_calculator.all <- function(ps, dist, metadata) {
  
  
  
fixed_taxa <- ps %>%
 tax_fix(unknowns = "NA")

  
 dists <- fixed_taxa %>%
  dist_calc(dist) %>%
   dist_get() 
   
     
dists <- as.matrix(dists)
 
 melted_vOTU <- dists  %>%
   melt()
 
 melted_vOTU
  
 

 colnames(melted_vOTU) <- c("sample1", "sample2", "dist.vOTU")

 
  
 fam <- tax_glom(ps, taxrank="Family", NArm = TRUE) 
fixed_taxa_fam <- fam %>%
 tax_fix(unknowns = "NA")
 fam
 
 
 
 dist_fam <- fam %>%
  dist_calc(dist) %>%
   dist_get() 
 
 
  dist_fam <- as.matrix(dist_fam)

  melted_PBF <- dist_fam  %>%
   melt()
  
  
  
   colnames(melted_PBF) <- c("sample1", "sample2", "dist.pbf")

   
   
   dist.merged.all <- left_join(melted_vOTU %>% select(sample1, sample2, dist.vOTU), 
                         melted_PBF %>% select(sample1, sample2, dist.pbf), 
                         by = c("sample1" = "sample1", "sample2" = "sample2")) %>% 
                       left_join(metadata %>% select(Participant.ID, filename), by = c("sample1" = "filename")) %>% 
                       left_join(metadata %>% select(Participant.ID, filename), by = c("sample2" = "filename")) %>% 
                        melt()


colnames(dist.merged.all) <- c("sample1", "sample2", "subject1", "subject2", "metric", "value")
dist.merged.all

dist.merged.all$metric <- factor(dist.merged.all$metric, levels = c("dist.vOTU", "dist.pbf"))

#Same subject column to allow to dinstinguish between same v same vs. same vs different comparisons. 

dist.merged.all <- dist.merged.all %>% mutate(same.subject = subject1 == subject2)


dist.merged.all
# Remove rows where 'Value' is equal to 0 because this is same v same comparison  
dist.merged.all <- dist.merged.all[dist.merged.all$value != 0, ]
dist.merged.all



#change names 


dist.merged.all$same.subject = as.character(dist.merged.all$same.subject)
dist.merged.all$metric = as.character(dist.merged.all$metric)




dist.merged.all$same.subject[dist.merged.all$same.subject == "TRUE"] = "Intra-Individual"
dist.merged.all$same.subject[dist.merged.all$same.subject == "FALSE"] = "Inter-Individual"


dist.merged.all$metric[dist.merged.all$metric == "dist.vOTU"] = "vOTU"
dist.merged.all$metric[dist.merged.all$metric == "dist.pbf"] = "PBF"

colors <- c("#C3B1E1", "#a0d6b4")



dist.merged.all$metric <- factor(dist.merged.all$metric, levels = c("vOTU", "PBF"))



dist.merged.all

}



```

```{r}
#BRAY 

##FOR the wilcoxon, I'll need to first reshape the data 

bray_distance_df.wider <- bray_distance_df %>%
  pivot_wider(names_from = metric, values_from = value)




# Now on just intra -comparisons 
dist.merged.all_intra.bray <- bray_distance_df.wider[bray_distance_df.wider$same.subject == "Intra-Individual",]

#intra wilcox test
wilcox.test(Pair(vOTU, PBF) ~ 1, data = dist.merged.all_intra.bray)


dist.merged.all_inter.bray <- bray_distance_df.wider[bray_distance_df.wider$same.subject == "Inter-Individual",]

#inter wilox test 
wilcox.test(Pair(vOTU, PBF) ~ 1, data = dist.merged.all_inter.bray)


#now plot with significance stars 


#removing the test variable x
rm(x)
colors <- c("#C3B1E1", "#a0d6b4")


#now plot 
 bray_distance_df  %>% 
  ggplot(aes(x = same.subject, y = value, fill = metric)) +
 geom_violin(scale = "width", aes(fill=metric), alpha = 0.3, position = position_dodge(width = 0.9)) +
  geom_boxplot(outlier.shape = NA, width = 0.3, aes(fill=metric), color="black", position = position_dodge(width = 0.9)) +
    annotate("segment", x = 0.75, xend = 1.25, y = 1.09, yend = 1.09, 
           linetype = "solid", color = "black", size = 1) +
     annotate("text", x = 1, y = 1.11, label = "****", size = 6, color = "black") +  

       annotate("segment", x = 1.75, xend = 2.25, y = 1.03, yend = 1.03, 
           linetype = "solid", color = "black", size = 1) +
     annotate("text", x = 2, y = 1.05, label = "****", size = 6, color = "black") +  

  scale_fill_viridis(discrete = T, begin = 0.1, end = 0.7, labels = labels) +
  scale_colour_viridis(discrete = T, begin = 0.1, end = 0.7, labels = labels) +
 # geom_jitter(alpha = 0.05) +
  #scale_fill_brewer(palette = "Set1") + 
  #facet_wrap(. ~ same.subject, labeller = label_parsed) + 
   scale_fill_manual(values = colors) +  
  scale_color_manual(values = colors) +  
   labs(x = "Comparison", y = "Distance") +
   labs(fill = "Distance metric") + 
   scale_x_discrete(labels = c("Inter-individual (across)", "Intra-individual (within)")) +
  theme_bw() 

```
```{r}
#Aitchison's 

##FOR the wilcoxon, I'll need to first reshape the data 

aitchison_distance_df.wider <- aitchison_distance_df %>%
  pivot_wider(names_from = metric, values_from = value)




# Now on just intra -comparisons 
dist.merged.all_intra.aitch <- aitchison_distance_df.wider[aitchison_distance_df.wider$same.subject == "Intra-Individual",]

#intra wilcox test
wilcox.test(Pair(vOTU, PBF) ~ 1, data = dist.merged.all_intra.aitch)


dist.merged.all_inter.aitch <- aitchison_distance_df.wider[aitchison_distance_df.wider$same.subject == "Inter-Individual",]

#inter wilox test 
wilcox.test(Pair(vOTU, PBF) ~ 1, data = dist.merged.all_inter.aitch)


#now plot with significance stars 


#removing the test variable x
rm(x)

#now plot 
 aitchison_distance_df  %>% 
  ggplot(aes(x = same.subject, y = value, fill = metric)) +
 geom_violin(scale = "width", aes(fill=metric), alpha = 0.3, position = position_dodge(width = 0.9)) +
  geom_boxplot(outlier.shape = NA, width = 0.3, aes(fill=metric), color="black", position = position_dodge(width = 0.9)) +
    annotate("segment", x = 0.75, xend = 1.25, y = 105, yend = 105, 
           linetype = "solid", color = "black", size = 1) +
     annotate("text", x = 1, y = 108, label = "****", size = 6, color = "black") +  

       annotate("segment", x = 1.75, xend = 2.25, y = 93, yend = 93, 
           linetype = "solid", color = "black", size = 1) +
     annotate("text", x = 2, y = 96, label = "****", size = 6, color = "black") +  

  scale_fill_viridis(discrete = T, begin = 0.1, end = 0.7, labels = labels) +
  scale_colour_viridis(discrete = T, begin = 0.1, end = 0.7, labels = labels) +
 # geom_jitter(alpha = 0.05) +
  #scale_fill_brewer(palette = "Set1") + 
  #facet_wrap(. ~ same.subject, labeller = label_parsed) + 
   scale_fill_manual(values = colors) +  
  scale_color_manual(values = colors) +  
   labs(x = "Comparison", y = "Distance") +
   labs(fill = "Distance metric") + 
   scale_x_discrete(labels = c("Inter-individual (across)", "Intra-individual (within)")) +
  theme_bw() 

```
```{r}
#plotting prevalence 


melted_1500 <- ps_melt(subset_1500)



prevalence(melted_1500, detection = 0)
```


```{r}
###CALCULATE STABILITY ####

#need the distance df (without duplicates removed - this will happen as I set sample2>sample1 )


bray_distance_df.all <-  dist_calculator.all(rarefied.reads.1500, "bray" ,metadata_df)


#add a metadata column for "time point " - converting week number to time point (ie- week 0,2,9 = 1,2,3)

test_metadata <- hmp2_metadata_phylo
test_metadata <- test_metadata[order(test_metadata$Participant.ID, test_metadata$week_num), ]
#ordering by week number for each individual 
#then creating a sequence for the number of time points per individual 
test_metadata$time_point <- sequence(rle(test_metadata$Participant.ID)$lengths)
write.csv(test_metadata, "/Users/anshulsinha/Desktop/test/test_meta.csv")



#Filter for just intra comparisons

dist.merged.all.filt.timepoints <- bray_distance_df.all %>%
  #Filter for just intra comparisons
  filter(same.subject == "Intra-Individual") %>%
  #unclear what this line is doing- ask Michael
 # filter(!metric %in% c("dist.aitch.filt", "dist.aitch.filt.pbf")) %>%
  select(sample1, sample2, metric, value) %>%
  left_join(test_metadata %>% select(time_point, filename, Participant.ID), by = c("sample1" = "filename")) %>%
  left_join(test_metadata %>% select(time_point, filename, Participant.ID), by = c("sample2" = "filename"), suffix = c(".sample1", ".sample2")) %>%
  mutate()

length(unique(bray_distance_df$sample1))

length(unique(dist.merged.all.filt.timepoints$sample2))




library(dplyr)

dist.merged.all.filt.timepoints.2 <- dist.merged.all.filt.timepoints %>%
  mutate(timepoint_after = time_point.sample2 > time_point.sample1) %>%
  filter(timepoint_after) %>%
  mutate(timepoint_diff = time_point.sample2 - time_point.sample1) %>%
  group_by(Participant.ID.sample1, metric, time_point.sample1) %>%
  arrange(timepoint_diff) %>%
 filter(timepoint_diff == min(timepoint_diff))   # Keep only the row with the minimum timepoint_diff per group

dist.merged.all.filt.timepoints.2

#Within each time_point.sample1 (group by patient and metric - this will take only the min timepoint_diff per group - allows us to sample "consecutive"time points )

#note that there are several cases where the min_timepoint_diff is > 1 
#some reasons? 
  #we filtered out some samples from 






test_metadata <- hmp2_metadata_phylo
test_metadata <- test_metadata %>%
  select(Participant.ID, diagnosis.x)


colnames(test_metadata) <- c("Participant.ID.sample1", "Diagnosis")


dist.merged.all.filt.timepoints.final_meta <- left_join(dist.merged.all.filt.timepoints.2, test_metadata, by= "Participant.ID.sample1")

dist.merged.all.filt.timepoints.final_meta <- unique(dist.merged.all.filt.timepoints.final_meta)


dist.merged.all.filt.timepoints.final_meta %>%
  filter(!metric %in% c("vOTU")) %>%
  ggplot(aes(x = Participant.ID.sample1, y = value, group = interaction(Participant.ID.sample1, metric), color = metric)) +
    geom_violin(scale = "width", aes(fill=metric), alpha = 0.3, position = position_dodge(width = 0.9)) +
    geom_boxplot(outlier.shape = NA, width = 0.3, aes(fill = metric), color = "black", position = position_dodge(width = 0.9)) +
    scale_fill_viridis(discrete = T, begin = 0.1, end = 0.3, labels = labels) +
    scale_colour_viridis(discrete = T, begin = 0.1, end = 0.3, labels = labels) +
    theme_bw() +
    labs(x = "Individual", y = "Stability\n(1 - distance)", color = "Distance metric", fill = "Distance metric") +
    facet_wrap(. ~ Diagnosis)







dist.merged.all.filt.timepoints.final_meta %>%
  filter(!metric %in% c("PBF")) %>%
  ggplot(aes(x = Participant.ID.sample1, y = value, group = interaction(Participant.ID.sample1, metric), color = metric)) +
  geom_violin(scale = "width", aes(fill=metric), alpha = 0.3, position = position_dodge(width = 0.9)) +
    geom_boxplot(outlier.shape = NA, width = 0.3, aes(fill = metric), color = "black", position = position_dodge(width = 0.9)) +
    scale_fill_viridis(discrete = T, begin = 0.1, end = 0.3, labels = labels) +
    scale_colour_viridis(discrete = T, begin = 0.1, end = 0.3, labels = labels) +
    theme_bw() +
    labs(x = "Individual", y = "Stability\n(1 - distance)", color = "Distance metric", fill = "Distance metric") +
     facet_wrap(. ~ Diagnosis)




#Filter for just PBF

dist.merged.all.filt.timepoints.final_meta_PBF <- dist.merged.all.filt.timepoints.final_meta %>%
  filter(!metric %in% c("vOTU"))


#Filter for just vOTU


dist.merged.all.filt.timepoints.final_meta_votu <- dist.merged.all.filt.timepoints.final_meta %>%
  filter(!metric %in% c("PBF"))


dist.merged.all.filt.timepoints.final_meta_agg_vOTU <-  aggregate(value ~ Diagnosis, data = dist.merged.all.filt.timepoints.final_meta_votu, FUN = mean)
dist.merged.all.filt.timepoints.final_meta_agg_PBF <-  aggregate(value ~ Diagnosis, data = dist.merged.all.filt.timepoints.final_meta_PBF, FUN = mean)



#Filter for just vOTU
#calculate the Mean value for each individual at the PBF level


PBF_grouped <- dist.merged.all.filt.timepoints.final_meta_PBF %>%
group_by(Participant.ID.sample1) %>%
    # Calculate the mean of the "Frequency" column for each group
    summarise_at(vars(value),
                 list(mean_values = mean))


unique_metadata <- unique(test_metadata)
unique_metadata <- unique_metadata %>%
  select(Participant.ID.sample1
, Diagnosis)


PBF_grouped <- left_join(PBF_grouped, unique_metadata, by= "Participant.ID.sample1")



votu_grouped <- dist.merged.all.filt.timepoints.final_meta_votu %>%
group_by(Participant.ID.sample1) %>%
    # Calculate the mean of the "Frequency" column for each group
    summarise_at(vars(value),
                 list(mean_values = mean))


votu_grouped <- left_join(votu_grouped, unique_metadata, by= "Participant.ID.sample1")

#write.csv(PBF_grouped, "/Users/anshulsinha/Desktop/IBD_prophages_aim/bioinformatics_aim/bioinformatics_HMP_2/free_virome/free_virome_09_23/diversity_analyses/whole_virome_PBF_instability.csv")
mean_vals <-  aggregate(mean_values ~ Diagnosis, data = PBF_grouped, FUN = mean)


#PLOT




votu_grouped %>%
  ggplot(aes(x = Diagnosis, y = mean_values, color = Diagnosis)) +
      geom_boxplot(width = 0.5, colour = "grey35", outlier.shape = NA) +
      geom_jitter(width = 0.2, alpha = 0.5, aes(color = Diagnosis)) +
    theme_bw() +
    labs(x = "Individual", y = "Bray Distance (From Previous Time Point)", color = "Diagnosis Status", fill = "Diagnosis Status") +
      scale_color_manual(values = diagnosis_cols)



PBF_grouped %>%
  ggplot(aes(x = Diagnosis, y = mean_values, color = Diagnosis)) +
      geom_boxplot(width = 0.5, colour = "grey35", outlier.shape = NA) +
      geom_jitter(width = 0.2, alpha = 0.5, aes(color = Diagnosis)) +
    theme_bw() +
    labs(x = "Individual", y = "Bray Distance (From Previous Time Point)", color = "Diagnosis Status", fill = "Diagnosis Status") +
      scale_color_manual(values = diagnosis_cols)


kruskal.test(mean_values ~ Diagnosis, data = votu_grouped)
kruskal.test(mean_values ~ Diagnosis, data = PBF_grouped)

pairwise.wilcox.test(votu_grouped$mean_values, votu_grouped$Diagnosis,
                 p.adjust.method = "BH")

pairwise.wilcox.test(PBF_grouped$mean_values, PBF_grouped$Diagnosis,
                 p.adjust.method = "BH")

```




```{r}
#calculate vOTU and PBF prevalence 
#NOT USING PHYLOSEQ OBJECT - TAKING ADVANTAGE OF STOCKDALE CUTOFFS FROM OTU_TABLE - PS introduces zeroes 

#Unlike other sections, I've used a mean depth cutoff > 1 here

#filter for the samples with more than 1500 counts 

#get names of those samples 

filtered.1500.sampledata <-  data.frame(sample_data(subset_1500))

sample.names.1500 <- filtered.1500.sampledata$filename

#filter df_hmp_virome for those counts 
filtered.1500.df_hmp_virome <- df_hmp_virome %>%
  filter(filename %in% sample.names.1500)

length(unique(filtered.1500.df_hmp_virome$filename)) #sanity check -1093 filenames 



length(unique(filtered.1500.df_hmp_virome$contigname)) #3,870 contigs total in filtered 1500




#merged with iphop
df_hmp_virome_merged <- left_join(filtered.1500.df_hmp_virome, hmp2_vir_iphop, by="contigname")







#using the cutoff of >1 mean depth in addition to only keeping samples > 1500 reads, we lose a few contigs  
#3886 vs. 3862
df_hmp_virome_merged <- df_hmp_virome_merged[df_hmp_virome_merged$meandepth >1,]


 length(unique(df_hmp_virome$contigname)) - length(unique(df_hmp_virome_merged$contigname)) 

 #we only lose 24 - would've expected a bit more 
 
 
 #quick check how many of these are NAs
 df_hmp_virome_merged.dup <- df_hmp_virome_merged[!duplicated(df_hmp_virome_merged$contigname),]
 
 table(df_hmp_virome_merged.dup$Family, useNA = "always")
 
 
 1 - (497/3862)
 3862-497

 length(unique(df_hmp_virome_merged$Family, useNA = "never")) 
 
 
 

#prevalence at the vOTU level 
 #note here that Im calculating based on prevalence at the SAMPLE and the INDIVIDUAL level 
 
 
df_hmp_virome_votu_prevalence <- df_hmp_virome_merged %>%
  group_by(contigname) %>%
  summarize(sample_count = n_distinct(filename), prevalence = n_distinct(filename) / n_distinct(df_hmp_virome_merged$filename),
            participant_count = n_distinct(Participant.ID), prevalence_ind = n_distinct(Participant.ID)/ n_distinct(df_hmp_virome_merged$Participant.ID))



#add a rank column 
df_hmp_virome_votu_prevalence$rank_prev <- rank(-df_hmp_virome_votu_prevalence$prevalence)
df_hmp_virome_votu_prevalence$rank_prev_ind <- rank(-df_hmp_virome_votu_prevalence$prevalence_ind)

#prevalence at the PBF level 
df_hmp_virome_pbf_prevalence <- df_hmp_virome_merged %>%
  group_by(Family) %>%
  summarize(sample_count = n_distinct(filename), prevalence = n_distinct(filename) / n_distinct(df_hmp_virome_merged$filename),
            participant_count = n_distinct(Participant.ID), prevalence_ind = n_distinct(Participant.ID)/ n_distinct(df_hmp_virome_merged$Participant.ID))




#collapse Family NAs as unidentified and then remove 
df_hmp_virome_pbf_prevalence <- df_hmp_virome_pbf_prevalence %>%
  mutate(Family = ifelse(is.na(Family), "unidentified", Family)) %>% 
  filter(Family != "unidentified")

df_hmp_virome_pbf_prevalence



#add a rank column in descending order 
df_hmp_virome_pbf_prevalence$rank_prev <- rank(-df_hmp_virome_pbf_prevalence$prevalence)
df_hmp_virome_pbf_prevalence$rank_prev_ind <- rank(-df_hmp_virome_pbf_prevalence$prevalence_ind)




### PREVALENCE BY INDIVIDUAL 



 # Find the rows where prevalence_ind is close to 0.5
#at rank_prev, that delineates above and below 0.5 prevalence 


threshold <- 0.5
tolerance <- 0.005

filtered_df.votu <- df_hmp_virome_votu_prevalence %>%
  filter(prevalence_ind >= (threshold - tolerance) & prevalence_ind <= (threshold + tolerance))
filtered_df.votu$rank_prev_ind

#at 232 - several contigs have about a  0.5 prevalence 



threshold <- 0.5
tolerance <- 0.1



 

filtered_df.pbf <- df_hmp_virome_pbf_prevalence %>%
  filter(prevalence_ind >= (threshold - tolerance) & prevalence_ind <= (threshold + tolerance))
filtered_df.pbf



#18 is the delimiter for PBFs 



#filter a list of those contigs with more than 50% prevalence in the contigs list 

vOTU_list_50_prev <- df_hmp_virome_votu_prevalence[df_hmp_virome_votu_prevalence$rank_prev_ind <= 232,]

236/3862*100

236/3870*100 


PBF_list_50_prev <- df_hmp_virome_pbf_prevalence[df_hmp_virome_pbf_prevalence$rank_prev_ind <=18,]
18/75
#plot prevalence per individual  

ggplot(df_hmp_virome_votu_prevalence, aes(x = rank_prev_ind, y = prevalence_ind)) +
    geom_point(size = 0.1) +  
    geom_jitter() + 
    labs(x = "Rank", y = "vOTU Prevalence", 
         title = "vOTU Prevalence Across Individuals") +
    annotate("segment", x = 233, xend = 233, y = 0, yend = 1, 
           linetype = "dashed", color = "red", size = 1) +
    theme_minimal() +
    theme(axis.text.x = element_blank())  # Removes species labels





ggplot(df_hmp_virome_pbf_prevalence, aes(x = rank_prev_ind, y = prevalence_ind)) +
    geom_point(size = 0.1) + 
    geom_jitter() +
    labs(x = "Rank", y = "vOTU Prevalence", 
         title = "PBF Prevalence Across Individuals") +
    annotate("segment", x = 18.5, xend = 18.5, y = 0, yend = 1, 
           linetype = "dashed", color = "red", size = 1) +
    theme_minimal() +
    theme(axis.text.x = element_blank())  # Removes species labels


#calculate the mean relative abundance of these contigs that are 50% abundant 

df_hmp_virome_merged.votu <- df_hmp_virome_merged %>%
  group_by(filename) %>%
  summarize(sum_depth = sum(meandepth), contigname = contigname, meandepth=meandepth)

df_hmp_virome_merged.votu$relative_abundance <- df_hmp_virome_merged.votu$meandepth/df_hmp_virome_merged.votu$sum_depth



#Now do the same with PBF 
#Here first make any column that is NA is now changed to unidentified and sum depth 
#I can play around with how I should/how I should want to 
df_hmp_virome_merged.pbf.2 <- df_hmp_virome_merged %>%
  mutate(Family = ifelse(is.na(Family), "unidentified", Family))  %>%
  group_by(filename) %>%
    summarize(sum_depth = sum(meandepth), Family = Family, meandepth=meandepth, contigname=contigname)


#now group by filename and family so that meandepth per Family is calculated 
  df_hmp_virome_merged.pbf.1 <- df_hmp_virome_merged.pbf.2 %>% 
    group_by(filename, Family) %>% 
    summarize(sum_depth=sum_depth,Family=Family, fam_depth=sum(meandepth))

  
#It will display this for each contig with a family value - so remove duplicate rows 
  df_hmp_virome_merged.pbf <- df_hmp_virome_merged.pbf.1[!duplicated(df_hmp_virome_merged.pbf.1),]
  df_hmp_virome_merged.pbf$relabundance <- df_hmp_virome_merged.pbf$fam_depth/df_hmp_virome_merged.pbf$sum_depth
  
  
  
  ###now filter for those contigs above a given rank####
  df_hmp_virome_merged.votu.filtered.prevalence.1 <- df_hmp_virome_merged.votu %>% 
    filter(contigname %in% vOTU_list_50_prev$contigname)
  
  
  df_hmp_virome_merged.votu.filtered.prevalence <- df_hmp_virome_merged.votu.filtered.prevalence.1 %>%
    group_by(filename) %>%
    summarise(sample_abundance = sum(relative_abundance))
  
  
  checkV_virome
  
  
  
  PBF_list_50_prev <- PBF_list_50_prev %>%
  mutate(Family = ifelse(is.na(Family), "unidentified", Family))
  
df_hmp_virome_merged.pbf.filtered.prevalence.1 <- df_hmp_virome_merged.pbf %>% 
    filter(Family %in% PBF_list_50_prev$Family)
  
df_hmp_virome_merged.pbf.filtered.prevalence.1 <- df_hmp_virome_merged.pbf.filtered.prevalence.1[df_hmp_virome_merged.pbf.filtered.prevalence.1$Family != "unidentified",]

  
df_hmp_virome_merged.pbf.filtered.prevalence <- df_hmp_virome_merged.pbf.filtered.prevalence.1 %>%
group_by(filename) %>%
summarise(sample_abundance = sum(relabundance))
    

#adding rows with 0% relative abundance that were filtered out 

#vOTUs

df_hmp_virome_merged.votu.filtered.prevalence #1,085 rows out of 1,093 samples 
1093-1085 # add 8 rows 
not.in.df_hmp_virome_merged.votu.filtered.prevalence.1 <- subset(df_hmp_virome_merged, !(filename %in%  df_hmp_virome_merged.votu.filtered.prevalence$filename))

not.in.df_hmp_virome_merged.votu.filtered.prevalence <- unique(not.in.df_hmp_virome_merged.votu.filtered.prevalence.1$filename)
df.not.in.df.votu <- data.frame(filename = not.in.df_hmp_virome_merged.votu.filtered.prevalence)
df.not.in.df.votu$sample_abundance <- 0

df_hmp_virome_merged.votu.filtered.prevalence <- rbind(df_hmp_virome_merged.votu.filtered.prevalence,df.not.in.df.votu )


#PBFs 

df_hmp_virome_merged.pbf.filtered.prevalence #1,092 rows out of 1,093 samples 
1093-1092 # add 1 rows 
not.in.df_hmp_virome_merged.pbf.filtered.prevalence.1 <- subset(df_hmp_virome_merged, !(filename %in%  df_hmp_virome_merged.pbf.filtered.prevalence$filename))

not.in.df_hmp_virome_merged.pbf.filtered.prevalence <- unique(not.in.df_hmp_virome_merged.pbf.filtered.prevalence.1$filename)
df.not.in.df.pbf <- data.frame(filename = not.in.df_hmp_virome_merged.pbf.filtered.prevalence)
df.not.in.df.pbf$sample_abundance <- 0

df_hmp_virome_merged.pbf.filtered.prevalence <- rbind(df_hmp_virome_merged.pbf.filtered.prevalence,df.not.in.df.pbf )





histogram(df_hmp_virome_merged.pbf.filtered.prevalence$sample_abundance, col="purple")
histogram(df_hmp_virome_merged.votu.filtered.prevalence$sample_abundance, col="darkgreen")
median(df_hmp_virome_merged.votu.filtered.prevalence$sample_abundance) #0.569
median(df_hmp_virome_merged.pbf.filtered.prevalence$sample_abundance) # 0.952
mean(df_hmp_virome_merged.votu.filtered.prevalence$sample_abundance) #0.540
mean(df_hmp_virome_merged.pbf.filtered.prevalence$sample_abundance) #0.910
    

length(PBF_list_50_prev$Family)/length(unique(df_hmp_virome_pbf_prevalence$Family))*100 # 24.32% of PBFs are 50% prevalent or above 


length(vOTU_list_50_prev$contigname)/length(unique(df_hmp_virome_votu_prevalence$contigname))*100 # 6.11% of contigs are 50% prevalent or above 



#Box plot and wilcoxon 

df_hmp_virome_merged.pbf.filtered.prevalence$metric <- "PBF"
df_hmp_virome_merged.votu.filtered.prevalence$metric <- "vOTU"

merged.prev.df <- rbind(df_hmp_virome_merged.pbf.filtered.prevalence, df_hmp_virome_merged.votu.filtered.prevalence)

merged.prev.df.wider <- merged.prev.df %>% 
  pivot_wider(names_from = metric, values_from = sample_abundance)

#inter wilox test 
wilcox.test(Pair(vOTU, PBF) ~ 1, data = merged.prev.df.wider) #p <2E-16






#plot rel ab 

 merged.prev.df  %>% 
  ggplot(aes(x = metric, y = sample_abundance, fill = metric)) +
geom_violin(scale = "width", aes(fill=metric), alpha = 0.3, position = position_dodge(width = 0.9)) +
  geom_boxplot(outlier.shape = NA, width = 0.3, aes(fill=metric), color="black", position = position_dodge(width = 0.9)) +
    annotate("segment", x = 1, xend = 2, y = 1.09, yend = 1.09, 
          linetype = "solid", color = "black", size = 1) +
     annotate("text", x = 1.5, y = 1.13, label = "****", size = 6, color = "black") +  

      # annotate("segment", x = 1.75, xend = 2.25, y = 93, yend = 93, 
       #    linetype = "solid", color = "black", size = 1) +
     #annotate("text", x = 2, y = 96, label = "****", size = 6, color = "black") +  

  scale_fill_viridis(discrete = T, begin = 0.1, end = 0.7, labels = labels) +
  scale_colour_viridis(discrete = T, begin = 0.1, end = 0.7, labels = labels) +
 # geom_jitter(alpha = 0.05) +
  #scale_fill_brewer(palette = "Set1") + 
  #facet_wrap(. ~ same.subject, labeller = label_parsed) + 
   scale_fill_manual(values = colors) +  
  scale_color_manual(values = colors) +  
   labs(x = "Comparison", y = "Relative Abundance") +
   labs(fill = "Distance metric") + 
   scale_x_discrete(labels = c("PBF", "vOTU")) +
  theme_bw() 


 
```




```{r}



# Rank prevalence plots base on per sample rather than individual




threshold <- 0.5
tolerance <- 0.001

filtered_df.votu.sample <- df_hmp_virome_votu_prevalence %>%
  filter(prevalence >= (threshold - tolerance) & prevalence <= (threshold + tolerance))
#anything less than 99 is > 50% prevalent 



threshold <- 0.5
tolerance <- 0.14


filtered_df.pbf.sample <- df_hmp_virome_pbf_prevalence %>%
  filter(prevalence >= (threshold - tolerance) & prevalence <= (threshold + tolerance))
filtered_df.pbf.sample #anything greater or less than 10 is > 50% prevalent 


#filter a list of those contigs with more than 50% prevalence in the contigs list 

vOTU_list_50_prev.sample <- df_hmp_virome_votu_prevalence[df_hmp_virome_votu_prevalence$rank_prev <= 99,]



PBF_list_50_prev.sample <- df_hmp_virome_pbf_prevalence[df_hmp_virome_pbf_prevalence$rank_prev <= 10,]



#plot prevalence per sample 
ggplot(df_hmp_virome_votu_prevalence, aes(x = rank_prev, y = prevalence)) +
    geom_point(size = 0.1) +  
    labs(x = "Rank", y = "vOTU Prevalence", 
         title = "vOTU Prevalence Across Samples") +
      annotate("segment", x = 100, xend = 100, y = 0, yend = 1, 
           linetype = "dashed", color = "red", size = 1) +
    theme_minimal() +
    theme(axis.text.x = element_blank())  # Removes species labels





ggplot(df_hmp_virome_pbf_prevalence, aes(x = rank_prev, y = prevalence)) +
    geom_point(size = 0.1) +  
    labs(x = "Rank", y = "vOTU Prevalence", 
         title = "PBF Prevalence Across Samples") +
    annotate("segment", x = 11, xend = 11, y = 0, yend = 1, 
           linetype = "dashed", color = "red", size = 1) +
    theme_minimal() +
    theme(axis.text.x = element_blank())  # Removes species labels




#calculate the mean relative abundance of these contigs that are 50% abundant 

  
###Only difference between this and the calculations per individual is the input list 




  df_hmp_virome_merged.votu.filtered.prevalence.1.sample <- df_hmp_virome_merged.votu %>% 
    filter(contigname %in% vOTU_list_50_prev.sample$contigname)
  
  
  df_hmp_virome_merged.votu.filtered.prevalence.sample <- df_hmp_virome_merged.votu.filtered.prevalence.1.sample %>%
    group_by(filename) %>%
    summarise(sample_abundance = sum(relative_abundance))
  
  
  
  
  
  
  PBF_list_50_prev.sample <- PBF_list_50_prev.sample %>%
  mutate(Family = ifelse(is.na(Family), "unidentified", Family))
  
df_hmp_virome_merged.pbf.filtered.prevalence.1.sample <- df_hmp_virome_merged.pbf %>% 
    filter(Family %in% PBF_list_50_prev.sample$Family)
  
df_hmp_virome_merged.pbf.filtered.prevalence.1.sample <- df_hmp_virome_merged.pbf.filtered.prevalence.1.sample[df_hmp_virome_merged.pbf.filtered.prevalence.1.sample$Family != "unidentified",]

  
df_hmp_virome_merged.pbf.filtered.prevalence.sample <- df_hmp_virome_merged.pbf.filtered.prevalence.1.sample %>%
group_by(filename) %>%
summarise(sample_abundance = sum(relabundance))



    
mean(df_hmp_virome_merged.votu.filtered.prevalence.sample$sample_abundance) #41.2%
mean(df_hmp_virome_merged.pbf.filtered.prevalence.sample$sample_abundance) #92.1%
median(df_hmp_virome_merged.votu.filtered.prevalence.sample$sample_abundance) #41.1%
median(df_hmp_virome_merged.pbf.filtered.prevalence.sample$sample_abundance) #92.09% 
histogram(df_hmp_virome_merged.pbf.filtered.prevalence.sample$sample_abundance, col="purple") #
histogram(df_hmp_virome_merged.votu.filtered.prevalence.sample$sample_abundance, col="darkgreen") #





length(PBF_list_50_prev.sample$Family)/length(unique(df_hmp_virome_pbf_prevalence$Family))*100 # 13.51% of PBFs are 50% prevalent or above 
length(vOTU_list_50_prev.sample$contigname)/length(unique(df_hmp_virome_votu_prevalence$contigname))*100 # 2.58% of contigs are 50% prevalent or above 



#Box plot and wilcoxon 

df_hmp_virome_merged.pbf.filtered.prevalence.sample$metric <- "PBF"
df_hmp_virome_merged.votu.filtered.prevalence.sample$metric <- "vOTU"

merged.prev.df.sample <- rbind(df_hmp_virome_merged.pbf.filtered.prevalence.sample, df_hmp_virome_merged.votu.filtered.prevalence.sample)

merged.prev.df.wider.sample <- merged.prev.df.sample %>% 
  pivot_wider(names_from = metric, values_from = sample_abundance)

#inter wilox test 
wilcox.test(Pair(vOTU, PBF) ~ 1, data = merged.prev.df.wider.sample) #p <2E-16


 merged.prev.df.sample  %>% 
  ggplot(aes(x = metric, y = sample_abundance, fill = metric)) +
geom_violin(scale = "width", aes(fill=metric), alpha = 0.3, position = position_dodge(width = 0.9)) +
  geom_boxplot(outlier.shape = NA, width = 0.3, aes(fill=metric), color="black", position = position_dodge(width = 0.9)) +
    annotate("segment", x = 1, xend = 2, y = 1.09, yend = 1.09, 
          linetype = "solid", color = "black", size = 1) +
     annotate("text", x = 1.5, y = 1.13, label = "****", size = 6, color = "black") +  

      # annotate("segment", x = 1.75, xend = 2.25, y = 93, yend = 93, 
       #    linetype = "solid", color = "black", size = 1) +
     #annotate("text", x = 2, y = 96, label = "****", size = 6, color = "black") +  

  scale_fill_viridis(discrete = T, begin = 0.1, end = 0.7, labels = labels) +
  scale_colour_viridis(discrete = T, begin = 0.1, end = 0.7, labels = labels) +
 # geom_jitter(alpha = 0.05) +
  #scale_fill_brewer(palette = "Set1") + 
  #facet_wrap(. ~ same.subject, labeller = label_parsed) + 
   scale_fill_manual(values = colors) +  
  scale_color_manual(values = colors) +  
   labs(x = "Comparison", y = "Relative Abundance") +
   labs(fill = "Distance metric") + 
   scale_x_discrete(labels = c("PBF", "vOTU")) +
  theme_bw() 


```



```{r}
### DESEQ2 #### FOR DYSBIOTIC SAMPLES 
#Whole virome here:

#dysbiotic vs. non-dysbiotic 


#get names of those samples with more than 1500 reads 

filtered.1500.sampledata <-  data.frame(sample_data(subset_1500))

sample.names.1500 <- filtered.1500.sampledata$filename

physeqhmp2whole_vir_i_reads #the ps object where the reads are not length normalized 
physeqhmp2whole_vir_i_reads #has 1,595 samples 


#filter for just the 1,093 above 1500 
physeqhmp2whole_vir_i_reads.1500 <- prune_samples(sample.names.1500,  physeqhmp2whole_vir_i_reads)
#sanity check 1,093 samples 


#now subset the phyloseq object so it only contains patient IDs that have both a dysbiotic and non-dysbiotic sample


#First, create a list of the samples that you want to remove

#metadata 
phyloseq_metadata <- hmp2_metadata_phylo 

#filter for samples that just have a "yes" valuue
yes_ids <- phyloseq_metadata %>% filter(dysbiosis_binary == "Yes") %>% distinct(Participant.ID)
no_ids <- phyloseq_metadata %>% filter(dysbiosis_binary == "No") %>% distinct(Participant.ID)



# Find the common Participant.IDs
common_ids <- intersect(yes_ids$Participant.ID, no_ids$Participant.ID)

length(common_ids)


# Filter the PS object so that we have  both dysbiotic and non indiviuals 
#Use the ps_object with reads (not length normalized reads)


filtered_ps <- subset_samples(physeqhmp2whole_vir_i_reads.1500 
, Participant.ID %in% common_ids)

#487 samples left 

filtered_ps


#test <- data.frame(sample_data(filtered_ps))



#1) tax glom- removing NAs - dont really want to include unknowns or single contigs here as they could influence DESEQ2 calc
#PS melt to generate counts table as df 



 tax_glom_fam_reads_deseq <- tax_glom(filtered_ps, taxrank="Family", NArm = TRUE) 
 


####IMPORTANT### Filter out low prevlance PBFs - If I dont do this, DESEQ2 will artifically think that some of the low abdundance taxa are DE 
##Choosing arbitrarily that it must be found in at least 50 % of individuals per above prevalence analyses  - 

 #first melt the PS to determine the OTUs that correspond to the PBFs
ps_melted_filtered <- ps_melt(tax_glom_fam_reads_deseq)
ps_melted_filtered2 <- ps_melt(filtered_ps)
ps_melted_filtered
ps_melted_filtered2
length(unique(ps_melted_filtered$Family)) #74 left 

 #confirm glom works 
table(unique(ps_melted_filtered$OTU))
table(unique(ps_melted_filtered$Family))


table(ps_melted_filtered$OTU)
table(ps_melted_filtered$Family)


length(unique(ps_melted_filtered$OTU))
length(unique(ps_melted_filtered$Family))

ntaxa(filtered_ps)
ntaxa(tax_glom_fam_reads_deseq)

#now take the contignames that are associated with the families that I want to keep 
ps_melted_filtered.prevalent.PBFs <- ps_melted_filtered %>% 
  filter(Family %in% PBF_list_50_prev$Family )

length(unique(ps_melted_filtered.prevalent.PBFs$Family)) #18 in here 

#now take the OTU names from this 
 keepTaxa = unique(ps_melted_filtered.prevalent.PBFs$OTU)



tax_glom_fam_reads_deseq.pruned <- prune_taxa(keepTaxa, tax_glom_fam_reads_deseq)
 
###Went from 74 to 18 taxa 


#now also remove samples that have zero counts 



phyloseq_richness_filter <- function(physeq, mintaxa = 10){
  sp <- estimate_richness(physeq, measures = "Observed")
  samples_to_keep <- rownames(sp)[ which(sp$Observed >= mintaxa) ]
  
  
  if(length(samples_to_keep) == 0){
    stop("All samples will be removed.\n")  
  }
  
  if(length(samples_to_keep) == nsamples(physeq)){
    cat("All samples will be preserved\n")
    res <- physeq
  }
  
  if(length(samples_to_keep) < nsamples(physeq)){
    res <- prune_samples(samples = samples_to_keep, x = physeq)
  }
 
  return(res)
}

tax_glom_fam_reads_deseq1 <- phyloseq_richness_filter(tax_glom_fam_reads_deseq.pruned, mintaxa = 1)

#now at 486 samples 





fam_reads_counts_deseq <- psmelt(otu_table(tax_glom_fam_reads_deseq1))


fam_reads_counts_deseq.meta <- data.frame(filename = unique(fam_reads_counts_deseq$Sample))
#sanity check - num individuals, diagnosis status, dysb vs. not 
fam_reads_counts_deseq.meta <- left_join(fam_reads_counts_deseq.meta, hmp2_metadata_phylo, by="filename")

length(unique(fam_reads_counts_deseq.meta$Participant.ID))
table(fam_reads_counts_deseq.meta$diagnosis.x)
table(fam_reads_counts_deseq.meta$dysbiosis_binary)

#49 individuals 
#140 non-IBD samples, 226 CD, 120 UC 
#371 Non, 115 dysbiotic samples 




#I believe that tax_glom agglomerates at a random OTU - so we'll just have to map the OTU name to its iPHOP designation later 


#use tiydrpivot wider to format into a useable matrix 

deseq_matrix_hmp <-  tidyr::pivot_wider(fam_reads_counts_deseq, names_from = OTU, values_from = Abundance)
deseq_matrix_hmp

#create variable sample_list (will need for later)
sample_list <- deseq_matrix_hmp$Sample
length(sample_list)

#switching the columns and rows so that each row is a different contig and each column is a different sample 
switch_matrix_deseq2_hmp <-  t(deseq_matrix_hmp)


#switch_matrix_deseq2_hmp <- as.data.frame(switch_matrix_deseq2_hmp)

# Assign the first row as column names
#colnames(switch_matrix_deseq2_hmp) <- switch_matrix_deseq2_hmp[1, ]

# Remove the first row
#switch_matrix_deseq2_hmp <- switch_matrix_deseq2_hmp[-1, ]

# If you need to convert 
#switch_matrix_deseq2_hmp <- as.matrix(switch_matrix_deseq2_hmp)

switch_matrix_deseq2_hmp.1 <- switch_matrix_deseq2_hmp
#export this 
write.csv(switch_matrix_deseq2_hmp.1, "/Users/anshulsinha/Desktop/IBD_prophages_aim/bioinformatics_aim/bioinformatics_HMP_2/virome_data_08_2024/deseq/matrix.csv") 


#dim(switch_matrix_deseq2_hmp)

```
```{r}
melt.test <- ps_melt(tax_glom_fam_reads_deseq)

melt.test2 <- ps_melt(tax_glom_fam_reads_deseq.pruned)



```





```{r}
#sanity check - when i open and save the matrixcopy.csv - the file size is about half - making sure im not losing data by counting chatacters 

test1 <- read.csv("/Users/anshulsinha/Desktop/IBD_prophages_aim/bioinformatics_aim/bioinformatics_HMP_2/virome_data_08_2024/deseq/matrix.csv")
test2 <- read.csv("/Users/anshulsinha/Desktop/IBD_prophages_aim/bioinformatics_aim/bioinformatics_HMP_2/virome_data_08_2024/deseq/matrixcopy.csv")

clean_and_combine <- function(df) {
  # Convert the dataframe to a CSV-formatted string
  csv_string <- capture.output(write.csv(df, row.names = FALSE))
  
  # Combine lines into a single string
  combined_string <- paste(csv_string, collapse = "")
  
  # Remove backslashes, quotes, commas, and extra spaces
  cleaned_string <- gsub("[\\\",]", "", combined_string)  # Remove backslashes, quotes, commas
  cleaned_string <- gsub("\\s+", "", cleaned_string)       # Remove all whitespace (including spaces, tabs, newlines)
  
  return(cleaned_string)
}

num_count_df1 <- clean_and_combine(test1)
num_count_df2 <- clean_and_combine(test2)


char_count_df1 <- nchar(num_count_df1, type = "chars")
char_count_df2 <- nchar(num_count_df2, type = "chars")
char_count_df1-char_count_df2

#difference in 1,837 characters - probably due to the "V1" etc 


  
```




```{r}
#reading in manually edited switched matrix

raw_counts2_deseq2_hmp <- read.csv("/Users/anshulsinha/Desktop/IBD_prophages_aim/bioinformatics_aim/bioinformatics_HMP_2/virome_data_08_2024/deseq/matrixcopy.csv", check.names = FALSE)


#Formatting the rawcount2_deseq2 transposed matrix 



colnames(raw_counts2_deseq2_hmp)[1] <- "contig_ID"

raw_counts2_deseq2_hmp


#replace NA values with 0
raw_counts2_deseq2_hmp[is.na(raw_counts2_deseq2_hmp)] = 0
raw_counts2_deseq2_hmp

#naming that column "contig_ID"

contig_ID_deseq2_hmp <-  raw_counts2_deseq2_hmp$contig_ID

#Now I am generating a "sample index" so I can exclude "contig_ID" from our matrix 

sampleindex_deseq2_hmp <- grepl("\\d", colnames(raw_counts2_deseq2_hmp))
##of the column names, anything that contains a numeric 


#converting to a matrix and only including the sample index columns 
raw_counts_matrix_deseq2_hmp <- as.matrix(raw_counts2_deseq2_hmp[,sampleindex_deseq2_hmp])
raw_counts_matrix_deseq2_hmp


rownames(raw_counts_matrix_deseq2_hmp) <- contig_ID_deseq2_hmp

head(raw_counts_matrix_deseq2_hmp)




raw_counts_matrix_deseq2_hmp


```


```{r}

#reading in sample mapping file (coldata)


#metadata



metadata_df <- read.csv("/Users/anshulsinha/Desktop/IBD_prophages_aim/bioinformatics_aim/bioinformatics_HMP_2/prop_stats_outputs/combined_metadata.csv", header = TRUE, row.names = 1)
metadata_df
names(metadata_df)[names(metadata_df) == 'Sample_name'] <- 'filename'

#remove samples that have no dysbiosis scores- this brings us to 1595 samples 
metadata_df <- metadata_df[complete.cases(metadata_df$dysbiosis_binary), ]


#Need to filter out samples that DONT have both a yes and no 

# Filter the PS object so that we have  both  #Use the ps_object with reads (not length normalized reads)




#changing all columns to factor 
sample_mapping_hmp2 <- mutate_if(metadata_df, is.character, as.factor)
sample_mapping_hmp2 <- mutate_if(metadata_df, is.integer, as.factor)
sample_mapping_hmp2 

# Filter again to filter out any samples that have 0 counts or are in the common_ids list created earlier that includes patients with dysb and non-dysb valuees 

sample_mapping_hmp2_filtered <- sample_mapping_hmp2 %>% filter(filename %in% sample_list)


sample_mapping_hmp2_filtered <-  sample_mapping_hmp2_filtered %>% 
    select(filename, diagnosis.x, dysbiosis_binary, Participant.ID) %>% 
     remove_rownames  %>%
    column_to_rownames(var = "filename")





```



```{r}



#Put the columns of the count data in the same order as rows names of the sample mapping, then make sure it worked (TRUE)

raw_counts_matrix_deseq2_hmp <- raw_counts_matrix_deseq2_hmp[, unique(rownames(sample_mapping_hmp2_filtered))]

head(raw_counts_matrix_deseq2_hmp)
all(colnames(raw_counts_matrix_deseq2_hmp) == rownames(sample_mapping_hmp2_filtered))



sample_mapping_hmp2_filtered

length(unique(sample_mapping_hmp2_filtered$Participant.ID)) #comparing the 49 individuals who have dysbiotic and non samples 


```



```{r}
library(DESeq2)
#Use a simple paired design 
#basically treating that each sample has a non_dysbiotic and dysbiotic sample 


deseq2Data_hmp2 <- DESeqDataSetFromMatrix(countData=raw_counts_matrix_deseq2_hmp, colData=sample_mapping_hmp2_filtered, design = ~ Participant.ID + dysbiosis_binary)


```

```{r}
#DE results - not using a nested design like with Duerkop data, so no need to rebuild the model matrix here 
#need to first estimate size factors to deal with zeroes 

dds_hmp2 <-estimateSizeFactors(deseq2Data_hmp2, type = "poscounts")
dds_hmp2 <- DESeq(dds_hmp2)
```

```{r}
rownames(dds_hmp2)
plotCounts(dds_hmp2, gene = "H4017_k119_66087_flag=1_multi=308.0000_len=167667", 
                        intgroup = "dysbiosis_binary")
plotCounts(dds_hmp2, gene = "H4004_k119_64860_flag=0_multi=26.1241_len=61807_fragment_2", 
                        intgroup = "dysbiosis_binary")

plotCounts(dds_hmp2, gene = "M2042_k119_8133_flag=1_multi=451.0000_len=70625", 
                        intgroup = "dysbiosis_binary")


plotCounts(dds_hmp2, gene = "C3023_k119_25579_flag=1_multi=275.9600_len=137507_fragment_1", 
                        intgroup = "dysbiosis_binary")


plotCounts(dds_hmp2, gene = "M2048_k119_181878_flag=0_multi=124.9799_len=80168_fragment_1", 
                        intgroup = "dysbiosis_binary")



```

```{r}

resultsNames(dds_hmp2)
deseq2_results_hmp_2 <-  results(dds_hmp2, contrast=list("dysbiosis_binary_Yes_vs_No"))



deseq2_results_hmp_2 <- as.data.frame(deseq2_results_hmp_2)

deseq2_results_hmp_2 <- deseq2_results_hmp_2 %>% 
rownames_to_column(var = "contigname")
deseq2_results_hmp_2


deseq2_results_hmp_2_comb <- left_join(deseq2_results_hmp_2, hmp2_vir_iphop, by= "contigname")


#significant values 

deseq2_results_hmp_2_sig <- subset(deseq2_results_hmp_2_comb, padj < 0.05 & (log2FoldChange > 1 | log2FoldChange < -1))


deseq2_results_hmp_2_sig <- as.data.frame(deseq2_results_hmp_2_sig)






 library(EnhancedVolcano)

#in order to plot the cutoff of padj and not p-value, we need to give the pvalue column in the df the values from the padj column 


hmp_2_combined_deseq1_res2_df_changed <- deseq2_results_hmp_2_comb
hmp_2_combined_deseq1_res2_df_changed$pvalue <- hmp_2_combined_deseq1_res2_df_changed$padj


keyvals_col_con_hmp2 <- ifelse(
    hmp_2_combined_deseq1_res2_df_changed$log2FoldChange < -1 & hmp_2_combined_deseq1_res2_df_changed$padj < 0.05, 'orange',
      ifelse(hmp_2_combined_deseq1_res2_df_changed$log2FoldChange > 1 & hmp_2_combined_deseq1_res2_df_changed$padj < 0.05, 'darkgreen',
        'light grey'))
  keyvals_col_con_hmp2[is.na(keyvals_col_con_hmp2)] <- 'light grey'
  names(keyvals_col_con_hmp2)[keyvals_col_con_hmp2 == 'darkgreen'] <- 'Enriched in Dysbiotic Samples'
  names(keyvals_col_con_hmp2)[keyvals_col_con_hmp2 == 'light grey'] <- 'Non-significant'
  names(keyvals_col_con_hmp2)[keyvals_col_con_hmp2 == 'orange'] <- 'Depleted in Dysbiotic Samples'

EV_col_con <- EnhancedVolcano(hmp_2_combined_deseq1_res2_df_changed, lab=NA , x = 'log2FoldChange',
    y = 'pvalue',  pCutoff = 0.05, cutoffLineWidth = 0.1, selectLab = rownames(hmp_2_combined_deseq1_res2_df_changed)[which(names(keyvals_col_con_hmp2) %in% c('Over-Abundant in Colitis', 'Over-Abundant in Control'))], pointSize = 2, gridlines.major = FALSE, gridlines.minor = FALSE, colCustom = keyvals_col_con_hmp2,  legendPosition = 'right', legendLabSize = 12,legendIconSize = 4.0, title = "", axisLabSize = 15,    subtitle = "", caption = "", xlab = expression(Log[2]~"Fold-Change")
)

EV_col_con


```
```{r}

edit_names_deseq <-  deseq2_results_hmp_2_comb[deseq2_results_hmp_2_comb$Family != "f__",]
edit_names_deseq$Family <- gsub("^.{0,3}", "", edit_names_deseq$Family)


   
# filter dataframe to get data to be highligheted
edit_names_deseq_highlight <- edit_names_deseq %>% 
             filter(padj<0.05)


 deseq.lfc.plot <-edit_names_deseq %>%
  ggplot(aes(x = log2FoldChange, reorder(Family, -log2FoldChange))) +
  geom_vline(xintercept = 0) +
  geom_point(aes(color = case_when(log2FoldChange > 1 & padj < 0.05 ~ "darkgreen", 
                                   log2FoldChange < -1 &  padj < 0.05 ~ "orange",
                                  TRUE ~ "grey" )), size = 5) +
  geom_point(data = . %>% filter(padj < 0.05 & log2FoldChange > 1 | padj < 0.05 & log2FoldChange < -1 ), size = 8, color = "darkred", shape = 1) +
  theme(
    axis.text.y = element_text(face = "italic", size = 10),
    axis.title.x = element_text(face = "italic")
  ) +
  scale_x_continuous(
    name = expression(Log[2] ~ " Fold Change")
  ) +
  scale_color_manual(
    values = c("darkgreen", "orange", "darkred"),
    breaks = c("darkgreen", "orange"),
    labels = c("Below 0", "Above 0")
  ) +
  guides(color = "none")  # Remove the legend


 
sig_names_families2 <- edit_names_deseq %>% 
             filter(padj<0.05 & (log2FoldChange >= 1 | log2FoldChange <= -1))

 
sig_names_families <- edit_names_deseq %>% 
             filter(padj<0.05 & (log2FoldChange >= 1 | log2FoldChange <= -1))

sig_names_families <- sig_names_families$Family

```

```{r}
#Step 1 - Generate count tables for each of the following 
# family level 
#family level with temp or vir designation 

#1) tax glom- removing NAs - dont really want to include unknowns or single contigs here as they could influence DESEQ2 calc

#use the subset_1500

physeqhmp2whole_vir_i_reads.1500 <- prune_samples(sample.names.1500,  physeqhmp2whole_vir_i_reads)


 tax_glom_fam_reads.limma <- tax_glom(physeqhmp2whole_vir_i_reads.1500, taxrank="Family", NArm = TRUE) 
 
 

#2 include the same taxa that meet the prevalence cutoff 


####IMPORTANT### Filter out low prevlance PBFs - If I dont do this, DESEQ2 will artifically think that some of the low abdundance taxa are DE 
##Choosing arbitrarily that it must be found in at least 50 % of individuals per above prevalence analyses  - 

 #first melt the PS to determine the OTUs that correspond to the PBFs
ps_melted_filtered.limma <- ps_melt(tax_glom_fam_reads.limma)

length(unique(ps_melted_filtered.limma$OTU)) #74 left 

#now take the contignames that are associated with the families that I want to keep 
ps_melted_filtered.limma.prevalent.PBFs <- ps_melted_filtered.limma %>% 
  filter(Family %in% PBF_list_50_prev$Family )

length(unique(ps_melted_filtered.limma.prevalent.PBFs$Family)) #18 in here 

#now take the OTU names from this 
 keepTaxa = unique(ps_melted_filtered.limma.prevalent.PBFs$OTU)



tax_glom_fam_reads_limma.pruned <- prune_taxa(keepTaxa, tax_glom_fam_reads.limma)
 
###Went from 74 to 18 taxa 


#now also remove samples that have zero counts 



phyloseq_richness_filter <- function(physeq, mintaxa = 10){
  sp <- estimate_richness(physeq, measures = "Observed")
  samples_to_keep <- rownames(sp)[ which(sp$Observed >= mintaxa) ]
  
  
  if(length(samples_to_keep) == 0){
    stop("All samples will be removed.\n")  
  }
  
  if(length(samples_to_keep) == nsamples(physeq)){
    cat("All samples will be preserved\n")
    res <- physeq
  }
  
  if(length(samples_to_keep) < nsamples(physeq)){
    res <- prune_samples(samples = samples_to_keep, x = physeq)
  }
 
  return(res)
}

tax_glom_fam_reads_limma1 <- phyloseq_richness_filter(tax_glom_fam_reads_limma.pruned, mintaxa = 1)

#now at 1092 samples 





fam_reads_counts_limma <- psmelt(otu_table(tax_glom_fam_reads_limma1))


fam_reads_counts_limma.meta <- data.frame(filename = unique(fam_reads_counts_limma$Sample))
#sanity check - num individuals, diagnosis status, dysb vs. not 
fam_reads_counts_limma.meta <- left_join(fam_reads_counts_limma.meta, hmp2_metadata_phylo, by="filename")

length(unique(fam_reads_counts_limma.meta$Participant.ID))
table(fam_reads_counts_limma.meta$diagnosis.x)
table(fam_reads_counts_limma.meta$dysbiosis_binary)

#115 individuals 
#326 non-IBD samples, 492 CD, 274 UC 
#952 Non, 140 dysbiotic samples 



  
#3) PS melt to generate counts table as df 

fam_reads_countslimma1 <- psmelt(otu_table(tax_glom_fam_reads_limma1))

#For the two family names, it saves the agglomerated OTU name as a contig name (not the family name) - I'll have to change that here by left joining with a version of the iPHOP table (just family)

df_hmp_free_iphop_all_taxa_only_fam <- select(df_hmp_iphop_all, -c("Main.method","Confidence.score", "Additional.methods", "Virulent", "Temperate", "Lifestyle", "Host.genome", "Kingdom","Phylum", "Class", "Order", "Genus", "Species"))
colnames(df_hmp_free_iphop_all_taxa_only_fam) <- c("OTU", "Family")



#remove NAs 
df_hmp_free_iphop_all_taxa_only_fam  <- df_hmp_free_iphop_all_taxa_only_fam[!is.na(df_hmp_free_iphop_all_taxa_only_fam$Family),]


#Left Join
fam_reads_countslimma2 <- left_join(fam_reads_countslimma1,  df_hmp_free_iphop_all_taxa_only_fam, by = "OTU" )
unique(fam_reads_countslimma2$Family)



#Remove the first col with the contigname

fam_reads_countslimma2 <- fam_reads_countslimma2[-1]



#pivot wider 

fam_reads_countslimma3 <- fam_reads_countslimma2 %>%
                 pivot_wider(names_from = Sample, values_from = Abundance)

fam_reads_countslimma3 <- tibble::column_to_rownames(fam_reads_countslimma3, "Family")



#covert to matrix 

fam_reads_counts_matrix_limma <- as.matrix(fam_reads_countslimma3)








```

```{r}

library(limma)
library(edgeR)

#doesn't seem like there is an obvious way to do this:
# difficulty lies in that there are multiple replicates per individual - probably too much variation to use the DESEQ2 collapsereplicates()
# THe forums suggest to use duplicateCorrelation from LIMMA 


#####  LIMMA AT THE FAMILY LEVEL - WHOLE VIROME - NO LIFESTYLE INFO ##################################



#For basic setup of the LIMMA workflow, I followed this: https://ucdavis-bioinformatics-training.github.io/2022-April-GGI-DE-in-R/data_analysis/DE_Analysis_with_quizzes_fixed

#counts table 
rownames(fam_reads_counts_matrix_limma)





#metadata 
metadata_df_limma.1 <- hmp2_metadata_phylo

#filter for samples in matrix 

names.limma <- unique(fam_reads_countslimma2$Sample)
length(names.limma)


metadata_df_limma <- metadata_df_limma.1 %>% 
  filter(filename %in% names.limma)


#It’s very important to check that the samples are in the same order in the metadata and in the counts table, particularly since no errors will be generated if they aren’t–you’ll just get nonsense results.
rownames(metadata_df_limma) <- metadata_df_limma$filename

identical(rownames(metadata_df_limma), colnames(fam_reads_counts_matrix_limma))

#this is false ! to correct 
fam_reads_counts_matrix_1 <- fam_reads_counts_matrix_limma[,rownames(metadata_df_limma)]

#check again... now try 
identical(rownames(metadata_df_limma), colnames(fam_reads_counts_matrix_1))

#turn counts into a DGELIST 

d0_fam_counts <- DGEList(fam_reads_counts_matrix_1)

#now calculate normalization factors 
d0_fam_counts <- calcNormFactors(d0_fam_counts)





#Now we need to filter low expressed genes 
#To do that we will use the EdgeR filterby Expr 
#first we need to create a simple model -

mm_famcounts_diagnosis <- model.matrix(~0 + diagnosis.x, data = metadata_df_limma)
mm_famcounts_diagnosis


#Back to filtering

keep_famcounts_diagnosis <- filterByExpr(d0_fam_counts, mm_famcounts_diagnosis)
sum(keep_famcounts_diagnosis) # This keeps all 18




#filter using this 
d_fam_counts <- d0_fam_counts[keep_famcounts_diagnosis,]




# Voom transformation and calculation of variance weights


vobj_tmp_fam = voom( d_fam_counts, mm_famcounts_diagnosis, plot=TRUE)


#The mean variance trend does not look great, but I dont want to remove anymore samples, so I will rpoceed 

#First duplicate correlation 
dupcor_fam <- duplicateCorrelation(vobj_tmp_fam,mm_famcounts_diagnosis,block=metadata_df_limma$Participant.ID)



# run voom considering the duplicateCorrelation results
# in order to compute more accurate precision weights
# Otherwise, use the results from the first voom run
vobj_fam = voom( d_fam_counts, mm_famcounts_diagnosis, plot=TRUE, block=metadata_df_limma$Participant.ID, correlation=dupcor_fam$consensus)



# Estimate linear mixed model with a single variance component
# Fit the model for each gene, 
dupcor_fam2 <- duplicateCorrelation(vobj_fam, mm_famcounts_diagnosis, block=metadata_df_limma$Participant.ID)


# But this  uses  the virome-wide average for the random effect
fitDupCor_fam <- lmFit(vobj_fam, mm_famcounts_diagnosis, block=metadata_df_limma$Participant.ID, correlation=dupcor_fam2$consensus)

#making contrasts -followed this https://www.bioconductor.org/packages/devel/workflows/vignettes/RNAseq123/inst/doc/limmaWorkflow.html#creating-a-design-matrix-and-contrasts
contr.matrix_fam <- makeContrasts(
   CDvnonIBD = diagnosis.xCD - diagnosis.xnonIBD, 
   UCvnonIBD = diagnosis.xUC - diagnosis.xnonIBD, 
   CDvUC = diagnosis.xCD - diagnosis.xUC, 
   levels = colnames(mm_famcounts_diagnosis))

fitDupCor_fam <- contrasts.fit(fitDupCor_fam, contrasts=contr.matrix_fam)




# Fit Empirical Bayes for moderated t-statistics
fitDupCor_fam <- eBayes( fitDupCor_fam )



summary(decideTests(fitDupCor_fam))
fitDupCor_fam$coefficients

CD_nonIBD_fam <- topTable(fitDupCor_fam, coef = "CDvnonIBD", adjust="BH", number = 18)
UC_nonIBD_fam <- topTable(fitDupCor_fam, coef = "UCvnonIBD", adjust="BH", number = 18)
CD_UC_fam <- topTable(fitDupCor_fam, coef = "CDvUC", adjust="BH", number = 18)


CD_nonIBD_fam
UC_nonIBD_fam
CD_UC_fam


##ggplot2 plot the genes and their LFC


library(tidyverse)
# filter dataframe to get data to be highligheted
CD_nonIBD_fam_df_highlight <- CD_nonIBD_fam %>% 
             filter(adj.P.Val<0.05)







##VOLCANO PLOTS 







##ggplot2 plot the genes and their LFC
CD_nonIBD_fam_df <-  tibble::rownames_to_column(CD_nonIBD_fam, "Family")
#UC plot fam level

CD_nonIBD_fam_df$Family <- gsub("f__", "", CD_nonIBD_fam_df$Family)
           

#CD plot fam level

CD_nonIBD_fam_df %>%
 ggplot(aes(x = logFC, reorder(Family, -logFC))) +
  geom_vline(xintercept = 0) +
  geom_point(aes(color = case_when(logFC > 1 & adj.P.Val < 0.05 ~ "#800000", 
                                   logFC < -1 &  adj.P.Val < 0.05 ~ "#023020",
                                  TRUE ~ "grey" )), size = 5) +
  geom_point(data = . %>% filter(adj.P.Val < 0.05 & logFC > 1 | adj.P.Val < 0.05 & logFC < -1 ), size = 8, color = "darkred", shape = 1) +
  theme(
    axis.text.y = element_text(face = "italic", size = 10),
    axis.title.x = element_text(face = "italic")
  ) +
  scale_x_continuous(
    name = expression(Log[2] ~ " Fold Change")
  ) +
  scale_color_manual(
    values = c("#800000", "#023020", "darkred"),
    breaks = c("#800000", "#023020"),
    labels = c("Below 0", "Above 0")
  ) +
  guides(color = "none")  # Remove the legend



##ggplot2 plot the genes and their LFC
UC_nonIBD_fam_df <-  tibble::rownames_to_column(UC_nonIBD_fam, "Family")
#UC plot fam level

UC_nonIBD_fam_df$Family <- gsub("f__", "", UC_nonIBD_fam_df$Family)
                

UC_nonIBD_fam_df %>%
 ggplot(aes(x = logFC, reorder(Family, -logFC))) +
  geom_vline(xintercept = 0) +
  geom_point(aes(color = case_when(logFC > 1 & adj.P.Val < 0.05 ~ "#301934", 
                                   logFC < -1 &  adj.P.Val < 0.05 ~ "#023020",
                                  TRUE ~ "grey" )), size = 5) +
  geom_point(data = . %>% filter(adj.P.Val < 0.05 & logFC > 1 | adj.P.Val < 0.05 & logFC < -1 ), size = 8, color = "darkred", shape = 1) +
  theme(
    axis.text.y = element_text(face = "italic", size = 10),
    axis.title.x = element_text(face = "italic")
  ) +
  scale_x_continuous(
    name = expression(Log[2] ~ " Fold Change")
  ) +
  scale_color_manual(
    values = c("#301934", "#023020", "darkred"),
    breaks = c("#301934", "#023020"),
    labels = c("Below 0", "Above 0")
  ) +
  guides(color = "none")  # Remove the legend



CD_UC_fam_df <-  tibble::rownames_to_column(CD_UC_fam, "Family")
CD_UC_fam_df$Family <- gsub("f__", "", CD_UC_fam_df$Family)
                            

CD_UC_fam_df %>%
  ggplot(aes(x = logFC, reorder(Family, -logFC))) +
  geom_vline(xintercept = 0) +
  geom_point(aes(color = case_when(logFC > 1 & adj.P.Val < 0.05 ~ "#800000", 
                                   logFC < -1 &  adj.P.Val < 0.05 ~ "#301934",
                                  TRUE ~ "grey" )), size = 5) +
  geom_point(data = . %>% filter(adj.P.Val < 0.05 & logFC > 1 | adj.P.Val < 0.05 & logFC < -1 ), size = 8, color = "darkred", shape = 1) +
  theme(
    axis.text.y = element_text(face = "italic", size = 10),
    axis.title.x = element_text(face = "italic")
  ) +
  scale_x_continuous(
    name = expression(Log[2] ~ " Fold Change")
  ) +
  scale_color_manual(
    values = c("#800000", "#301934", "darkred"),
    breaks = c("#800000", "#301934"),
    labels = c("Below 0", "Above 0")
  ) +
  guides(color = "none")  # Remove the legend


#non IBD colour 
non_IBD_col = 023020
CD_col = 800000
UC_col = 301934



####VOLCANO PLOTS#########

#in order to plot the cutoff of padj and not p-value, we need to give the pvalue column in the df the values from the padj column 

#### CD vs. non-IBD 

CD_nonIBD_fam_df_changed <- CD_nonIBD_fam_df
CD_nonIBD_fam_df_changed$pvalue <- CD_nonIBD_fam_df_changed$adj.P.Val


keyvals_col_con_hmp2_CD_nonIBD <- ifelse(
    CD_nonIBD_fam_df_changed$logFC < -1 & CD_nonIBD_fam_df_changed$adj.P.Val < 0.05, "#301934",
      ifelse(CD_nonIBD_fam_df_changed$logFC > 1 & CD_nonIBD_fam_df_changed$adj.P.Val < 0.05, "#023020",
        'light grey'))
  keyvals_col_con_hmp2_CD_nonIBD[is.na(keyvals_col_con_hmp2_CD_nonIBD)] <- 'light grey'
  names(keyvals_col_con_hmp2_CD_nonIBD)[keyvals_col_con_hmp2_CD_nonIBD == "#301934"] <- 'Enriched in CD Samples'
  names(keyvals_col_con_hmp2_CD_nonIBD)[keyvals_col_con_hmp2_CD_nonIBD == 'light grey'] <- 'Non-significant'
  names(keyvals_col_con_hmp2_CD_nonIBD)[keyvals_col_con_hmp2_CD_nonIBD == "#023020"] <- 'Enriched in Control Samples'

EV_col_con_CD_nonIBD <- EnhancedVolcano(CD_nonIBD_fam_df_changed, lab=NA , x = 'logFC',
    y = 'pvalue',  pCutoff = 0.05, cutoffLineWidth = 0.1, selectLab = rownames(CD_nonIBD_fam_df_changed)[which(names(keyvals_col_con_hmp2_CD_nonIBD) %in% c('Over-Abundant in CD', 'Over-Abundant in Control'))], pointSize = 2, gridlines.major = FALSE, gridlines.minor = FALSE, colCustom = keyvals_col_con_hmp2_CD_nonIBD,  legendPosition = 'right', legendLabSize = 12,legendIconSize = 4.0, title = "", axisLabSize = 15,    subtitle = "", caption = ""
)








###UC vs. non-IBD#####
CD_nonIBD_fam_df
UC_nonIBD_fam_df
UC_nonIBD_fam_df_changed <- UC_nonIBD_fam_df
UC_nonIBD_fam_df_changed$pvalue <- UC_nonIBD_fam_df_changed$adj.P.Val


keyvals_col_con_hmp2_UC_nonIBD <- ifelse(
    UC_nonIBD_fam_df_changed$logFC < -1 & UC_nonIBD_fam_df_changed$adj.P.Val < 0.05, "#301934",
      ifelse(UC_nonIBD_fam_df_changed$logFC > 1 & UC_nonIBD_fam_df_changed$adj.P.Val < 0.05, "#023020",
        'light grey'))
  keyvals_col_con_hmp2_UC_nonIBD[is.na(keyvals_col_con_hmp2_UC_nonIBD)] <- 'light grey'
  names(keyvals_col_con_hmp2_UC_nonIBD)[keyvals_col_con_hmp2_UC_nonIBD == "#301934"] <- 'Enriched in UC Samples'
  names(keyvals_col_con_hmp2_UC_nonIBD)[keyvals_col_con_hmp2_UC_nonIBD == 'light grey'] <- 'Non-significant'
  names(keyvals_col_con_hmp2_UC_nonIBD)[keyvals_col_con_hmp2_UC_nonIBD == "#023020"] <- 'Enriched in Control Samples'

EV_col_con_UC_nonIBD <- EnhancedVolcano(UC_nonIBD_fam_df_changed, lab=NA , x = 'logFC',
    y = 'pvalue',  pCutoff = 0.05, cutoffLineWidth = 0.1, selectLab = rownames(UC_nonIBD_fam_df_changed)[which(names(keyvals_col_con_hmp2_UC_nonIBD) %in% c('Over-Abundant in UC', 'Over-Abundant in Control'))], pointSize = 2, gridlines.major = FALSE, gridlines.minor = FALSE, colCustom = keyvals_col_con_hmp2_UC_nonIBD,  legendPosition = 'right', legendLabSize = 12,legendIconSize = 4.0, title = "", axisLabSize = 15,    subtitle = "", caption = ""
)



##### CD vs. UC #########
CD_UC_fam_df_changed <- CD_UC_fam_df
CD_UC_fam_df_changed$pvalue <- CD_UC_fam_df_changed$adj.P.Val


keyvals_col_con_hmp2_CD_UC <- ifelse(
    CD_UC_fam_df_changed$logFC < -1 & CD_UC_fam_df_changed$adj.P.Val < 0.05, "#702963",
      ifelse(CD_UC_fam_df_changed$logFC > 1 & CD_UC_fam_df_changed$adj.P.Val < 0.05, "#800000",
        'light grey'))
  keyvals_col_con_hmp2_CD_UC[is.na(keyvals_col_con_hmp2_CD_UC)] <- 'light grey'
  names(keyvals_col_con_hmp2_CD_UC)[keyvals_col_con_hmp2_CD_UC == "#800000"] <- 'Enriched in CD Samples'
  names(keyvals_col_con_hmp2_CD_UC)[keyvals_col_con_hmp2_CD_UC == 'light grey'] <- 'Non-significant'
  names(keyvals_col_con_hmp2_CD_UC)[keyvals_col_con_hmp2_CD_UC == "#702963"] <- 'Enriched in UC Samples'

EV_col_con_CD_UC <- EnhancedVolcano(CD_UC_fam_df_changed, lab=NA , x = 'logFC',
    y = 'pvalue',  pCutoff = 0.05, cutoffLineWidth = 0.1, selectLab = rownames(CD_UC_fam_df_changed)[which(names(keyvals_col_con_hmp2_CD_UC) %in% c('Over-Abundant in CD', 'Over-Abundant in UC'))], pointSize = 2, gridlines.major = FALSE, gridlines.minor = FALSE, colCustom = keyvals_col_con_hmp2_CD_UC,  legendPosition = 'right', legendLabSize = 12,legendIconSize = 4.0, title = "", axisLabSize = 15,    subtitle = "", caption = ""
)




```




  
  
  



```{r}

#AMG table 

#will need just the samples without 1500 
df_hmp_virome_merged.2 <- left_join(filtered.1500.df_hmp_virome, hmp2_vir_iphop, by="contigname")
df_hmp_virome_merged.2.iphop <- df_hmp_virome_merged.2[!is.na(df_hmp_virome_merged.2$Family),]

length(unique(df_hmp_virome_merged.2$contigname))
length(unique(df_hmp_virome_merged.2.iphop$contigname))


df_hmp_virome_merged.2.names <- unique(df_hmp_virome_merged.2$contigname)



#3886 contigs - need to filter to get the 3,870 


#define 
`%!in%` <- function(x, y) {
  !(x %in% y)
}
df_hmp_iphop_all.analyses.one <-   df_hmp_iphop_all_1

df_hmp_iphop_all.analyses <- df_hmp_iphop_all.analyses.one %>% 
  filter(contigname %!in% df_hmp_virome_merged.2.names)





AMGs <- read.table("/Users/anshulsinha/Desktop/IBD_prophages_aim/bioinformatics_aim/bioinformatics_HMP_2/virome_data_08_2024/AMGs/concatenated_AMGs.tsv", sep = "\t", quote = "", header = TRUE)

#create new column to indicate where the contig came from 


AMGs <- AMGs %>%
  mutate(participant.ID = sub("^[^_]*_[^_]*_[^_]*_([^\\.]+)\\..*$", "\\1", filename))

#now append to the contig name to be consistent with contig naming format 

AMGs$contigname <- paste(AMGs$participant.ID,"_",AMGs$scaffold, sep = "")

#replace whitespace with underscores for consistency 
AMGs$contigname <- gsub(" ", "_", AMGs$contigname)


#now filter so I only include the 3,870 contigs I care about - ones with iphop assignments 

length(unique(df_hmp_virome_merged.2.iphop$contigname)) #3,370

iphop.names <- df_hmp_virome_merged.2.iphop$contigname

#filter to just contain those names 
AMGs$contigname 

AMGs.filtered <- AMGs %>% 
  filter(contigname %in% iphop.names)

length(unique(AMGs.filtered$participant.ID)) 


length(unique(AMGs.filtered$protein)) 

#left with only 1,789 rows - suggests that not every contig has an AMG - sanity check to confirm that I am not missing anything 




'%!in%' <- function(x,y)!('%in%'(x,y))


AMGs.filtered.out <- AMGs %>% 
  filter(contigname %!in% iphop.names)


#read in C3001 VIBRANT file 

AMGs.C3001 <- read.table("/Users/anshulsinha/Desktop/IBD_prophages_aim/bioinformatics_aim/bioinformatics_HMP_2/virome_data_08_2024/AMGs/VIBRANT_AMG_individuals_C3001.contigs.tsv", sep = "\t", quote = "", header = TRUE)

length(unique(AMGs.C3001$scaffold))
#90 AMGs from 64 contigs - from C3001 log - 716 phages total - means that not all phages have a detected AMG - our completeness cutoff means that we are keeping a higher proportion 

#back to our filtered data

length(unique(AMGs.filtered$scaffold))

#1,089 distinct contigs with AMGs (1,789 - indicating some contigs have multiple AMGs)


#A PBF sanity check from the iphop output 


#3886 contigs - need to filter to get the 3,870 

df_hmp_iphop_all.analyses.one <-   df_hmp_iphop_all_1
df_hmp_iphop_all.analyses.one

df_hmp_iphop_all.analyses <- df_hmp_iphop_all.analyses.one %>% 
  filter(contigname %in% df_hmp_virome_merged.2.names)



length(df_hmp_iphop_all.analyses$contigname) #3,870

df_hmp_iphop_all.analyses.filtered <- df_hmp_iphop_all.analyses

length(df_hmp_iphop_all.analyses.filtered$contigname) #3,870


#if "NA" change to contig name 
df_hmp_iphop_all.analyses$Family <- ifelse(is.na(df_hmp_iphop_all.analyses$Family), df_hmp_iphop_all.analyses$contigname, df_hmp_iphop_all.analyses$Family)


na_count <- sum(is.na(df_hmp_iphop_all.analyses.filtered$Family))

#507 NAs 

3870-500  #3,370 have PBF membership 


#of the remaining 
df_hmp_iphop_all.analyses.2 <- df_hmp_iphop_all.analyses.filtered

df_hmp_iphop_all.analyses.2 <- df_hmp_iphop_all.analyses.2[!is.na(df_hmp_iphop_all.analyses.2$Family), ]


length(unique(df_hmp_iphop_all.analyses.2$Family)) #3,370 PBFs into 74 PBFs 

df_hmp_iphop_all.analyses.2.grouped <- df_hmp_iphop_all.analyses.2 %>% 
  group_by(Family) %>% 
  summarise(contig_count = n_distinct(contigname))


df_hmp_iphop_all.analyses.2.grouped

mean(df_hmp_iphop_all.analyses.2.grouped$contig_count)
sd(df_hmp_iphop_all.analyses.2.grouped$contig_count)

#plot number of contigs/PBF


ggplot(df_hmp_iphop_all.analyses.2.grouped, aes(x = reorder(Family,-contig_count) , y = contig_count)) +
    geom_point(size = 0.1) +  
    geom_jitter() + 
    labs(x = "PBF", y = "Contigs per PBF", 
         title = "Contigs per PBF") +
    annotate("segment", x = 11.5, xend = 11.5, y = 0, yend = 900, 
          linetype = "dashed", color = "red", size = 0.25) +
    theme_minimal() +
    theme(axis.text.x = element_blank())  # Removes species labels


#seems like there is a delination at number 11 (85 vs 37)

df_hmp_iphop_all.analyses.2.grouped %>% 
  arrange(-contig_count)

#filter for top 11 

df_hmp_iphop_all.analyses.2.grouped.11 <-  df_hmp_iphop_all.analyses.2.grouped[df_hmp_iphop_all.analyses.2.grouped$contig_count > 37,]


#plot again 

ggplot(df_hmp_iphop_all.analyses.2.grouped.11, aes(x = reorder(Family,-contig_count) , y = contig_count)) +
    geom_point(size = 1) +  
    #geom_jitter() + 
    labs(x = "PBF", y = "Contigs per PBF", 
         title = "Contigs per PBF") +
    annotate("segment", x = 11.5, xend = 11.5, y = 0, yend = 900, 
          linetype = "dashed", color = "red", size = 0.25) +
    theme_minimal() +
    theme(axis.text.x = element_blank())  # Removes species labels



#are all of these 11 the most prevalent? 

df_hmp_iphop_all.analyses.2.grouped.11.prev.ind <- df_hmp_iphop_all.analyses.2.grouped.11 %>% 
  filter(Family %in% PBF_list_50_prev$Family) 
#all 11 found in at least. 50% of individuals prevalent 



df_hmp_iphop_all.analyses.2.grouped.11.prev.ind <- df_hmp_iphop_all.analyses.2.grouped.11 %>% 
  filter(Family %in% PBF_list_50_prev.sample$Family) 

#all 8 found in at least 50% of samples 




##BACK TO AMGs 


AMGs.filtered

AMGs.filtered$contigname <- gsub(" ", "_", AMGs.filtered$contigname)

#Read in the file from the VIBRANT github that maps the KOs to their pathway 

AMG.mapper <- read.table("/Users/anshulsinha/Desktop/IBD_prophages_aim/bioinformatics_aim/bioinformatics_HMP_2/virome_data_08_2024/AMGs/VIBRANT_KEGG_pathways_summary.tsv", quote = "", sep = "\t", header = TRUE)


#give each Entry..map. a new row with KO 


AMG.mapper.1 <- AMG.mapper %>%
  separate_rows(KOs, sep = "~")

table(AMG.mapper.1$Metabolism)


# I can now filter out the Entry map. and Pathway column to simplify things 

AMG.mapper.2 <- AMG.mapper.1 %>% 
  select(Metabolism, KOs)

#remove duplicate rows - some should exist because the same KOs may belong to diff Pathway and Entry Maps, but the same Metabolism 

AMG.mapper.3 <- AMG.mapper.2[!duplicated(AMG.mapper.2), ]

table(AMG.mapper.3$Metabolism)

length(unique(AMG.mapper.3$KOs))


#there are 5,625 unique KOs, despite 6,547 rows

#identify KOs that are found across multiple categories 
AMG.mapper.3.mapping.multiples <- AMG.mapper.3 %>% 
  group_by(KOs) %>% 
  summarise(metabolism_count=n_distinct(Metabolism))

AMG.mapper.4.mapping.multiples <- AMG.mapper.3.mapping.multiples[AMG.mapper.3.mapping.multiples$metabolism_count > 1,]
#678 KOs with multiple metabolism categories 


#are any of these in our AMG df 

AMGs.filtered.test <- AMGs.filtered %>% 
  filter(AMG.KO %in% AMG.mapper.4.mapping.multiples$KOs)

length(unique(AMGs.filtered.test$AMG.KO)) #89 KOs with multiple - making up 265 rows 






AMGs.filtered.test2 <- AMGs.filtered.test %>%
group_by(AMG.KO) %>% 
  summarise(contigcount=n_distinct(contigname))
#can see some of these 89 KOs are found in multiple contigs




#What I will do is create a column that gives a combined Metabolism KO value 
AMG.mapper.3$KO_metabolism <- paste(AMG.mapper.3$Metabolism, AMG.mapper.3$KOs, sep="_")



#assign rownames to keep track 

AMGs.filtered$rownumbers <- 1:nrow(AMGs.filtered)


AMGs.filtered$KOs <- AMGs.filtered$AMG.KO



AMGs.filtered.joined <- left_join(AMGs.filtered, AMG.mapper.3, by="KOs")



#can see that there are now 2,129 compared to 1,790 earlier 

#seems like less rows than I wouldve expcted



AMGs.filtered.joined.test <- AMGs.filtered.joined %>% 
  filter(KOs %in% AMG.mapper.4.mapping.multiples$KOs) #this has 605 rows


AMGs.filtered.joined.test2 <- AMGs.filtered %>% 
  filter(KOs %in% AMG.mapper.4.mapping.multiples$KOs) #this has 265 rows


AMGs.filtered.joined.test3 <- AMGs.filtered.joined %>% #in the joined df - how many KOs don't have multiple
  filter(KOs %!in% AMG.mapper.4.mapping.multiples$KOs) #this has 1,524 rows


#reminder - #89 KOs with multiple metabolism categories - making up 265 rows 

1524 + 265 #1,789

1524 + 605 # 2,129 This number accounts for the  times the 89 KOs  were counted multiple times 

length(unique(AMGs.filtered.joined$contigname)) # comes from 1,089 unique contigs 
#some contigs contain multiple AMGs and some AMGs belong to multiple categories 




#now left join with iphop 

AMGs.filtered.joined.iphop <- left_join(AMGs.filtered.joined, hmp2_vir_iphop, by="contigname")


#how many PHFs carry an AMG 

length(unique(AMGs.filtered.joined.iphop$Family))
45/74


#####what are the most prevalent AMGs in my dataset??#####
table(AMGs.filtered.joined.iphop$Metabolism) ## AA metabolism= 732 ## Carb metabolism = 224 ### Energy metabolism = 340 #### Cofactor = 329
#play around with these 4 







#########AMG distribution################

#Overall distribution 
#create function that gives a distribution of AMGs - can filter for specific PHFs
AMG_distribution <- function(df) {
  
AMGs.filtered.joined.iphop.grouped <- df %>% 
  group_by(Metabolism) %>% 
  summarize(count=n_distinct(protein))

#note that Im counting distinct proteins rather than contigs in case a scaffold contains two KOs from the same category o

AMGs.filtered.joined.iphop.grouped <- AMGs.filtered.joined.iphop.grouped[!is.na(AMGs.filtered.joined.iphop.grouped$Metabolism),]
AMGs.filtered.joined.iphop.grouped$Metabolism <- gsub('"', '', AMGs.filtered.joined.iphop.grouped$Metabolism)

  AMGs.filtered.joined.iphop.grouped
}







###PLOTTING OVERALL AMGS DISTRIBUTION#####
overall_AMG_distribution <-  AMG_distribution(AMGs.filtered.joined.iphop)
ggplot(overall_AMG_distribution, aes(x = Metabolism, y = count, fill = Metabolism)) +
  geom_bar(stat = "identity", width = 1) + 
  theme(axis.text.x = element_blank())



####PLOTTING THE ENTEROBACTERIACEAE DISTRIBUTION#####

AMGs.filtered.joined.iphop_entero <- AMGs.filtered.joined.iphop[AMGs.filtered.joined.iphop$Family == "f__Enterobacteriaceae",]
entero_AMG_distribution <-  AMG_distribution(AMGs.filtered.joined.iphop_entero)


ggplot(entero_AMG_distribution, aes(x = Metabolism, y = count, fill = Metabolism)) +
  geom_bar(stat = "identity", width = 1) + 
  theme(axis.text.x = element_blank()) +
  ggtitle("Enterobacteriaceae")


####PLOTTING THE Ruminococcacaea DISTRIBUTION#####

AMGs.filtered.joined.iphop_rumino <- AMGs.filtered.joined.iphop[AMGs.filtered.joined.iphop$Family == "f__Ruminococcaceae",]
rumino_AMG_distribution <-  AMG_distribution(AMGs.filtered.joined.iphop_rumino)


ggplot(rumino_AMG_distribution, aes(x = Metabolism, y = count, fill = Metabolism)) +
  geom_bar(stat = "identity", width = 1) + 
  theme(axis.text.x = element_blank()) +
  ggtitle("Ruminococcaceae")


####PLOTTING THE CAG-74 DISTRIBUTION#####
AMGs.filtered.joined.iphop_cag_74 <- AMGs.filtered.joined.iphop[AMGs.filtered.joined.iphop$Family == "f__CAG-74",]
cag74_AMG_distribution <-  AMG_distribution(AMGs.filtered.joined.iphop_cag_74)


ggplot(cag74_AMG_distribution, aes(x = Metabolism, y = count, fill = Metabolism)) +
  geom_bar(stat = "identity", width = 1) + 
  theme(axis.text.x = element_blank()) + 
  ggtitle("CAG-74")



####PLOTTING THE Acidaminococcaceae DISTRIBUTION#####

AMGs.filtered.joined.iphop_acidamino <- AMGs.filtered.joined.iphop[AMGs.filtered.joined.iphop$Family == "f__Acidaminococcaceae",]
acidamino_AMG_distribution <-  AMG_distribution(AMGs.filtered.joined.iphop_acidamino)


ggplot(acidamino_AMG_distribution, aes(x = Metabolism, y = count, fill = Metabolism)) +
  geom_bar(stat = "identity", width = 1) + 
  theme(axis.text.x = element_blank()) + 
  ggtitle("Acidaminococcaceae")


####PLOTTING THE Acutalibacteraceae DISTRIBUTION#####

AMGs.filtered.joined.iphop_acut <- AMGs.filtered.joined.iphop[AMGs.filtered.joined.iphop$Family == "f__Acutalibacteraceae",]
acut_AMG_distribution <-  AMG_distribution(AMGs.filtered.joined.iphop_acut)


ggplot(acut_AMG_distribution, aes(x = Metabolism, y = count, fill = Metabolism)) +
  geom_bar(stat = "identity", width = 1) + 
  theme(axis.text.x = element_blank())  + 
  ggtitle("Acutalibacteraceae")



####PLOTTING THE Lachnospiraceae DISTRIBUTION#####

AMGs.filtered.joined.iphop_lachno <- AMGs.filtered.joined.iphop[AMGs.filtered.joined.iphop$Family == "f__Lachnospiraceae",]
lachno_AMG_distribution <-  AMG_distribution(AMGs.filtered.joined.iphop_lachno)


ggplot(lachno_AMG_distribution, aes(x = Metabolism, y = count, fill = Metabolism)) +
  geom_bar(stat = "identity", width = 1) + 
  theme(axis.text.x = element_blank()) + 
  ggtitle("Lachnospiraceae")


####PLOTTING THE Bacteriodaceae DISTRIBUTION#####

AMGs.filtered.joined.iphop_bacteroid <- AMGs.filtered.joined.iphop[AMGs.filtered.joined.iphop$Family == "f__Bacteroidaceae",]
bacterioid_AMG_distribution <-  AMG_distribution(AMGs.filtered.joined.iphop_bacteroid)


ggplot(bacterioid_AMG_distribution, aes(x = Metabolism, y = count, fill = Metabolism)) +
  geom_bar(stat = "identity", width = 1) + 
  theme(axis.text.x = element_blank()) + 
  ggtitle("Bacteroidaceae")

####PLOTTING THE Bifidobacteriaceae DISTRIBUTION#####

AMGs.filtered.joined.iphop_bifido <- AMGs.filtered.joined.iphop[AMGs.filtered.joined.iphop$Family == "f__Bifidobacteriaceae",]
bifido_AMG_distribution <-  AMG_distribution(AMGs.filtered.joined.iphop_bifido)


ggplot(bifido_AMG_distribution, aes(x = Metabolism, y = count, fill = Metabolism)) +
  geom_bar(stat = "identity", width = 1) + 
  theme(axis.text.x = element_blank()) + 
  ggtitle("Bifidobacteriaceae")


####PLOTTING THE Oscillospiraceae DISTRIBUTION#####

AMGs.filtered.joined.iphop_oscillo <- AMGs.filtered.joined.iphop[AMGs.filtered.joined.iphop$Family == "f__Oscillospiraceae",]
oscillospiraceae_AMG_distribution <-  AMG_distribution(AMGs.filtered.joined.iphop_oscillo)


ggplot(oscillospiraceae_AMG_distribution, aes(x = Metabolism, y = count, fill = Metabolism)) +
  geom_bar(stat = "identity", width = 1) + 
  theme(axis.text.x = element_blank()) + 
  ggtitle("Oscillospiraceae")







#I noticed enrichment in ENterobacteriaceae protein folding - lets look into this 

AMGs.filtered.joined.iphop_entero <- AMGs.filtered.joined.iphop_entero


AMGs.filtered.joined.iphop_entero$Metabolism <- gsub('"', '',   AMGs.filtered.joined.iphop_entero$Metabolism)

AMGs.filtered.joined.iphop_entero.pf <- AMGs.filtered.joined.iphop_entero[AMGs.filtered.joined.iphop_entero$Metabolism == "Folding, sorting and degradation",]

length(unique(AMGs.filtered.joined.iphop_entero.pf$scaffold)) 


#look specifically at the CysO gene

AMGs.filtered.joined.iphop_entero.pf.cyso <- AMGs.filtered.joined.iphop_entero[AMGs.filtered.joined.iphop_entero$AMG.KO.name == "mec; [CysO sulfur-carrier protein]-S-L-cysteine hydrolase [EC:3.13.1.6]",]

length(unique(AMGs.filtered.joined.iphop_entero.pf.cyso$scaffold)) #14 entero scaffolds carry this gene

#compare that all of them (across PHFs)

AMGs.filtered.joined.iphop.cyso <- AMGs.filtered.joined.iphop[AMGs.filtered.joined.iphop$AMG.KO.name == "mec; [CysO sulfur-carrier protein]-S-L-cysteine hydrolase [EC:3.13.1.6]",]
length(unique(AMGs.filtered.joined.iphop.cyso$scaffold))
table(AMGs.filtered.joined.iphop.cyso$Family)


#number of cysO across genomes 

AMGs.filtered.joined.iphop.cyso 
length(AMGs.filtered.joined.iphop.cyso$scaffold)

length(unique(AMGs.filtered.joined.iphop.cyso$scaffold)) #21 total 



AMGs.filtered.joined.iphop.families.cyso <- AMGs.filtered.joined.iphop.cyso %>% 
  group_by(Family) %>% 
  summarize(n_AMGs = n_distinct(protein))



ggplot(AMGs.filtered.joined.iphop.families.cyso, aes(x = reorder(Family,-n_AMGs
) , y = n_AMGs
)) +
    geom_bar(stat = "identity") +  
    labs(x = "PHF", y = "AMGs", 
         title = "CysO") +
    theme_minimal() + 
        theme(axis.text.x = element_text(size = 8,angle = 45, hjust = 1, face="italic")) 







AMGs.filtered.joined.iphop.checkv.length <- left_join(AMGs.filtered.joined.iphop,checkV_virome, by= "contigname")
                      


###IMPORTANT NOTE HERE -In the code below we're calculating AMGs/Mb  just based off of the mb of contigs that contain an AMG (ie- not all contigs in the PHF).Also, its counting contig length multiple times for contigs that have more than one AMG. After intiial submission, I realized this should instead be normalized to contig length of total contigs in the dataset (regardless if they do or do not have a contig). I've done this is in the next block of code. But am keeping the original process here for posterity



#### Stacked bar chart for AMG distribution #####

AMGs.filtered.joined.iphop
AMGs.filtered.joined.iphop.grouped.family <- AMGs.filtered.joined.iphop%>% 
  group_by(Family, Metabolism) %>%
  summarize(count=n_distinct(protein))


#simplify to only those that have more than 10 contigs 
AMGs.filtered.joined.iphop.2 <- AMGs.filtered.joined.iphop%>% 
  group_by(Family) %>%
  summarize(n_contigs_total=n_distinct(contigname))

length(unique(AMGs.filtered.joined.iphop.grouped.family$Family))

AMGs.filtered.joined.iphop.grouped.family.joined <- left_join(AMGs.filtered.joined.iphop.grouped.family, AMGs.filtered.joined.iphop.2, by= "Family")

AMGs.filtered.joined.iphop.grouped.family.joined <- AMGs.filtered.joined.iphop.grouped.family.joined[AMGs.filtered.joined.iphop.grouped.family.joined$n_contigs_total >10,]

length(unique(AMGs.filtered.joined.iphop.grouped.family.joined$Family)) #12 PHFs contain more than 10 AMGs

AMGs.filtered.joined.iphop.grouped.family.joined <-  AMGs.filtered.joined.iphop.grouped.family.joined[!is.na(AMGs.filtered.joined.iphop.grouped.family.joined$Metabolism),]


library(viridis)
colors <- viridis(10)
AMGs.filtered.joined.iphop.grouped.family.joined$Family <- gsub("f__", "", AMGs.filtered.joined.iphop.grouped.family.joined$Family )

AMGs.filtered.joined.iphop.grouped.family.joined$Metabolism <- gsub('"', '', AMGs.filtered.joined.iphop.grouped.family.joined$Metabolism)


ggplot(AMGs.filtered.joined.iphop.grouped.family.joined, aes(x = Family, y = count, fill = Metabolism)) +
  geom_bar(stat = "identity", position = "fill") +
  scale_y_continuous(labels = scales::percent_format()) +
    scale_fill_manual(values = brewer.pal(12, "Set3")) +
  labs(y = "Proportion", x = "", fill = "Metabolism Category") +
  theme_minimal() + 
    theme(axis.text.x = element_text(size = 8,angle = 45, hjust = 1, face="italic")) 












#######HOW MANY CONTIGS ARE THERE PER FAMILY??#######

AMGs.filtered.joined.iphop.2 <- AMGs.filtered.joined.iphop%>% 
  group_by(Family) %>%
  summarize(n_contigs_total=n_distinct(contigname))


#now calculate the number of distinct contigs per metabolism family 

#need to first ensure that all families and metabolism groups are there (this is to ensure for cases of Family where contig = 0)

# Create all combinations of Family and Metabolism
all_combinations <- AMGs.filtered.joined.iphop %>%
  distinct(Family, Metabolism) %>%
  complete(Family, Metabolism)


# Summarize the data and count distinct contigs
AMGs.filtered.joined.iphop.3 <- AMGs.filtered.joined.iphop %>%
  group_by(Family, Metabolism) %>%
  summarize(n_contigs = n_distinct(contigname))

# Left join with all combinations and replace NA with 0
AMGs.filtered.joined.iphop.3 <- all_combinations %>%
  left_join(AMGs.filtered.joined.iphop.3, by = c("Family", "Metabolism")) %>%
  replace_na(list(n_contigs = 0))


#now join the two 

AMGs.filtered.joined.iphop.4 <- left_join(AMGs.filtered.joined.iphop.3, AMGs.filtered.joined.iphop.2, by="Family")
  AMGs.filtered.joined.iphop.4$prop <- AMGs.filtered.joined.iphop.4$n_contigs/AMGs.filtered.joined.iphop.4$n_contigs_total

  AMGs.filtered.joined.iphop.4$Metabolism <- gsub('"', '',   AMGs.filtered.joined.iphop.4$Metabolism)



  #now filter for the ones we care about 
  AMGs.filtered.joined.iphop.5 <- AMGs.filtered.joined.iphop.4[AMGs.filtered.joined.iphop.4$Metabolism == "Carbohydrate metabolism" | AMGs.filtered.joined.iphop.4$Metabolism == "Amino acid metabolism" | AMGs.filtered.joined.iphop.4$Metabolism == "Energy metabolism" | AMGs.filtered.joined.iphop.4$Metabolism == "Metabolism of cofactors and vitamins" | AMGs.filtered.joined.iphop.4$Metabolism  == "Folding, sorting and degradation" | AMGs.filtered.joined.iphop.4$Metabolism == "Glycan biosynthesis and metabolism",]

  

  
  
  
  
  
  
  
  
####TERNARY PLOTS########
library(Ternary)

  
AMGs.filtered.joined.iphop.5 <- AMGs.filtered.joined.iphop.5[!is.na(AMGs.filtered.joined.iphop.5$Metabolism),]
  
  #filter an arbitrary 20 
AMGs.filtered.joined.iphop.5.filtered <- AMGs.filtered.joined.iphop.5[AMGs.filtered.joined.iphop.5$n_contigs_total > 20,]

  
AMGs.filtered.joined.iphop.5.wider <- AMGs.filtered.joined.iphop.5.filtered %>% 
           pivot_wider(names_from = Metabolism, values_from = prop, id_cols= Family)


library(ggtern)

colnames(AMGs.filtered.joined.iphop.5.wider) <- gsub(" ", "_", colnames(AMGs.filtered.joined.iphop.5.wider))

colnames(AMGs.filtered.joined.iphop.5.wider) <- gsub(",", "", colnames(AMGs.filtered.joined.iphop.5.wider))

AMGs.filtered.joined.iphop.5.wider


data.AMGs.filtered.joined.iphop.5.wider.1 <- as.data.frame(AMGs.filtered.joined.iphop.5.wider[c("Folding_sorting_and_degradation", "Glycan_biosynthesis_and_metabolism", "Metabolism_of_cofactors_and_vitamins")])


# plotting
ggtern(data = data.AMGs.filtered.joined.iphop.5.wider.1, aes(Folding_sorting_and_degradation, Glycan_biosynthesis_and_metabolism, Metabolism_of_cofactors_and_vitamins)) +
  geom_point(
    alpha = 3,
    size = 4,
    color = "coral"
  ) +
  theme_rgbw() 






#####Group by PBF to see if certain PBFs are enriched in AMGs or in certain Metabolism modules etc.#####


#join all contigs to get the total length of each contig 

AMGs.filtered.joined.iphop.checkv.length <- left_join(AMGs.filtered.joined.iphop,checkV_virome, by= "contigname")


###IMPORTANT NOTE HERE - WE ARE CALCULATING THE AMGS/MB (and the contig length) just based off of the mb of contigs that contain an AMG (ie- not all contigs in the PHF). This is in response to the distribution graph I had earlier (ie showing proportion of AMGs in Enterobacteriacea are more protein-folding skewed). This answers - of the AMGs that a PHF has, what is the distribution. We are then normalizing by Mb containing an AMG to ensure that we're not just getting more - ie more protein folding AMGs because we have more Enteraobacteriaceae contigs in general. Either way, as a sanity check in the next block of code I've provided the data if we make the denominator instead the total Mb of a PHF. 

                                 
#now get the sum per family       
sum_per_fam <- AMGs.filtered.joined.iphop.checkv.length %>% 
  group_by(Family) %>%  
  summarize(sum_length=sum(contig_length))

#also plot in general the length per PHF


ggplot(sum_per_fam, aes(x = reorder(Family,-sum_length
) , y = sum_length
)) +
    geom_bar(stat = "identity") +  
    labs(x = "PHF", y = "Assembled bases", 
         title = "Assembled Bases") +
    theme_minimal() + 
        theme(axis.text.x = element_text(size = 8,angle = 45, hjust = 1, face="italic")) 











#filter for just protein folding ones
AMGs.filtered.joined.iphop$Metabolism <- gsub('"', "", AMGs.filtered.joined.iphop$Metabolism)
AMGs.filtered.joined.iphop.pf <- AMGs.filtered.joined.iphop[AMGs.filtered.joined.iphop$Metabolism == "Folding, sorting and degradation",]

#count the number of protein folding AMGs/fam

AMGs.filtered.joined.iphop.families.pf <- AMGs.filtered.joined.iphop.pf %>% 
  group_by(Family) %>% 
  summarize(n_AMGs = n_distinct(protein))



joined.pf <- left_join(sum_per_fam, AMGs.filtered.joined.iphop.families.pf, by= "Family")

#calculate per bp 
joined.pf$AMG.per.bp <- joined.pf$n_AMGs/joined.pf$sum_length


#filter for just the PHFs that H
joined.pf$n_AMGs <- ifelse(is.na(joined.pf$n_AMGs), 0, joined.pf$n_AMGs)

joined.pf$AMG.per.bp <- ifelse(is.na(joined.pf$AMG.per.bp), 0, joined.pf$AMG.per.bp)

joined.pf$AMG.per.1000kbp <- (joined.pf$n_AMGs/joined.pf$sum_length)*1000000                                         
joined.pf



#filter for the PHFs that have more than 10 contigs with AMGs 

AMGs.filtered.joined.iphop.grouped.family.joined.10 <- AMGs.filtered.joined.iphop.grouped.family.joined[AMGs.filtered.joined.iphop.grouped.family.joined$n_contigs_total >10,]

contigs.10.amgs <- AMGs.filtered.joined.iphop.grouped.family.joined.10$Family

joined.pf$Family <- gsub("f__", "", joined.pf$Family )
contigs.10.amgs

joined.pf.filtered <- joined.pf %>% 
  filter(Family %in% contigs.10.amgs)


#now plot 

ggplot(joined.pf.filtered, aes(x = reorder(Family,-AMG.per.1000kbp
) , y = AMG.per.1000kbp
)) +
    geom_bar(stat = "identity") +  
    labs(x = "PHF", y = "AMGs per Mb", 
         title = "Protein Folding, Sorting and Degradation") +
    theme_minimal() + 
        theme(axis.text.x = element_text(size = 8,angle = 45, hjust = 1, face="italic")) 



#Now do this agnostic to Metabolism Category 

#count the number of protein folding AMGs/fam

AMGs.filtered.joined.iphop.families.grouped.all <- AMGs.filtered.joined.iphop %>% 
  group_by(Family) %>% 
  summarize(n_AMGs = n_distinct(protein))



joined.all.AMGs <- left_join(sum_per_fam, AMGs.filtered.joined.iphop.families.grouped.all, by= "Family")

#calculate per bp 
joined.all.AMGs$AMG.per.bp <- joined.all.AMGs$n_AMGs/joined.all.AMGs$sum_length


#filter for just the PHFs that H
joined.all.AMGs$n_AMGs <- ifelse(is.na(joined.all.AMGs$n_AMGs), 0, joined.all.AMGs$n_AMGs)

joined.all.AMGs$AMG.per.bp <- ifelse(is.na(joined.all.AMGs$AMG.per.bp), 0, joined.all.AMGs$AMG.per.bp)
joined.all.AMGs$AMG.per.1000kbp <- (joined.all.AMGs$n_AMGs/joined.all.AMGs$sum_length)*1000000                                         
joined.all.AMGs

joined.all.AMGs$Family <- gsub("f__", "", joined.all.AMGs$Family )
contigs.10.amgs

joined.all.AMGs.Filtered <- joined.all.AMGs %>% 
  filter(Family %in% contigs.10.amgs)

ggplot(joined.all.AMGs.Filtered, aes(x = reorder(Family,-AMG.per.1000kbp
) , y = AMG.per.1000kbp
)) +
    geom_bar(stat = "identity") +  
    labs(x = "PHF", y = "AMGs per Mb", 
         title = "All AMGs") +
    theme_minimal() + 
        theme(axis.text.x = element_text(size = 8,angle = 45, hjust = 1, face="italic")) 




####now do this based on carb metabolism #####

AMGs.filtered.joined.iphop.carb <- AMGs.filtered.joined.iphop[AMGs.filtered.joined.iphop$Metabolism == "Carbohydrate metabolism",]

#count the number of protein folding AMGs/fam

AMGs.filtered.joined.iphop.families.carb <- AMGs.filtered.joined.iphop.carb %>% 
  group_by(Family) %>% 
  summarize(n_AMGs = n_distinct(protein))



joined.carb <- left_join(sum_per_fam, AMGs.filtered.joined.iphop.families.carb, by= "Family")

#calculate per bp 
joined.carb$AMG.per.bp <- joined.carb$n_AMGs/joined.carb$sum_length


#filter for just the PHFs that H
joined.carb$n_AMGs <- ifelse(is.na(joined.carb$n_AMGs), 0, joined.carb$n_AMGs)

joined.carb$AMG.per.bp <- ifelse(is.na(joined.carb$AMG.per.bp), 0, joined.carb$AMG.per.bp)

joined.carb$AMG.per.1000kbp <- (joined.carb$n_AMGs/joined.carb$sum_length)*1000000                                         
joined.carb





#filter for the PHFs that have more than 10 contigs with AMGs 

AMGs.filtered.joined.iphop.grouped.family.joined.10 <- AMGs.filtered.joined.iphop.grouped.family.joined[AMGs.filtered.joined.iphop.grouped.family.joined$n_contigs_total >10,]

contigs.10.amgs <- AMGs.filtered.joined.iphop.grouped.family.joined.10$Family

joined.carb$Family <- gsub("f__", "", joined.carb$Family )
contigs.10.amgs

joined.carb.filtered <- joined.carb %>% 
  filter(Family %in% contigs.10.amgs)


#now plot 

ggplot(joined.carb.filtered, aes(x = reorder(Family,-AMG.per.1000kbp
) , y = AMG.per.1000kbp
)) +
    geom_bar(stat = "identity") +  
    labs(x = "PHF", y = "AMGs per Mb", 
         title = "Carbohydrate Metabolism") +
    theme_minimal() + 
        theme(axis.text.x = element_text(size = 8,angle = 45, hjust = 1, face="italic")) 














length(unique(AMGs.filtered.joined$contigname)) 
# For our PHF AMG analyses, we first only included vOTUS with a family identification #3,370 contigs

#of these, 1,089 contain at least one AMG 
unique(AMGs.filtered.joined$contigname)
1089/3370*100




# Get the unique contignames
unique_contigs <- unique(AMGs.filtered.joined$contigname)

# Find the number of contignames containing "fragment"
fragment_count <- sum(grepl("fragment", unique_contigs))

# Calculate the proportion
fragment_proportion <- fragment_count / length(unique_contigs)
fragment_proportion*100








```

```{r}


#Sanity Check - see if we get similar trends when we normalize per Mb assembled of ALL PHF contigs, not just of the contigs containing an AMG

#The previous analyses used only the sum of contig lengths containing an AMG as the denominator

#We'll go ahead an use these data for the manuscript - overall, it seems more accurate way of characterizing AMGs/mb




length(unique(df_hmp_virome_merged.2.not.na$contigname))

names_with_family <- df_hmp_virome_merged.2.not.na$contigname

filter_checkv <- checkV_virome %>%
  filter(contigname %in% names_with_family)

legnth_contig <- left_join(filter_checkv,hmp2_vir_iphop, by= "contigname")




                                 
#now get the sum per family       
sum_per_fam2 <- legnth_contig %>% 
  group_by(Family) %>%  
  summarize(sum_length=sum(contig_length))





#now plot 

ggplot(joined.pf.filtered, aes(x = reorder(Family,-AMG.per.1000kbp
) , y = AMG.per.1000kbp
)) +
    geom_bar(stat = "identity") +  
    labs(x = "PHF", y = "AMGs per Mb", 
         title = "Protein Folding, Sorting and Degradation") +
    theme_minimal() + 
        theme(axis.text.x = element_text(size = 8,angle = 45, hjust = 1, face="italic")) 






#filter for just protein folding ones
AMGs.filtered.joined.iphop$Metabolism <- gsub('"', "", AMGs.filtered.joined.iphop$Metabolism)
AMGs.filtered.joined.iphop.pf <- AMGs.filtered.joined.iphop[AMGs.filtered.joined.iphop$Metabolism == "Folding, sorting and degradation",]

#count the number of protein folding AMGs/fam

AMGs.filtered.joined.iphop.families.pf <- AMGs.filtered.joined.iphop.pf %>% 
  group_by(Family) %>% 
  summarize(n_AMGs = n_distinct(protein))



joined.pf2 <- left_join(sum_per_fam2, AMGs.filtered.joined.iphop.families.pf, by= "Family")



#calculate per bp 
joined.pf2$AMG.per.bp <- joined.pf2$n_AMGs/joined.pf2$sum_length


#filter for just the PHFs that H
joined.pf2$n_AMGs <- ifelse(is.na(joined.pf2$n_AMGs), 0, joined.pf2$n_AMGs)

joined.pf2$AMG.per.bp <- ifelse(is.na(joined.pf2$AMG.per.bp), 0, joined.pf2$AMG.per.bp)

joined.pf2$AMG.per.1000kbp <- (joined.pf2$n_AMGs/joined.pf2$sum_length)*1000000                                         
joined.pf2



#filter for the PHFs that have more than 10 contigs with AMGs 

AMGs.filtered.joined.iphop.grouped.family.joined.10 <- AMGs.filtered.joined.iphop.grouped.family.joined[AMGs.filtered.joined.iphop.grouped.family.joined$n_contigs_total >10,]

contigs.10.amgs <- AMGs.filtered.joined.iphop.grouped.family.joined.10$Family

joined.pf2$Family <- gsub("f__", "", joined.pf2$Family )
contigs.10.amgs


joined.pf2.filtered <- joined.pf2 %>% 
  filter(Family %in% contigs.10.amgs)


#now plot 

ggplot(joined.pf2.filtered, aes(x = reorder(Family,-AMG.per.1000kbp
) , y = AMG.per.1000kbp
)) +
    geom_bar(stat = "identity") +  
    labs(x = "PHF", y = "AMGs per Mb", 
         title = "Protein Folding, Sorting and Degradation") +
    theme_minimal() + 
        theme(axis.text.x = element_text(size = 8,angle = 45, hjust = 1, face="italic")) 





####now do this based on carb metabolism #####

AMGs.filtered.joined.iphop.carb <- AMGs.filtered.joined.iphop[AMGs.filtered.joined.iphop$Metabolism == "Carbohydrate metabolism",]

#count the number of carbAMGs/fam

AMGs.filtered.joined.iphop.families.carb <- AMGs.filtered.joined.iphop.carb %>% 
  group_by(Family) %>% 
  summarize(n_AMGs = n_distinct(protein))



joined.carb2 <- left_join(sum_per_fam2, AMGs.filtered.joined.iphop.families.carb, by= "Family")

#calculate per bp 
joined.carb2$AMG.per.bp <- joined.carb2$n_AMGs/joined.carb2$sum_length







#filter for just the PHFs that have an AMG 
joined.carb2$n_AMGs <- ifelse(is.na(joined.carb2$n_AMGs), 0, joined.carb2$n_AMGs)

joined.carb2$AMG.per.bp <- ifelse(is.na(joined.carb2$AMG.per.bp), 0, joined.carb2$AMG.per.bp)

joined.carb2$AMG.per.1000kbp <- (joined.carb2$n_AMGs/joined.carb2$sum_length)*1000000                                         
joined.carb2





#filter for the PHFs that have more than 10 contigs with AMGs 

AMGs.filtered.joined.iphop.grouped.family.joined.10 <- AMGs.filtered.joined.iphop.grouped.family.joined[AMGs.filtered.joined.iphop.grouped.family.joined$n_contigs_total >10,]

contigs.10.amgs <- AMGs.filtered.joined.iphop.grouped.family.joined.10$Family

joined.carb2$Family <- gsub("f__", "", joined.carb2$Family )
contigs.10.amgs

joined.carb.filtered2 <- joined.carb2 %>% 
  filter(Family %in% contigs.10.amgs)


#now plot 

ggplot(joined.carb.filtered2, aes(x = reorder(Family,-AMG.per.1000kbp
) , y = AMG.per.1000kbp
)) +
    geom_bar(stat = "identity") +  
    labs(x = "PHF", y = "AMGs per Mb", 
         title = "Carbohydrate Metabolism") +
    theme_minimal() + 
        theme(axis.text.x = element_text(size = 8,angle = 45, hjust = 1, face="italic")) 


##Here, instead of Bif with higher AMGs/bp of carbohydrate metabolism, we have Bacteroidaceae with higher enrichment. These tell us slightly different things. If Bif is going to have an AMG, its most likely going to be a carbohydrate metabolism gene, whereas per sequencing content, Bacteoridaceae is more likely to have one.

#Regardless - in general the Enterobacteriaceae observation holds up across both 



####Respond to the number of vOTUs that have an AMG: Temperate vs. virulent 
# For our PHF AMG analyses, we first only included vOTUS with a family identification #3,370 contigs

#of these, 1,089 contain at least one AMG 
unique(AMGs.filtered.joined$contigname)
1089/3370*100




# Get the unique contignames
unique_contigs <- unique(AMGs.filtered.joined$contigname)

# Find the number of contignames containing "fragment"
fragment_count <- sum(grepl("fragment", unique_contigs))
# 374

# Calculate the proportion
fragment_proportion <- fragment_count / length(unique_contigs)
fragment_proportion*100
#374


#Now do this for temperate vs. virulent 
#create prophage column to name everything that has "fragment" in the scaffold column temperate and everything not as virulent 


                                 
#now get the sum per lifestyle (including just the ones with a Family prediction since this is relevant to the PHFanalyses)    

#add a prophage column to the length_contig df
legnth_contig$prophage <- ifelse(grepl("fragment", legnth_contig$contigname, ignore.case = TRUE), "yes", "no")

table(legnth_contig$prophage)

sum_per_fam3 <- legnth_contig %>% 
  group_by(prophage) %>%  
  summarize(sum_length=sum(contig_length))




#count the number AMGs/mb
length(unique(AMGs.filtered.joined$scaffold))
AMGS.grouped.lifestyle <- AMGs.filtered.joined




#add a prophage column to the AMG df 
AMGS.grouped.lifestyle$prophage <- ifelse(grepl("fragment", AMGS.grouped.lifestyle$scaffold, ignore.case = TRUE), "yes", "no")


AMGS.grouped.lifestyle <- AMGS.grouped.lifestyle %>% 
  group_by(prophage) %>% 
  summarize(n_AMGs = n_distinct(protein))


#calculate per bp 
AMGS.grouped.lifestyle2 <- left_join(AMGS.grouped.lifestyle, sum_per_fam3, by= "prophage")


#calculate per bp 
AMGS.grouped.lifestyle2$AMG.per.bp <- AMGS.grouped.lifestyle2$n_AMGs/AMGS.grouped.lifestyle2$sum_length

AMGS.grouped.lifestyle2$AMG.per.mb <- AMGS.grouped.lifestyle2$n_AMGs/AMGS.grouped.lifestyle2$sum_length*1000000   






```




```{r}
#Richness and alpha diversity 


palette_IBD <- c("#77DD77","#FAA0A0","#b19cd9")
palette_dysb <- c("#00cc33","#c23b22")

tax_glom_fam_level <- tax_glom(subset_1500, taxrank="Family", NArm = TRUE) 



rich_diag.phf <- plot_richness(tax_glom_fam_level, x = "diagnosis.x", measures = c("Eveness")) +
  geom_boxplot(width = 0.5, colour = "grey35", outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.5, aes(color = diagnosis.x)) +
  scale_color_manual(values = diagnosis_cols) +
  guides(color = guide_legend(title = "Diagnosis", override.aes = list(size = 5))) +  # Adjust the size value as needed
  theme_bw() +
  xlab("") +
  ylab("Richness") +
  theme(
    axis.text = element_text(size = 14),
    axis.title = element_text(size = 16),
    legend.text = element_text(size = 14),
    legend.title = element_text(size = 16)
  )



#grouping by participant ID

grouped_plot_rich.phf <- rich_diag.phf$data %>%
  group_by(Participant.ID) %>%
  summarise(
    richness = mean(value, na.rm = TRUE),  
    diagnosis.x = (diagnosis.x)  # Assuming it's a categorical column
  )

grouped_plot_rich.phf <-unique(grouped_plot_rich.phf)



ggplot(grouped_plot_rich.phf, aes(x = diagnosis.x, y = richness)) +
 geom_boxplot(width = 0.5, colour = "grey35", outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.5, aes(color = diagnosis.x)) +
  # scale_y_continuous(
   # breaks = log2(1 / 2^(0:13)),
    #labels = function(x) paste0(100 * round(2^x, digits = 5), "%"),
    #limits = c(log2(0.00005), log2(0.5))
#  ) +
   scale_color_manual(values = c("nonIBD" = "#06402B", "CD" = "#ff2d29", "UC" = "#A020F0")) + 
  guides(color = guide_legend(title = "Diagnosis")) +
  theme_bw() + 
  xlab("") +  # Change the X-axis label here
  ylab("Shannon")    +   theme(axis.text = element_text(size = 15),  # Adjust text size of axis labels
        axis.title = element_text(size = 16)) + 
    theme(axis.text = element_text(size = 15),  # Adjust text size of axis labels
        axis.title = element_text(size = 16)) +    theme(legend.text = element_text(size = 15)) +   theme(legend.title = element_text(size = 15))  # Adjust text 

#Significance


grouped_plot_rich.phf$diagnosis.x <- as.factor(grouped_plot_rich.phf$diagnosis.x)

# Perform Kruskal-Wallis test
kruskal_result_rich.phf <- kruskal.test(richness ~ diagnosis.x, data = grouped_plot_rich)




library(dunn.test)
  # Perform Dunn's test
  dunn_result_rich.phf <- dunn.test(grouped_plot_rich.phf$richness, g = grouped_plot_rich.phf$diagnosis.x, method = "bonferroni")
  
  

```



```{r}


tax_glom_fam_level <- tax_glom(subset_1500, taxrank="Family", NArm = TRUE) 



rich_dysb.phf <- plot_richness(tax_glom_fam_level, x = "dysbiosis_binary", measures = c("Observed")) +
  geom_boxplot(width = 0.5, colour = "grey35", outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.5, aes(color = diagnosis.x)) +
  scale_color_manual(values = diagnosis_cols) +
  guides(color = guide_legend(title = "Dysbiosis Status", override.aes = list(size = 5))) +  # Adjust the size value as needed
  theme_bw() +
  xlab("") +
  ylab("Richness") +
  theme(
    axis.text = element_text(size = 14),
    axis.title = element_text(size = 16),
    legend.text = element_text(size = 14),
    legend.title = element_text(size = 16)
  )



#grouping by participant ID

grouped_plot_rich.phf.dysb <- rich_dysb.phf$data %>%
  group_by(Participant.ID) %>%
  summarise(
    richness = mean(value, na.rm = TRUE),  
    dysbiosis_binary = (dysbiosis_binary)  # Assuming it's a categorical column
  )

grouped_plot_rich.phf.dysb <-unique(grouped_plot_rich.phf.dysb)



ggplot(grouped_plot_rich.phf.dysb, aes(x = dysbiosis_binary, y = richness)) +
 geom_boxplot(width = 0.5, colour = "grey35", outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.5, aes(color = dysbiosis_binary)) +
  # scale_y_continuous(
   # breaks = log2(1 / 2^(0:13)),
    #labels = function(x) paste0(100 * round(2^x, digits = 5), "%"),
    #limits = c(log2(0.00005), log2(0.5))
#  ) +
   scale_color_manual(values = c("No" = "#AF9117", "Yes" = "#06402B")) + 
  guides(color = guide_legend(title = "Diagnosis")) +
  theme_bw() + 
  xlab("") +  # Change the X-axis label here
  ylab("Richness")    +   theme(axis.text = element_text(size = 15),  # Adjust text size of axis labels
        axis.title = element_text(size = 16)) + 
    theme(axis.text = element_text(size = 15),  # Adjust text size of axis labels
        axis.title = element_text(size = 16)) +    theme(legend.text = element_text(size = 15)) +   theme(legend.title = element_text(size = 15))  # Adjust text 

#Significance


grouped_plot_rich.phf$diagnosis.x <- as.factor(grouped_plot_rich.phf$diagnosis.x)

# Perform Kruskal-Wallis test
kruskal_result_rich.phf <- kruskal.test(richness ~ diagnosis.x, data = grouped_plot_rich)




library(dunn.test)
  # Perform Dunn's test
  dunn_result_rich.phf <- dunn.test(grouped_plot_rich.phf$richness, g = grouped_plot_rich.phf$diagnosis.x, method = "bonferroni")

  
  
  
  

rich_dysb.phf.shan <- plot_richness(tax_glom_fam_level, x = "dysbiosis_binary", measures = c("Shannon")) +
  geom_boxplot(width = 0.5, colour = "grey35", outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.5, aes(color = diagnosis.x)) +
  scale_color_manual(values = diagnosis_cols) +
  guides(color = guide_legend(title = "Dysbiosis Status", override.aes = list(size = 5))) +  # Adjust the size value as needed
  theme_bw() +
  xlab("") +
  ylab("Richness") +
  theme(
    axis.text = element_text(size = 14),
    axis.title = element_text(size = 16),
    legend.text = element_text(size = 14),
    legend.title = element_text(size = 16)
  )



#grouping by participant ID

grouped_plot_shan.phf.dysb <- rich_dysb.phf.shan$data %>%
  group_by(Participant.ID) %>%
  summarise(
    richness = mean(value, na.rm = TRUE),  
    dysbiosis_binary = (dysbiosis_binary)  # Assuming it's a categorical column
  )

grouped_plot_shan.phf.dysb <-unique(grouped_plot_shan.phf.dysb)



ggplot(grouped_plot_shan.phf.dysb, aes(x = dysbiosis_binary, y = richness)) +
 geom_boxplot(width = 0.5, colour = "grey35", outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.5, aes(color = dysbiosis_binary)) +
  # scale_y_continuous(
   # breaks = log2(1 / 2^(0:13)),
    #labels = function(x) paste0(100 * round(2^x, digits = 5), "%"),
    #limits = c(log2(0.00005), log2(0.5))
#  ) +
   scale_color_manual(values = c("No" = "#AF9117", "Yes" = "#06402B")) + 
    annotate("segment", x = 1, xend = 2, y = 2.3, yend = 2.3, 
           linetype = "solid", color = "black", size = 1) +
     annotate("text", x = 1.5, y = 2.4, label = "****", size = 7, color = "black") +  
  guides(color = guide_legend(title = "Dysbiosis Status")) +
  theme_bw() + 
  xlab("") +  # Change the X-axis label here
  ylab("Shannon")    +   theme(axis.text = element_text(size = 15),  # Adjust text size of axis labels
        axis.title = element_text(size = 16)) + 
    theme(axis.text = element_text(size = 15),  # Adjust text size of axis labels
        axis.title = element_text(size = 16)) +    theme(legend.text = element_text(size = 15)) +   theme(legend.title = element_text(size = 15))  # Adjust text 

#Significance


grouped_plot_shan.phf.dysb$dysbiosis_binary <- as.factor(grouped_plot_shan.phf.dysb$dysbiosis_binary)

# Perform Kruskal-Wallis test
kruskal_result_rich.phf.dysb <- kruskal.test(richness ~ dysbiosis_binary, data = grouped_plot_shan.phf.dysb)




library(dunn.test)
  # Perform Dunn's test
  dunn_result_shan.phf <- dunn.test(grouped_plot_shan.phf.dysb$richness, g = grouped_plot_shan.phf.dysb$dysbiosis_binary, method = "bonferroni")

  
  
  
  
  
plot_richness(tax_glom_fam_level, x="dysbiosis", measures=c("Observed")) + 
  geom_smooth(method = "lm", se = TRUE) + 
   labs(x = "Dysbiosis Score", y = "PHF Richness") + 
  theme_bw()  + 
    theme(axis.text = element_text(size = 12),  # Adjust text size of axis labels
        axis.title = element_text(size = 16)) +    theme(legend.text = element_text(size = 12)) +   theme(legend.title = element_text(size = 13))  # Adjust text size of legend title
  
  
library(lmer)

rich_dysb.phf.cont <- plot_richness(tax_glom_fam_level, x = "dysbiosis", measures = c("Observed")) 
rich_dysb.phf.cont$data

lmer_richness.dysb <-  lmer(value ~ dysbiosis  + (1|Participant.ID), data = (rich_dysb.phf.cont$data))
      
summary(lmer_richness.dysb)
anova(lmer_richness.dysb)
# Change the Y-a

```


```{r}

palette_IBD <- c("#77DD77","#FAA0A0","#b19cd9")
palette_dysb <- c("#00cc33","#c23b22")

tax_glom_fam_level <- tax_glom(subset_1500, taxrank="Family", NArm = TRUE) 



shan_diag.phf <- plot_richness(tax_glom_fam_level, x = "diagnosis.x", measures = c("Shannon")) +
  geom_boxplot(width = 0.5, colour = "grey35", outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.5, aes(color = diagnosis.x)) +
  scale_color_manual(values = diagnosis_cols) +
  guides(color = guide_legend(title = "Diagnosis", override.aes = list(size = 5))) +  # Adjust the size value as needed
  theme_bw() +
  xlab("") +
  ylab("Richness") +
  theme(
    axis.text = element_text(size = 14),
    axis.title = element_text(size = 16),
    legend.text = element_text(size = 14),
    legend.title = element_text(size = 16)
  )



#grouping by participant ID

grouped_plot_shan.phf <- shan_diag.phf$data %>%
  group_by(Participant.ID) %>%
  summarise(
    richness = mean(value, na.rm = TRUE),  
    diagnosis.x = (diagnosis.x)  # Assuming it's a categorical column
  )

grouped_plot_shan.phf <-unique(grouped_plot_shan.phf)



ggplot(grouped_plot_shan.phf, aes(x = diagnosis.x, y = richness)) +
 geom_boxplot(width = 0.5, colour = "grey35", outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.5, aes(color = diagnosis.x)) +
  # scale_y_continuous(
   # breaks = log2(1 / 2^(0:13)),
    #labels = function(x) paste0(100 * round(2^x, digits = 5), "%"),
    #limits = c(log2(0.00005), log2(0.5))
#  ) +
   scale_color_manual(values = c("nonIBD" = "#06402B", "CD" = "#ff2d29", "UC" = "#A020F0")) + 
  guides(color = guide_legend(title = "Diagnosis")) +
  annotate("segment", x = 1, xend = 2, y = 2.3, yend = 2.3, 
           linetype = "solid", color = "black", size = 1) +
     annotate("text", x = 1.5, y = 2.4, label = "**", size = 7, color = "black") +  
   annotate("segment", x = 1, xend = 3.2, y = 2.6, yend = 2.6, 
           linetype = "solid", color = "black", size = 1) +
     annotate("text", x = 2, y = 2.7, label = "p=0.079", size = 4.5, color = "black") +  
  theme_bw() + 
  xlab("") +  # Change the X-axis label here
  ylab("Shannon")    +   theme(axis.text = element_text(size = 15),  # Adjust text size of axis labels
        axis.title = element_text(size = 16)) + 
    theme(axis.text = element_text(size = 15),  # Adjust text size of axis labels
        axis.title = element_text(size = 16)) +    theme(legend.text = element_text(size = 15)) +   theme(legend.title = element_text(size = 15))  # Adjust text 

#Significance


grouped_plot_shan.phf$diagnosis.x <- as.factor(grouped_plot_shan.phf$diagnosis.x)

# Perform Kruskal-Wallis test
 grouped_plot_shan.phf.krus <- kruskal.test(richness ~ diagnosis.x, data = grouped_plot_shan.phf)




library(dunn.test)
  # Perform Dunn's test
  dunn_result_shan.phf <- dunn.test(grouped_plot_shan.phf$richness, g = grouped_plot_shan.phf$diagnosis.x, method = "bonferroni")
  
  

```





```{r}
####FIGURES### 1A = PBF vs. vOTU  PREVALENCE DISTRIBUTION 
#1B = Relative Abundance of those Prevalent CONTIGS
#1C = Bray-Distance in PHF vs. vOTU - intra vs. inter 


library(cowplot)

one_A <- ggplot(df_hmp_virome_votu_prevalence, aes(x = rank_prev_ind, y = prevalence_ind)) +
    geom_point(size = 0.1) +  
    geom_jitter() + 
    labs(x = "Rank", y = "vOTU Prevalence", 
         title = "vOTU Prevalence") +
    annotate("segment", x = 233, xend = 233, y = 0, yend = 1, 
           linetype = "dashed", color = "red", size = 1) +
    theme_minimal() +
    theme(axis.text.x = element_blank()) + # Removes species labels
    theme(plot.title = element_text(size = 12))





one_B <- ggplot(df_hmp_virome_pbf_prevalence, aes(x = rank_prev_ind, y = prevalence_ind)) +
    geom_point(size = 0.1) + 
    geom_jitter() +
    labs(x = "Rank", y = "PHF Prevalence", 
         title = "PHF Prevalence") +
    annotate("segment", x = 18.5, xend = 18.5, y = 0, yend = 1, 
           linetype = "dashed", color = "red", size = 1) +
    theme_minimal() +
    theme(axis.text.x = element_blank()) +   # Removes species label   # Adjusts plot title size
    theme(plot.title = element_text(size = 12))



#This figure shows the cumulative relative abundance of prevalent features of Individuals (not samples )
colors <- c( "#a0d6b4", "#C3B1E1")
one_c <-  merged.prev.df  %>% 
  ggplot(aes(x = metric, y = sample_abundance, fill = metric)) +
  geom_violin(scale = "width", aes(fill=metric), alpha = 0.3, position = position_dodge(width = 0.9)) +
  geom_boxplot(outlier.shape = NA, width = 0.3, aes(fill=metric), color="black", position = position_dodge(width = 0.9)) +
  annotate("segment", x = 1, xend = 2, y = 1.09, yend = 1.09, 
          linetype = "solid", color = "black", size = 1) +
  annotate("text", x = 1.5, y = 1.13, label = "****", size = 4.5, color = "black") +  

  scale_fill_viridis(discrete = TRUE, begin = 0.7, end = 0.1, labels = labels) +  # Swap begin and end
  scale_colour_viridis(discrete = TRUE, begin = 0.7, end = 0.1, labels = labels) +
  
  scale_fill_manual(values = colors, labels = c("PHF", "vOTU")) +  # Ensure manual colors match
  scale_color_manual(values = colors, labels = c("PHF", "vOTU")) +  

  labs(x = "", y = "Relative Abundance") +
  labs(fill = "Distance metric") + 
  scale_x_discrete(labels = c("PHF", "vOTU")) +
  scale_y_continuous(limits = c(0, 1.2)) +   
  theme_bw() + ggtitle("Prevalent Features") + 
      theme(plot.title = element_text(size = 12))




colors <- c("#C3B1E1", "#a0d6b4")
one_d <- bray_distance_df  %>% 
  ggplot(aes(x = same.subject, y = value, fill = metric)) +
 geom_violin(scale = "width", aes(fill=metric), alpha = 0.3, position = position_dodge(width = 0.9)) +
  geom_boxplot(outlier.shape = NA, width = 0.3, aes(fill=metric), color="black", position = position_dodge(width = 0.9)) +
    annotate("segment", x = 0.75, xend = 1.25, y = 1.09, yend = 1.09, 
           linetype = "solid", color = "black", size = 1) +
     annotate("text", x = 1, y = 1.15, label = "****", size = 4.5, color = "black") +  

       annotate("segment", x = 1.75, xend = 2.25, y = 1.03, yend = 1.03, 
           linetype = "solid", color = "black", size = 1) +
     annotate("text", x = 2, y = 1.05, label = "****", size = 4.5, color = "black") +  

  scale_fill_viridis(discrete = T, begin = 0.1, end = 0.7, labels = labels) +
  scale_colour_viridis(discrete = T, begin = 0.1, end = 0.7, labels = labels) +
  scale_fill_manual(values = colors, labels = c("vOTU", "PHF")) +  
  scale_color_manual(values = colors, labels = c("vOTU", "PHF")) +  
 # geom_jitter(alpha = 0.05) +
  #scale_fill_brewer(palette = "Set1") + 
  #facet_wrap(. ~ same.subject, labeller = label_parsed) + 
   scale_fill_manual(values = colors) +  
  scale_color_manual(values = colors) +  
      scale_y_continuous(limits = c(0, 1.24)) +   # Set y-axis limit here
    scale_fill_manual(values = colors, labels = c("vOTU", "PHF")) +  # Ensure manual colors match
  scale_color_manual(values = colors, labels = c("vOTU", "PHF")) +  
   labs(x = "", y = "Bray Distance") +
   labs(fill = "Distance metric") + 
   scale_x_discrete(labels = c("Inter-individual", "Intra-individual")) +
  theme_bw() + ggtitle("Between Sample Distance") + 
  
  # Rotate x-axis labels
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
      theme(plot.title = element_text(size = 12)) +
   theme(legend.position = "none")



  

fig_one  <- plot_grid(one_A,one_B, one_c, one_d, rel_heights = c(1,1.4),labels = c("A", "B", "C", "D")) #combine the plots into one plotting space
fig_one



ggsave(filename = "/Users/anshulsinha/Desktop/PBF_manuscript/figure3.pdf", plot = fig_one, width = 10, height = 8, dpi = 800)




```

```{r}
#Fig 2 

###Bray_Dysbiosis 
fig2A1 <- PCoA_vOTU.Bray.Dysbiosis + ggtitle("vOTU") + theme_bw() + 
  labs(color = "Dysbiosis Status",x = "PCoA Axis 1 (7.1%)", y = "PCoA Axis 2 (3.9%)") + # Modify axis names) + 
 scale_color_manual(values = c("No" = "#AF9117", "Yes" = "#06402B"), # Adjust color labels
                     labels = c("No" = "Non-Dysbiotic", "Yes" = "Dysbiotic")) + 
    theme(legend.title = element_text(size = 14),   # Increase legend title size
        legend.text = element_text(size = 12), plot.title = element_text(size = 18))  

 fig2A2 <- PCoA_PBF.Bray.Dysbiosis  + ggtitle("PHF") + theme_bw() + 
  labs(color = "Dysbiosis Status",x = "PCoA Axis 1 (30.6%)", y = "PCoA Axis 2 (8.7%)") + # Modify axis names) + 
 scale_color_manual(values = c("No" = "#AF9117", "Yes" = "#06402B"), # Adjust color labels
                     labels = c("No" = "Non-Dysbiotic", "Yes" = "Dysbiotic")) + 
    theme(legend.title = element_text(size = 14),   # Increase legend title size
        legend.text = element_text(size = 12), plot.title = element_text(size = 18)) + 
    theme(legend.position = "none")



 
fig2B <- EV_col_con 
fig2B
 
#fig2C <- deseq.lfc.plot +   labs(y = "PHF") +   theme( 
       # axis.title.x = element_text(size = 14),  # Increase x-axis label size
        #axis.title.y = element_text(size = 14))   

#fig2C + labs(x = expression(Log[2]~"Fold-Change")) 



 
fig2.top <- plot_grid(fig2A1, fig2A2,rel_widths = c(1.5,1), rel_heights = c(1,1),labels = c("A", ""), label_size = 18)
fig2.bottom <- plot_grid(fig2B, rel_widths = c(1.24,1), rel_heights = c(1,1),labels = c("B"), label_size = 18)
comb2 <- plot_grid(fig2.top,fig2.bottom, ncol = 1)


ggsave(filename = "/Users/anshulsinha/Desktop/PBF_manuscript/figure4.png", plot = comb2, width = 10, height = 8, dpi = 300)





```





```{r}
```


```{r}
#Supplementary Figure 1 - Contigs Per PBF

# Select the first 5 rows based on the reordered Family
top_5_families <- df_hmp_iphop_all.analyses.2.grouped %>%
    arrange(desc(contig_count)) %>%
    slice_head(n = 5)




# Remove the 'f__' prefix from the Family column
df_hmp_iphop_all.analyses.2.grouped$Family_clean <- gsub("^f__", "", df_hmp_iphop_all.analyses.2.grouped$Family)

# Update the color_group labels to display only numeric values in the legend
df_hmp_iphop_all.analyses.2.grouped$color_group <- cut(
  df_hmp_iphop_all.analyses.2.grouped$contig_count,
  breaks = c(-Inf, 1, 10, 50, 100, Inf),
  labels = c("1 black", "2-10 dark green", "11-50 gold", "51-100 red", ">100 purple"),
  right = TRUE
)

# Update the plot
sup_fig1 <- ggplot(df_hmp_iphop_all.analyses.2.grouped, 
                   aes(x = reorder(Family_clean, -contig_count), y = contig_count)) +
  geom_point(aes(color = color_group), size = 2) +  
  scale_color_manual(
    values = c(">100 purple" = "purple", 
               "51-100 red" = "red", 
               "11-50 gold" = "gold", 
               "2-10 dark green" = "darkgreen", 
               "1 black" = "black"),
    name = "vOTU Count",
    breaks = c(">100 purple", "51-100 red", "11-50 gold", "2-10 dark green", "1 black"),
    labels = function(labels) gsub(" .*", "", labels)  # Keep only the numeric part
  ) +  
  labs(x = "PHF", y = "vOTUs per PHF", 
       title = "vOTUs per PHF") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8),  # Rotate text, adjust position, and decrease font size
    axis.text.y = element_text(size = 10),  # Adjust y-axis text size
    axis.title = element_text(size = 12),  # Adjust axis title size
    plot.title = element_text(size = 14, face = "bold"),  # Adjust title size and style
    legend.position = "top",  # Position the legend at the top
    legend.justification = "right"  # Align legend to the top-right corner
  )

# Display the plot
sup_fig1




# Arrange dataframe in descending order of the 'Score' column
df_hmp_iphop_all.analyses.2.grouped3 <- df_hmp_iphop_all.analyses.2.grouped %>%
  arrange(desc(contig_count))


ggsave(filename = "/Users/anshulsinha/Desktop/PBF_manuscript/sup_fig1.png", plot = sup_fig1, width = 10, height = 8, dpi = 800)




```


```{r}
#Supplementary Figure 3 - Contigs Per PBF


sup3_1 <- PCoA_vOTU.Bray.Diagnosis + ggtitle("vOTU") + theme_bw() + 
  labs(color = "Diagnosis",x = "PCoA Axis 1 (7.1%)", y = "PCoA Axis 2 (3.9%)") + # Modify axis names) + 
 scale_color_manual(values = c("nonIBD" = "#06402B", "CD" = "#ff2d29", "UC" = "#A020F0"), # Adjust color labels
                     labels = c("nonIBD" = "Non-IBD", "CD" = "CD", "UC" = "UC")) + 
    theme(legend.title = element_text(size = 14),   # Increase legend title size
        legend.text = element_text(size = 12)) 


 fig3A2 <- PCoA_PBF.Bray.Diagnosis  + ggtitle("PHF") + theme_bw() + 
  labs(color = "Dysbiosis Status",x = "PCoA Axis 1 (30.6%)", y = "PCoA Axis 2 (8.7%)") + # Modify axis names) + 
 scale_color_manual(values = c("nonIBD" = "#06402B", "CD" = "#ff2d29", "UC" = "#A020F0"), # Adjust color labels
                     labels = c("nonIBD" = "Non-IBD", "CD" = "CD", "UC" = "UC")) + 
    theme(legend.title = element_text(size = 14),   # Increase legend title size
        legend.text = element_text(size = 12)) + 
    theme(legend.position = "none")


 sup_fig3 <- plot_grid(sup3_1, fig3A2,rel_widths = c(1.5,1))
                       



```


```{r}
#Supplementary Figure 2# changed now with new SFig.2B, SFig.2C


####AMG Figure #####
colors <- viridis(10)
AMGs.filtered.joined.iphop.grouped.family.joined <-  AMGs.filtered.joined.iphop.grouped.family.joined[!is.na(AMGs.filtered.joined.iphop.grouped.family.joined$Metabolism),]

AMGs.filtered.joined.iphop.grouped.family.joined$Metabolism <- gsub('"', '', AMGs.filtered.joined.iphop.grouped.family.joined$Metabolism)

AMGs.filtered.joined.iphop.grouped.family.joined$Metabolism <- gsub('"', '', AMGs.filtered.joined.iphop.grouped.family.joined$Metabolism)



figS2A <- ggplot(AMGs.filtered.joined.iphop.grouped.family.joined, aes(x = Family, y = count, fill = Metabolism)) +
  geom_bar(stat = "identity", position = "fill") +
  scale_y_continuous(labels = scales::percent_format()) +
    scale_fill_manual(values = brewer.pal(12, "Set3")) +
  labs(y = "Relative Proportion", x = "PHF", fill = "KEGG Metabolism Category") +
  theme_minimal() + 
    theme(axis.text.x = element_text(size = 8,angle = 45, hjust = 1, face="italic")) + 
  
  theme(
    legend.key.size = unit(0.2, "cm"),  # Key size
    legend.text = element_text(size = 9)  # Text size
  ) + 
  theme(legend.title = element_text(size = 12, hjust = 0.5))








figS2B <- ggplot(joined.carb.filtered2, aes(x = reorder(Family,-AMG.per.1000kbp
) , y = AMG.per.1000kbp
)) +
    geom_bar(stat = "identity") +  
    labs(x = "PHF", y = "AMGs per Mb", 
         title = "Carbohydrate Metabolism Genes") +
    theme_minimal() + 
        theme(axis.text.x = element_text(size = 6,angle = 45, hjust = 1, face="italic")) +
    theme(plot.title = element_text(size = 11))  # Adjust the size as needed


figS2C <- ggplot(joined.pf2.filtered, aes(x = reorder(Family,-AMG.per.1000kbp
) , y = AMG.per.1000kbp
)) +
    geom_bar(stat = "identity") +  
    labs(x = "PHF", y = "AMGs per Mb", 
         title = "Folding, Sorting and Degradation Genes") +
    theme_minimal() + 
        theme(axis.text.x = element_text(size = 8,angle = 45, hjust = 1, face="italic")) +
    theme(plot.title = element_text(size = 11))  # Adjust the size as needed




AMGs.filtered.joined.iphop.families.cyso$Family <- gsub('f__', '', AMGs.filtered.joined.iphop.families.cyso$Family)

figS2D <- ggplot(AMGs.filtered.joined.iphop.families.cyso, aes(x = reorder(Family,-n_AMGs
) , y = n_AMGs
)) +
    geom_bar(stat = "identity") +  
    labs(x = "PHF", y = "vOTUs carrying AMG", 
         title = "cysO") +
    theme_minimal() + 
        theme(axis.text.x = element_text(size = 8,angle = 45, hjust = 1, face="italic")) +
                theme(plot.title = element_text(face = "italic")) + 
  theme(plot.title = element_text(size = 11))




topS2 <-plot_grid(figS2A,  labels = c("A"), label_size = 18) 



botS2.1 <- plot_grid(figS2B, figS2C, figS2D,labels = c("B", "C", "D"), label_size = 18, nrow  = 1)




combS2.2 <- plot_grid(topS2, botS2.1, nrow = 2)




ggsave(filename = "/Users/anshulsinha/Desktop/PBF_manuscript/supplementary_figure_2.pdf", plot = combS2.2, width = 10, height = 8, dpi = 800)





```

```{r}
####COMPARING TEMPERATE VS. VIRULENT 
#do similar but for temp and virulent viromes 
physeqhmp2vir
physeqhmp2tempvir



#subsetting for 1500 reads (total - not for just temperate virome - I may want to change this )
subset_1500.temp <-  subset_samples(physeqhmp2tempvir, length_normalized_read_count > 1500)
subset_1500.vir <-  subset_samples(physeqhmp2vir, length_normalized_read_count > 1500)



2176/3862*100

rarefied.reads.1500.temp <-  rarefy_even_depth(subset_1500.temp, sample.size = min(sample_sums(subset_1500.temp)),
  rngseed = 1, replace = TRUE, trimOTUs = TRUE, verbose = TRUE)


rarefied.reads.1500.vir <-  rarefy_even_depth(subset_1500.vir, sample.size = min(sample_sums(subset_1500.vir)),
  rngseed = 1, replace = TRUE, trimOTUs = TRUE, verbose = TRUE)





vOTU_perm(rarefied.reads.1500.temp, "bray", "dysbiosis_binary")
PBF_perm(rarefied.reads.1500.temp, "bray", "dysbiosis_binary")



PCoA_vOTU.Bray.Diagnosis.temp <-   PCoA_vOTU(rarefied.reads.1500.temp, "bray", "diagnosis.x")
PCoA_vOTU.Bray.Dysbiosis.temp <-   PCoA_vOTU(rarefied.reads.1500.temp, "bray", "dysbiosis_binary")


#PBF - Bray - Using rarefied DF 
PCoA_PBF.Bray.Diagnosis.temp <-   PCoA_PBF(rarefied.reads.1500.temp, "bray", "diagnosis.x")
PCoA_PBF.Bray.Dysbiosis.temp <-   PCoA_PBF(rarefied.reads.1500.temp, "bray", "dysbiosis_binary")




vOTU_perm(rarefied.reads.1500.vir, "bray", "dysbiosis_binary")
PBF_perm(rarefied.reads.1500.vir, "bray", "dysbiosis_binary")



PCoA_vOTU.Bray.Diagnosis.vir <-   PCoA_vOTU(rarefied.reads.1500.vir, "bray", "diagnosis.x")
PCoA_vOTU.Bray.Dysbiosis.vir <-   PCoA_vOTU(rarefied.reads.1500.vir, "bray", "dysbiosis_binary")


#PBF - Bray - Using rarefied DF 
PCoA_PBF.Bray.Diagnosis.vir <-   PCoA_PBF(rarefied.reads.1500.vir, "bray", "diagnosis.x")
PCoA_PBF.Bray.Dysbiosis.vir <-   PCoA_PBF(rarefied.reads.1500.vir, "bray", "dysbiosis_binary")


```

```{r}
#PBF - Bray - Using rarefied DF 
PCoA_PBF.Bray.Diagnosis.temp <-   PCoA_PBF(rarefied.reads.1500.temp, "bray", "diagnosis.x") +  ggtitle("Temperate Virome")+ theme_bw() + 
  labs(color = "Diagnosis",x = "PCoA Axis 1 (32.4%)", y = "PCoA Axis 2 (9.5%)") + # Modify axis names) + 
 scale_color_manual(values = c("nonIBD" = "#06402B", "CD" = "#ff2d29", "UC" = "#A020F0"), # Adjust color labels
                     labels = c("nonIBD" = "Non-IBD", "CD" = "CD", "UC" = "UC")) + 
  theme(
    plot.title = element_text(size = 16, face = "bold"), # Increase title size
    legend.title = element_text(size = 14),             # Customize legend title size
    legend.text = element_text(size = 12)              # Customize legend text size
  )

57 + 31 + 27


PCoA_PBF.Bray.Diagnosis.vir <-   PCoA_PBF(rarefied.reads.1500.vir, "bray", "diagnosis.x") +  ggtitle("Virulent Virome")+ theme_bw() + 
  labs(color = "Diagnosis",x = "PCoA Axis 1 (23.0%)", y = "PCoA Axis 2 (13.6%)") + # Modify axis names) + 
 scale_color_manual(values = c("nonIBD" = "#06402B", "CD" = "#ff2d29", "UC" = "#A020F0"), # Adjust color labels
                     labels = c("nonIBD" = "Non-IBD", "CD" = "CD", "UC" = "UC"))  + 
    theme(
    plot.title = element_text(size = 16, face = "bold"), # Increase title size
    legend.title = element_text(size = 14),             # Customize legend title size
    legend.text = element_text(size = 12)              # Customize legend text size
  )






PCoA_PBF.Bray.Dysbiosis.temp <-   PCoA_PBF(rarefied.reads.1500.temp, "bray", "dysbiosis_binary") + ggtitle("Temperate Virome") + theme_bw() + 
  labs(color = "Dysbiosis Status",x = "PCoA Axis 1 (32.4%)", y = "PCoA Axis 2 (9.5%)") + # Modify axis names) + 
 scale_color_manual(values = c("No" = "#AF9117", "Yes" = "#06402B"), # Adjust color labels
                     labels = c("No" = "Non-Dysbiotic", "Yes" = "Dysbiotic")) + 
    theme(legend.title = element_text(size = 14),   # Increase legend title size
        legend.text = element_text(size = 12), plot.title = element_text(size = 18)) + 
    theme(
    plot.title = element_text(size = 16, face = "bold"), # Increase title size
    legend.title = element_text(size = 14),             # Customize legend title size
    legend.text = element_text(size = 12)              # Customize legend text size
  )






PCoA_PBF.Bray.Dysbiosis.vir <-   PCoA_PBF(rarefied.reads.1500.vir, "bray", "dysbiosis_binary") + ggtitle("Virulent Virome") + theme_bw() + 
  labs(color = "Dysbiosis Status",x = "PCoA Axis 1 (23.0%)", y = "PCoA Axis 2 (13.6%)") + # Modify axis names) + 
 scale_color_manual(values = c("No" = "#AF9117", "Yes" = "#06402B"), # Adjust color labels
                     labels = c("No" = "Non-Dysbiotic", "Yes" = "Dysbiotic")) + 
    theme(legend.title = element_text(size = 14),   # Increase legend title size
        legend.text = element_text(size = 12), plot.title = element_text(size = 18)) + 
    theme(
    plot.title = element_text(size = 16, face = "bold"), # Increase title size
    legend.title = element_text(size = 14),             # Customize legend title size
    legend.text = element_text(size = 12)              # Customize legend text size
  )


PBF_perm(rarefied.reads.1500.vir, "bray", "dysbiosis_binary")
PBF_perm(rarefied.reads.1500.temp, "bray", "dysbiosis_binary")


PBF_perm(rarefied.reads.1500.vir, "bray", "diagnosis.x")
PBF_perm(rarefied.reads.1500.temp, "bray", "diagnosis.x")









```




```{r}

#Comparing virulent vs. temperate part 2 
physeqhmp2wholevir_lifestyle

physeqhmp2wholevir_lifestyle.subset.1500 <-  subset_samples(physeqhmp2wholevir_lifestyle, length_normalized_read_count > 1500)



#relative abundance of temperate vs. virulent 

#for before phyloseq where I calculated the relative abundance of temperate phages 

temp_rel_ab_df

#left join with metadata


joined_temprelab <- left_join(temp_rel_ab_df, metadata_df, by = "filename")



joined_temprelab <- joined_temprelab[!is.na(joined_temprelab$diagnosis.x),]
joined_temprelab <- joined_temprelab[!is.na(joined_temprelab$dysbiosis_binary),]




#relative abundance of temperate phages by diagnosis status 
joined_temprelab %>% 
  ggplot(aes(x=diagnosis.x, y=temp_relab, colour = diagnosis.x)) + 
   scale_color_manual(values = c("nonIBD" = "#06402B", "CD" = "#ff2d29", "UC" = "#A020F0"), # Adjust color labels
                  labels = c("nonIBD" = "Non-IBD", "CD" = "CD", "UC" = "UC")) + 
  geom_jitter() +
  geom_boxplot() + 
  xlab("Diagnosis Status") + 
  ylab("Temperate Phage Relative Abundance")


#same as above but group by individual first 
joined_temprelab.grouped.2 <- joined_temprelab %>%
  group_by(Participant.ID) %>% 
  mutate(mean_temp_relab = mean(temp_relab)) 


joined_temprelab.grouped.1 <- left_join(metadata_df, joined_temprelab.grouped.2, , by = "Participant.ID" )


 joined_temprelab.grouped <- joined_temprelab.grouped.1 %>% 
  group_by(Participant.ID) %>%
  slice_sample(n = 1) 
  

joined_temprelab.grouped %>% 
  ggplot(aes(x=diagnosis.x.x
, y=temp_relab, colour = diagnosis.x.x
)) + 
   scale_color_manual(values = c("nonIBD" = "#06402B", "CD" = "#ff2d29", "UC" = "#A020F0"), # Adjust color labels
                  labels = c("nonIBD" = "Non-IBD", "CD" = "CD", "UC" = "UC")) + 
  geom_jitter() +
  geom_boxplot() + 
  xlab("Diagnosis Status") + 
  ylab("Temperate Phage Relative Abundance")






joined_temprelab %>% 
  ggplot(aes(x=dysbiosis_binary, y=temp_relab, color = dysbiosis_binary)) + 
   scale_color_manual(values = c("No" = "#AF9117", "Yes" = "#06402B")) + # Adjust color labels
  geom_jitter() +
  geom_boxplot() + 
  xlab("Dysbiosis Status") + 
  ylab("Temperate Phage Relative Abundance")



#stats on these 


joined_temprelab.stats.diag <- joined_temprelab %>% 
  group_by(diagnosis.x) %>% 
  summarize(mean = mean(temp_relab), SD = sd(temp_relab)) #CD - 62.5, UC = 63.2, nonIBD = 61.8


joined_temprelab.stats.diag.grouped <- joined_temprelab.grouped %>%
    group_by(diagnosis.x.x) %>% 
  summarize(mean = mean(temp_relab), SD = sd(temp_relab)) #CD - 62.5, UC = 65.5, nonIBD = 64.3

kruskal.test(mean ~ diagnosis.x.x, data = joined_temprelab.stats.diag.grouped)




joined_temprelab.stats.dysb <- joined_temprelab %>% 
  group_by(dysbiosis_binary) %>% 
  summarize(mean = mean(temp_relab)) #no- 0.624 #yes- 0.635







```
```{r}
#RDA 




  redundancy_ps1 <- tax_glom(subset_1500, taxrank="Family", NArm = TRUE) 


  redundancy_ps1_transformed <- redundancy_ps1 %>% 
    tax_transform("clr", rank = "Family") %>%
    ord_calc(method = "RDA", constraints = c("temp_relab"), scale_cc = TRUE)
  names(sample_data(redundancy_ps1))
  
  
  ord_get(redundancy_ps1_transformed)
  
  renamer <- function(x) str_replace(x, pattern = "temp_relab", replacement = "Temperate Phage Relative Abundance")

  
  #RDA - hbi and dysbiosis
  ord_plot(redundancy_ps1_transformed, colour="dysbiosis_binary", var_renamer = renamer,  constraint_vec_style = vec_constraint(1, alpha = 0.5),
    constraint_vec_length = 2, constraint_lab_length = 3.8,
    constraint_lab_style = constraint_lab_style(
      alpha = 2, size = 2.6, max_angle = 0, perpendicular = TRUE))   +  stat_ellipse(aes(linetype = dysbiosis_binary, colour = dysbiosis_binary), linewidth = 0.8, show.legend = FALSE) + scale_color_manual(values = dysbiosis_cols) + theme_bw() + guides(color = guide_legend(title = "Dysbiosis Status")) +  theme(legend.key = element_blank())  +     theme(legend.text = element_text(size = 12)) +   theme(legend.title = element_text(size = 13))  # Adjust text size of legend title




```
```{r}


### DESEQ2 #### FOR DYSBIOTIC SAMPLES 
#PBFFREPs virome here:

#dysbiotic vs. non-dysbiotic 


physeqhmp2whole_vir_i_reads_combfam.1500 <- subset_samples(physeqhmp2whole_vir_i_reads_combfam, length_normalized_read_count > 1500)


#comb = family names appended with bacphlip info  (109 taxa)
  tax_glom_fam_reads_comb <- tax_glom(physeqhmp2whole_vir_i_reads_combfam.1500, taxrank="Family", NArm = TRUE) 


#subset the phyloseq object so it only contains patient IDs that have both a dysbiotic and non-dysbiotic sample


#First, create a list of the samples that you want to remove

#metadata 
phyloseq_metadata <- hmp2_metadata_phylo

#filter for samples that just have a "yes" valuue
yes_ids <- phyloseq_metadata %>% filter(dysbiosis_binary == "Yes") %>% distinct(Participant.ID)
no_ids <- phyloseq_metadata %>% filter(dysbiosis_binary == "No") %>% distinct(Participant.ID)




# Find the common Participant.IDs
common_ids <- intersect(yes_ids$Participant.ID, no_ids$Participant.ID)

length(common_ids)


# Filter the PS object so that we have  both  #Use the ps_object with reads (not length normalized reads)



filtered_ps_pbfrep <- subset_samples(tax_glom_fam_reads_comb 
, Participant.ID %in% common_ids)

#test <- data.frame(sample_data(filtered_ps))




 
####IMPORTANT### Filter out low prevlance PBFs - If I dont do this, DESEQ2 will artifically think that some of the low abdundance taxa are DE 
##Choosing arbitrarily that it must be found in at least 10 % of samples - this is high enough that if it is only found in one individual, it should be below threshold, but if it is found in a few individuals it should still be included 


# Compute prevalence of each feature, store as data.frame
prevdf_pbfrep = apply(X = otu_table(filtered_ps_pbfrep),
               MARGIN = ifelse(taxa_are_rows(filtered_ps_pbfrep), yes = 1, no = 2),
               FUN = function(x){sum(x > 0)})

# Add taxonomy and total read counts to this data.frame
prevdf_pbfrep = data.frame(Prevalence = prevdf_pbfrep,
                    TotalAbundance = taxa_sums(filtered_ps_pbfrep),
                    tax_table(filtered_ps_pbfrep))

# Define prevalence threshold as 10% of total samples
prevalenceThreshold_pbfrep = 0.10 * nsamples(filtered_ps_pbfrep)
prevalenceThreshold_pbfrep


# Execute prevalence filter, using `prune_taxa()` function
keepTaxa_pbfrep = rownames(prevdf_pbfrep)[(prevdf_pbfrep$Prevalence >= prevalenceThreshold_pbfrep)]
filtered_ps_pbfrep_1 = prune_taxa(keepTaxa_pbfrep, filtered_ps_pbfrep)

###Went from 115 to 56 taxa 


#now also remove samples that have zero counts 



phyloseq_richness_filter <- function(physeq, mintaxa = 10){
  sp <- estimate_richness(physeq, measures = "Observed")
  samples_to_keep <- rownames(sp)[ which(sp$Observed >= mintaxa) ]
  
  
  if(length(samples_to_keep) == 0){
    stop("All samples will be removed.\n")  
  }
  
  if(length(samples_to_keep) == nsamples(physeq)){
    cat("All samples will be preserved\n")
    res <- physeq
  }
  
  if(length(samples_to_keep) < nsamples(physeq)){
    res <- prune_samples(samples = samples_to_keep, x = physeq)
  }
 
  return(res)
}

filtered_ps_pbfrep_2 <- phyloseq_richness_filter(filtered_ps_pbfrep_1, mintaxa = 1)

#lose 1 sample



fam_reads_counts_pbfrep <- psmelt(otu_table(filtered_ps_pbfrep_2))






#I believe that tax_glom agglomerates at a random OTU - so we'll just have to map the OTU name to its iPHOP designation later 


#use tiydrpivot wider to format into a useable matrix 

deseq_matrix_hmp_pbfrep <-  tidyr::pivot_wider(fam_reads_counts_pbfrep, names_from = OTU, values_from = Abundance)
deseq_matrix_hmp_pbfrep

#create variable sample_list (will need for later)
sample_list_pbfrep <- deseq_matrix_hmp_pbfrep$Sample
length(sample_list_pbfrep)

#switching the columns and rows so that each row is a different contig and each column is a different sample 
switch_matrix_deseq2_hmp_pbfrep <-  t(deseq_matrix_hmp_pbfrep)



switch_matrix_deseq2_hmp_pbfrep


#export this 
write.csv(switch_matrix_deseq2_hmp_pbfrep, "/Users/anshulsinha/Desktop/IBD_prophages_aim/bioinformatics_aim/bioinformatics_HMP_2/virome_data_08_2024/deseq_pbfrep/switched_matrix.csv") 

```

```{r}
#reading in manually edited switched matrix

raw_counts2_deseq2_hmp_pbfreps <- read.csv("/Users/anshulsinha/Desktop/IBD_prophages_aim/bioinformatics_aim/bioinformatics_HMP_2/virome_data_08_2024/deseq_pbfrep/switched_matrix_edit.csv", check.names = FALSE)
raw_counts2_deseq2_hmp_pbfreps



#Formatting the rawcount2_deseq2 transposed matrix 



colnames(raw_counts2_deseq2_hmp_pbfreps)[1] <- "contig_ID"

raw_counts2_deseq2_hmp_pbfreps


#replace NA values with 0
raw_counts2_deseq2_hmp_pbfreps[is.na(raw_counts2_deseq2_hmp_pbfreps)] = 0
raw_counts2_deseq2_hmp_pbfreps

#naming that column "contig_ID"

contig_ID_deseq2_hmp_pbfreps <-  raw_counts2_deseq2_hmp_pbfreps$contig_ID

#Now I am generating a "sample index" so I can exclude "contig_ID" from our matrix 

sampleindex_deseq2_hmp_pbfreps <- grepl("\\d", colnames(raw_counts2_deseq2_hmp_pbfreps))
##of the column names, anything that contains a numeric 


#converting to a matrix and only including the sample index columns 
raw_counts_matrix_deseq2_hmp_pbfreps <- as.matrix(raw_counts2_deseq2_hmp_pbfreps[,sampleindex_deseq2_hmp_pbfreps])
raw_counts_matrix_deseq2_hmp_pbfreps


rownames(raw_counts_matrix_deseq2_hmp_pbfreps) <- contig_ID_deseq2_hmp_pbfreps

head(raw_counts_matrix_deseq2_hmp_pbfreps)




```

```{r}

#metadata


metadata_df <- phyloseq_metadata
metadata_df
names(metadata_df)[names(metadata_df) == 'Sample_name'] <- 'filename'

#remove samples that have no dysbiosis scores- this brings us to 1595 samples 
metadata_df <- metadata_df[complete.cases(metadata_df$dysbiosis_binary), ]


#Need to filter out samples that DONT have both a yes and no 

# Filter the PS object so that we have  both  #Use the ps_object with reads (not length normalized reads)




#changing all columns to factor 
sample_mapping_hmp2 <- mutate_if(metadata_df, is.character, as.factor)
sample_mapping_hmp2 <- mutate_if(metadata_df, is.integer, as.factor)
sample_mapping_hmp2 

# Filter again to filter out any samples that have 0 counts or are in the common_ids list created earlier that includes patients with dysb and non-dysb valuees 

sample_mapping_hmp2_filtered_pbfreps <- sample_mapping_hmp2 %>% filter(filename %in% sample_list_pbfrep)


sample_mapping_hmp2_filtered_pbfreps <-  sample_mapping_hmp2_filtered_pbfreps %>% 
    select(filename, diagnosis.x, dysbiosis_binary, Participant.ID) %>% 
     remove_rownames  %>%
    column_to_rownames(var = "filename")




```

```{r}


#Put the columns of the count data in the same order as rows names of the sample mapping, then make sure it worked (TRUE)

raw_counts_matrix_deseq2_hmp_pbfreps <- raw_counts_matrix_deseq2_hmp_pbfreps[, unique(rownames(sample_mapping_hmp2_filtered_pbfreps))]

head(raw_counts_matrix_deseq2_hmp_pbfreps)
all(colnames(raw_counts_matrix_deseq2_hmp_pbfreps) == rownames(sample_mapping_hmp2_filtered_pbfreps))



sample_mapping_hmp2_filtered_pbfreps




```
```{r}
library(DESeq2)
#Use a simple paired design 
#basically treating that each sample has a non_dysbiotic and dysbiotic sample 


deseq2Data_hmp2_pbfrep <- DESeqDataSetFromMatrix(countData=raw_counts_matrix_deseq2_hmp_pbfreps, colData=sample_mapping_hmp2_filtered_pbfreps, design = ~ Participant.ID + dysbiosis_binary)

```
```{r}
#DE results - not using a nested design like with Duerkop data, so no need to rebuild the model matrix here 
#need to first estimate size factors to deal with zeroes 

dds_hmp2_pbfrep <-estimateSizeFactors(deseq2Data_hmp2_pbfrep, type = "poscounts")
dds_hmp2_pbfrep <- DESeq(dds_hmp2_pbfrep)
```

```{r}

resultsNames(dds_hmp2_pbfrep)
deseq2_results_hmp_2_pbfrep <-  results(dds_hmp2_pbfrep, contrast=list("dysbiosis_binary_Yes_vs_No"))



deseq2_results_hmp_2_pbfrep <- as.data.frame(deseq2_results_hmp_2_pbfrep)

deseq2_results_hmp_2_pbfrep <- deseq2_results_hmp_2_pbfrep %>% 
rownames_to_column(var = "contigname")
deseq2_results_hmp_2_pbfrep


#iphop for comb_names and left_join 
pbfrep_iphop <- as.data.frame(df_hmp_iphop_all_combined_taxa_names)
pbfrep_iphop <- rownames_to_column(pbfrep_iphop, var = "contigname")

deseq2_results_hmp_2_comb_pbfrep1 <- left_join(deseq2_results_hmp_2_pbfrep, pbfrep_iphop, by= "contigname")


#also join with other iphop df so I can do some filtering 
hmp2_free_vir_iphop_edited <- hmp2_vir_iphop  %>% 
  select(contigname, Family)

colnames(hmp2_free_vir_iphop_edited) <- c("contigname", "Family_Original")

deseq2_results_hmp_2_comb_pbfrep1 <- left_join(deseq2_results_hmp_2_comb_pbfrep1, hmp2_free_vir_iphop_edited, by= "contigname")

table(deseq2_results_hmp_2_comb_pbfrep1$Family_Original)

#can see here that some of the Families only have either a virulent or temperate - we'll want to remove these for comparison sake 


deseq2_results_hmp_2_comb_pbfrep <- deseq2_results_hmp_2_comb_pbfrep1 %>%
  group_by(Family_Original) %>%
  filter(n() == 2) %>%
  ungroup()

#Now we've gone from  51 total  PBFREPs to 40 (represented by 20 families )
table(deseq2_results_hmp_2_comb_pbfrep$Family_Original)


#significant values - going to use a more strict cutoff here since most are significant using 0.05 (larger sample size = more chance of false positives)
#Managalea used p - 0.001

deseq2_results_hmp_2_sig_pbfrep <- subset(deseq2_results_hmp_2_comb_pbfrep, padj < 0.001)

deseq2_results_hmp_2_sig_pbfrep.05 <- subset(deseq2_results_hmp_2_comb_pbfrep, padj < 0.001)


deseq2_results_hmp_2_sig_pbfrep <- as.data.frame(deseq2_results_hmp_2_sig_pbfrep)


#create fold-change column
deseq2_results_hmp_2_sig_pbfrep$FoldChange <- 2^deseq2_results_hmp_2_sig_pbfrep$log2FoldChange


#temperate-to-virulent ratio = 
31.1819385/9.2208568


deseq2_results_hmp_2_comb_pbfrep



```
```{r}

###HMP-2 FIGS


hmp_2_combined_deseq1_res2_df_changed_pbfrep <- deseq2_results_hmp_2_comb_pbfrep
hmp_2_combined_deseq1_res2_df_changed_pbfrep$pvalue <- hmp_2_combined_deseq1_res2_df_changed_pbfrep$padj
table(hmp_2_combined_deseq1_res2_df_changed_pbfrep$Family)

keyvals_col_con_hmp2_pbfrep <- ifelse(
    hmp_2_combined_deseq1_res2_df_changed_pbfrep$log2FoldChange < -1 & hmp_2_combined_deseq1_res2_df_changed_pbfrep$padj < 0.001, 'orange',
      ifelse(hmp_2_combined_deseq1_res2_df_changed_pbfrep$log2FoldChange > 1 & hmp_2_combined_deseq1_res2_df_changed_pbfrep$padj < 0.001, 'darkgreen',
        'light grey'))
  keyvals_col_con_hmp2_pbfrep[is.na(keyvals_col_con_hmp2_pbfrep)] <- 'light grey'
  names(keyvals_col_con_hmp2_pbfrep)[keyvals_col_con_hmp2_pbfrep == 'darkgreen'] <- 'Enriched in  Dysbiotic Samples'
  names(keyvals_col_con_hmp2_pbfrep)[keyvals_col_con_hmp2_pbfrep == 'light grey'] <- 'Non-significant'
  names(keyvals_col_con_hmp2_pbfrep)[keyvals_col_con_hmp2_pbfrep == 'orange'] <- 'Depleted in Dysbiotic Samples'

EV_col_con_pbfrep <- EnhancedVolcano(hmp_2_combined_deseq1_res2_df_changed_pbfrep, lab=NA , x = 'log2FoldChange',
    y = 'pvalue',  pCutoff = 0.001, cutoffLineWidth = 0.1, selectLab = rownames(hmp_2_combined_deseq1_res2_df_changed_pbfrep)[which(names(keyvals_col_con_hmp2_pbfrep) %in% c('Over-Abundant in Colitis', 'Over-Abundant in Control'))], pointSize = 2, gridlines.major = FALSE, gridlines.minor = FALSE, colCustom = keyvals_col_con_hmp2_pbfrep,  legendPosition = 'right', legendLabSize = 12,legendIconSize = 4.0, title = "", axisLabSize = 15,    subtitle = "", caption = ""
)

EV_col_con_pbfrep



deseq2_results_hmp_2_sig_pbfrep %>%
  mutate(FamilyLabel = gsub("(.*?)-(.*)", "\\1-\\2", Family)) %>%
  ggplot(aes(x = log2FoldChange, y = factor(FamilyLabel, levels = rev(unique(sort(FamilyLabel)))), color = factor(sign(log2FoldChange)))) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray") +
  geom_point(size = 5) +
  labs(
    y = "PBF",
    color = "Log2 Fold Change"
  ) +
  theme(
    axis.text.y = element_text(face = "italic", size = 15),  # Adjust the size value as needed for y-axis labels
    axis.text.x = element_text(size = 15),  # Adjust the size value as needed for x-axis labels
    axis.title.x = element_text(face = "italic")
  ) +
  scale_x_continuous(
    name = expression(Log[2] ~ " Fold Change")
  ) +
  scale_color_manual(
    values = c("cornflowerblue", "coral"),
    breaks = c(-1, 1),
    labels = c("Below 0", "Above 0"),
    guide = "none"  # Remove the legend
  )



deseq2_results_hmp_2_comb_pbfrep %>%
  mutate(FamilyLabel = gsub("(.*?)-(.*)", "\\1-\\2", Family)) %>%
  ggplot(aes(x = log2FoldChange, y = factor(FamilyLabel, levels = rev(unique(sort(FamilyLabel)))), color = factor(sign(log2FoldChange)))) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray") +
  geom_point(size = 5) +
  labs(
    y = "PBF",
    color = "Log2 Fold Change"
  ) +
  theme(
    axis.text.y = element_text(face = "italic", size = 9),  # Adjust the size value as needed for y-axis labels
    axis.text.x = element_text(size = 15),  # Adjust the size value as needed for x-axis labels
    axis.title.x = element_text(face = "italic")
  ) +
  scale_x_continuous(
    name = expression(Log[2] ~ " Fold Change")
  ) +
  scale_color_manual(
    values = c("cornflowerblue", "coral"),
    breaks = c(-1, 1),
    labels = c("Below 0", "Above 0"),
    guide = "none"  # Remove the legend
  )






### FIGURE VERSION
deseq2_results_hmp_2_sig_pbfrep.edit <- deseq2_results_hmp_2_sig_pbfrep 
deseq2_results_hmp_2_sig_pbfrep.edit$Family <- gsub("f__", "", deseq2_results_hmp_2_sig_pbfrep.edit$Family)
deseq2_results_hmp_2_sig_pbfrep.edit$Family <- gsub("_", "-", deseq2_results_hmp_2_sig_pbfrep.edit$Family)



deseq2_results_hmp_2_sig_pbfrep.edit %>%
  mutate(FamilyLabel = gsub("(.*?)-(.*)", "\\1-\\2", Family)) %>%
  mutate(FamilyLabel = factor(
    FamilyLabel,
    levels = FamilyLabel[order(log2FoldChange, decreasing = TRUE)]
  )) %>%
  ggplot(aes(
    x = log2FoldChange, 
    y = FamilyLabel,  # The levels are already sorted based on log2FoldChange
    color = factor(sign(log2FoldChange))
  )) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray") +
  geom_point(size = 5) +
  labs(
    y = "PHF",
    color = "Log2 Fold Change"
  ) +
  theme(
    axis.text.y = element_text(face = "italic", size = 20),  # Increased y-axis label size
    axis.text.x = element_text(size = 20),                  # Increased x-axis label size
    axis.title.x = element_text(face = "italic")
  ) +
  scale_x_continuous(
    name = expression(Log[2] ~ " Fold Change")
  ) +
  scale_color_manual(
    values = c("coral", "darkgreen"),
    breaks = c(-1, 1),
    labels = c("Below 0", "Above 0"),
    guide = "none"  # Remove the legend
  )



```



```{r}
#######Metaphlan4####### ####TESTING CODE USING RELATIVE ABUNDANCE DATA### DO NOT USE FOR FIGURES/MANUSCRIPT

metaphlan4_family_ab <- read.table("/Users/anshulsinha/Desktop/PBF_manuscript/data/metaphlan/merged_abundance_table_family.txt", sep = "\t", header = TRUE)





#how many unique families? 
#312! Much more than the 74 PHF families 

length(unique(metaphlan4_family_ab$clade_name))



unique_fam_names <- (unique(metaphlan4_family_ab$clade_name))
#create a list which will be used as a query for a mapping file using the NCBI-> GTDB Took




write.csv(unique_fam_names, "/Users/anshulsinha/Desktop/PBF_manuscript/data/metaphlan/taxonomy/family_names.csv")


unique_fam_names

#use this to make an input for the taxonomy map (see read me)






#reading the taxonomy map - which maps the taxonomy from metaphlan to GTDB taxonomy 

ncbi_gtdb_map <- read.table("/Users/anshulsinha/Desktop/PBF_manuscript/data/metaphlan/taxonomy/taxonomy_map_summary_06.tsv", header = TRUE, sep = "\t")

#we'll need to do a couple things first: 

#1) separate the lineage column into distinct headers 

# Split the lineage column into separate columns
ncbi_gtdb_map_split <- ncbi_gtdb_map %>%
  separate(lineage, 
           into = c("Domain", "Phylum", "Class", "Order", "Family", "Genus", "Species"), 
           sep = ";", fill = "right")
length(unique(ncbi_gtdb_map_split$ncbi_taxonomy))



# Since the gtdb taxonomy column often does not give us the family (sometimes Family, sometimes Genus, etc.), we wll rename "Family" to GTDB family 
#There are some cases where the "lineage" family does not match up with the family in the gtdb column. 
#Unclear why that would be the case (ie see the f__Carnobacteriaceae row)
#But, what I will do is: 
#if the gtdb taxonomy is at the family level, name gtdb_family using this column, if not, name it the Family column. 


#ncbi_gtdb_map_split$gtdb_family <- ncbi_gtdb_map_split$Family



ncbi_gtdb_map_split <- ncbi_gtdb_map_split %>%
  mutate(gtdb_family = ifelse(startsWith(gtdb_taxonomy, "f__"), gtdb_taxonomy, Family))



table(is.na(ncbi_gtdb_map_split$gtdb_family))
#240 of the 312 are NA (alot of these are "SGBs")


#looks like it worked well
#make upper case 
ncbi_gtdb_map_split <- ncbi_gtdb_map_split %>%
  mutate(gtdb_family = sub("f__(\\w)(\\w*)", "f__\\U\\1\\L\\2", gtdb_family, perl = TRUE))


#but wait .. lets see if there are any cases where there are duplicate family names - could be if the family names are getting consolidated (ie= multiple disparate ncbi families get grouped into the same gtdb dffam )



ncbi_gtdb_map_split_duplicate <- ncbi_gtdb_map_split[duplicated(ncbi_gtdb_map_split$gtdb_family) | duplicated(ncbi_gtdb_map_split$gtdb_family, fromLast = TRUE), ]
#remove NA rows 

library(dplyr)
ncbi_gtdb_map_split_duplicate <- ncbi_gtdb_map_split_duplicate %>% filter(!is.na(gtdb_family))

#thirteen row of cases where we have duplicates 


#What is the concordance between the NCBI, vs. renamed 


ncbi_gtdb_map_split <- ncbi_gtdb_map_split %>%
  mutate(tax_same = ifelse(ncbi_taxonomy == gtdb_family, "True", "False"))

table(ncbi_gtdb_map_split$tax_same)

54+18
#54/72 have the same taxonomy, 18 have renamed taxonomy 




length(unique(ncbi_gtdb_map_split$gtdb_family)) # 65 unique gtdb family assignments 


#create a "select df" that has just the original NCBI names and the Gtdb names 
ncbi_gtdb_map_split_select <- ncbi_gtdb_map_split %>% 
  select(ncbi_taxonomy, gtdb_family)

colnames(ncbi_gtdb_map_split_select) <- c("clade_name", "gtdb_family")







#Lets go back to our metaphlan family abundance table and try to rename the families and create an OTU table 
#step one create and OTU table - we don't need to worry about changing taxonomy just yet. We can create our OTU table with the "clade_names" and then map these to the Family level - this will deal with any NA issues that arise from incompatbility between NCBI and GTDB - will be similar to PHF analyses- we can remove "NA" families

metaphlan4_family_ab

#left join
metaphlan4.family.2 <- left_join(metaphlan4_family_ab, ncbi_gtdb_map_split_select, by = "clade_name")

#312



#reorder so that gtdb family one is second 
# Rearrange columns to move `target_column` to the second position
metaphlan4.family.3 <- metaphlan4.family.2 %>%
  select(1, gtdb_family, everything())



#Remove prefixes 
metaphlan4.family.3$gtdb_family <- sub("^f__", "", metaphlan4.family.2$gtdb_family )
metaphlan4.family.3$clade_name <- sub("^f__", "", metaphlan4.family.2$clade_name )




#for the OTU table - i'll need to remove the family column and convert "clade_name" to rownnames
# Remove the gtdb_family col
metaphlan4.family.4 <- metaphlan4.family.3 %>%
  select(-gtdb_family)




metaphlan4.family.4 <- metaphlan4.family.4 %>% 
tibble::column_to_rownames("clade_name")



# Remove the '_d_metagenome' suffix from column names
colnames(metaphlan4.family.4) <- sub("d_metagenome$", "", colnames(metaphlan4.family.4))



metaphlan4.matrix <- as.matrix(metaphlan4.family.4)

#make taxonomy table - I should be able to make the tax_IDs the family names (and rownames)


metaphlan4.family.3.tax <- metaphlan4.family.3 %>%
  select(clade_name, gtdb_family)

#make another taxonomic level the same as clade name - don't think I'll be able to tax_glom without 
metaphlan4.family.3.tax$ncbi_fam <- metaphlan4.family.3.tax$clade_name



# Rearrange columns to move `target_column` to the second position
metaphlan4.family.3.tax <- metaphlan4.family.3.tax %>%
  select(1, ncbi_fam, everything())



#looks for cases that there are multiple clade_names values exist per gtdb family


metaphlan4.family.3.tax %>%
  group_by(gtdb_family) %>%
  summarize(n_clade_names = n_distinct(clade_name)) %>%
  arrange(desc(n_clade_names))  # Sort to see highest counts first



#looks for cases that there are multiple gtdb_family values exist per clade_name
metaphlan4.family.3.tax %>%
  group_by(clade_name) %>%
  summarize(n_families = n_distinct(gtdb_family)) %>%
  arrange(desc(n_families))  # Sort to see highest counts first
#This should be ok in a hierarchical setting>


#but I think i need to rearrange the orders here:


# Flip 2nd and 3rd columns
metaphlan4.family.3.tax <- metaphlan4.family.3.tax %>%
  select(clade_name, gtdb_family, ncbi_fam)






metaphlan.tax <- metaphlan4.family.3.tax %>% 
tibble::column_to_rownames("clade_name")



#as matrix 
metaphlan.tax.mat <- as.matrix(metaphlan.tax)


#metadata 
hmp2_metadata_phylo






```



```{r}

#make phyloseq!



library("phyloseq")
OTU_HMP2_metaphlan = otu_table(metaphlan4.matrix, taxa_are_rows = TRUE)
TAX_HMP2_metaphlan = tax_table(metaphlan.tax.mat)
META_HMP2_metaphlan <- sample_data(hmp2_metadata_phylo)
sample_names(META_HMP2_metaphlan) <- hmp2_metadata_phylo$filename
physeq_metaphlan_hmp2 = phyloseq(OTU_HMP2_metaphlan, TAX_HMP2_metaphlan, META_HMP2_metaphlan)


#1595 samples!

```


```{r}
physeq_metaphlan_hmp2_glom <- tax_glom(physeq_metaphlan_hmp2, taxrank="gtdb_family", NArm = TRUE) 

melted_glom_metaphlan <- ps_melt(physeq_metaphlan_hmp2_glom)

table(melted_glom_metaphlan$OTU)
table(melted_glom_metaphlan$gtdb_family)

length(melted_glom_metaphlan$OTU)
length(melted_glom_metaphlan$gtdb_family)


table(unique(melted_glom_metaphlan$OTU))
table(unique(melted_glom_metaphlan$gtdb_family))



#Look good when we glom!






#lets first filter for the same samples we did with our PHF analyses, measure depth, and calculate Good's coverage 

#list of sample names above 1,500 

sample.names.1500
length(sample.names.1500)



#filter to just get the 1,093
physeq_filtered_1500_metaphlan <- prune_samples(sample_names(physeq_metaphlan_hmp2) %in% sample.names.1500, physeq_metaphlan_hmp2)


#read count info 
reads_sample_metaphlan <- readcount(physeq_filtered_1500_metaphlan)




## Now lets see if sampling depth is sufficient

#step1 calculate Good's coveage

ps_melt_metaphlan_filtered <-  ps_melt(physeq_filtered_1500_metaphlan) 




 goods.data.metaphlan <- ps_melt_metaphlan_filtered %>% 
  group_by(Sample) %>%
  summarise(nseqs= sum(Abundance),
            n_singletons = sum(Abundance == 1), 
            goods = 100*(1- n_singletons/nseqs)) 


  goods.plot.metaphlan <- goods.data.metaphlan %>% 
  ggplot(aes(x=nseqs, y=goods)) +
    geom_point()
  #no singletons!
  
  
  
  
  #Looks like we're gettting enough seqs here
  
  mat2 <- as(t(otu_table(physeq_filtered_1500_metaphlan)), "matrix")
raremax2 <- min(rowSums(mat2))



random_rows2 <- sample(nrow(mat2), 50)
matrix.sub2 <- mat2[random_rows2, ]


subset_mat.pre.filt.2 <- mat2[1:50, ]

#rarecurve(subset_mat.pre.filt.2, step = 20, sample = raremax2, col = "coral", cex = 0.6, label = FALSE, main="Before Filtering")


  
```


```{r}
#instead of rarefying at 1500, rarefy at min sampling depth 





physeq_filtered_1500_metaphlan_rarefy <- rarefy_even_depth(physeq_filtered_1500_metaphlan, sample.size = min(sample_sums(physeq_filtered_1500_metaphlan)),
  rngseed = 1, replace = TRUE, trimOTUs = TRUE, verbose = TRUE)

#removed 260 OTUs  during subsampling -> means lost from any sample (because we went from 312 - 286)






```


```{r}
# calculate beta diversity - do at diagnosis and dysbiosis level with bray 
#should be able to use the same function as for the PHFs - tax glom at fam level and remove NAs


 
 PCoA_PBF_metaphlan  <- function(ps, distance, group_var) {


  
ps1 <- tax_glom(ps, taxrank="gtdb_family", NArm = TRUE) 

dist.ps.fixed <- ps1 %>%
 tax_fix(unknowns = "NA") %>%
  dist_calc(distance)
  

  

fixed.ps.dist.ord <- dist.ps.fixed  %>% 
  ord_calc("PCoA")
 
 ord_plot(fixed.ps.dist.ord, color = group_var, size = 2, interactive = FALSE) + 
   scale_colour_brewer(palette = "Dark2")
 
 
}
```



```{r}
#Generate PcoAs 
#first run to get axis numbers so I can label below 
 PCoA_PBF_metaphlan(physeq_filtered_1500_metaphlan_rarefy, "bray", "dysbiosis_binary")


PCoA_PBF.Bray.Dysbiosis.metaphlan <-   PCoA_PBF_metaphlan(physeq_filtered_1500_metaphlan_rarefy, "bray", "dysbiosis_binary") + ggtitle("Metaphlan Family") + theme_bw() + 
  labs(color = "Dysbiosis Status",x = "PCoA Axis 1 (41.5%)", y = "PCoA Axis 2 (10.2%)") + # Modify axis names) + 
 scale_color_manual(values = c("No" = "#AF9117", "Yes" = "#06402B"), # Adjust color labels
                     labels = c("No" = "Non-Dysbiotic", "Yes" = "Dysbiotic")) + 
    theme(legend.title = element_text(size = 14),   # Increase legend title size
        legend.text = element_text(size = 12), plot.title = element_text(size = 18)) + 
    theme(
    plot.title = element_text(size = 16, face = "bold"), # Increase title size
    legend.title = element_text(size = 14),             # Customize legend title size
    legend.text = element_text(size = 12)              # Customize legend text size
  )






PCoA_PBF.Bray.Diagnosis.metaphlan <-   PCoA_PBF_metaphlan(physeq_filtered_1500_metaphlan_rarefy, "bray", "diagnosis.x") +  ggtitle("Metaphlan Family")+ theme_bw() + 
  labs(color = "Diagnosis",x = "PCoA Axis 1 (41.5%)", y = "PCoA Axis 2 (10.2%)") + # Modify axis names) + 
 scale_color_manual(values = c("nonIBD" = "#06402B", "CD" = "#ff2d29", "UC" = "#A020F0"), # Adjust color labels
                     labels = c("nonIBD" = "Non-IBD", "CD" = "CD", "UC" = "UC")) + 
  theme(
    plot.title = element_text(size = 16, face = "bold"), # Increase title size
    legend.title = element_text(size = 14),             # Customize legend title size
    legend.text = element_text(size = 12)              # Customize legend text size
  )


PCoA_PBF.Bray.Dysbiosis.metaphlan
PCoA_PBF.Bray.Diagnosis.metaphlan

```



```{r}
#PERMANOVAs

PBF_perm_metaphlan  <- function(ps, distance, group_var) {

#can directly calculate bray distance from here since we have rarefied 


    
ps1 <- tax_glom(ps, taxrank="gtdb_family", NArm = TRUE) 

dist.ps.fixed <- ps1 %>%
 tax_fix(unknowns = "NA") %>%
  dist_calc(distance)
  
    
  perm <- dist.ps.fixed %>%
  dist_permanova(
    seed = 1234, # for set.seed to ensure reproducibility of random process
    n_processes = 1, n_perms = 999, # you should use at least 999!
    variables = group_var
  )
 
 
   perm_get(perm) %>% as.data.frame()

  
}

 PBF_perm_metaphlan(physeq_filtered_1500_metaphlan_rarefy, "bray", "dysbiosis_binary")
  PBF_perm_metaphlan(physeq_filtered_1500_metaphlan_rarefy, "bray", "diagnosis.x")



```


```{r}
#Look for differentially abundant families -> metaphlan!

### DESEQ2 #### FOR DYSBIOTIC SAMPLES 
#Whole virome here:

#dysbiotic vs. non-dysbiotic 


#get names of those samples with more than 1500 reads from PHF

filtered.1500.sampledata <-  data.frame(sample_data(subset_1500))

sample.names.1500 <- filtered.1500.sampledata$filename



#This is the ps object that have the 1,093 where the number of reads (PHFs) is above 1,500 (length normalized)

physeq_filtered_1500_metaphlan




#now subset the phyloseq object so it only contains patient IDs that have both a dysbiotic and non-dysbiotic sample


#First, create a list of the samples that you want to remove

#metadata 
phyloseq_metadata <- hmp2_metadata_phylo 

#filter for samples that just have a "yes" valuue
yes_ids <- phyloseq_metadata %>% filter(dysbiosis_binary == "Yes") %>% distinct(Participant.ID)
no_ids <- phyloseq_metadata %>% filter(dysbiosis_binary == "No") %>% distinct(Participant.ID)



# Find the common Participant.IDs
common_ids <- intersect(yes_ids$Participant.ID, no_ids$Participant.ID)

length(common_ids)


# Filter the PS object so that we have  both dysbiotic and non indiviuals 
#Use the ps_object with reads (not length normalized reads)


filtered_ps_metaphlan <- subset_samples(physeq_filtered_1500_metaphlan 
, Participant.ID %in% common_ids)

#487 samples left 

filtered_ps_metaphlan



table(as.data.frame(tax_table(filtered_ps_metaphlan))$gtdb_family)



#1) tax glom- removing NAs - dont really want to include unknowns or single contigs here as they could influence DESEQ2 calc
#PS melt to generate counts table as df 



 tax_glom_fam_reads_deseq_metaphlan <- tax_glom(filtered_ps_metaphlan, taxrank="gtdb_family", NArm = TRUE) 
 #63 families after tax_glom
 
 

# Check the unique values for OTU and gtdb_family
table(melted_glom_metaphlan$OTU)
table(melted_glom_metaphlan$gtdb_family)




 
##Filtering step here: Only include taxa that were included in DE analyses for PHFs
 
 PBF_list_50_prev_metaphlan <- PBF_list_50_prev

 unique(PBF_list_50_prev_metaphlan$Family)
 #remove f__ so its comparable with our metaphlan ps.object 
 
 PBF_list_50_prev_metaphlan$Family <- gsub("^f__", "", PBF_list_50_prev_metaphlan$Family)

 
 
 
 
 
 
 #first melt the PS to determine the tax_ids that correspond to the PBFs
ps_melted_filtered_metaphlan <- ps_melt(tax_glom_fam_reads_deseq_metaphlan)

length(unique(ps_melted_filtered_metaphlan$gtdb_family)) #63 left 



#now take the contignames that are associated with the families that I want to keep 
ps_melted_filtered.prevalent.metaphlan <- ps_melted_filtered_metaphlan %>% 
  filter(gtdb_family %in% PBF_list_50_prev_metaphlan$Family )

length(unique(ps_melted_filtered.prevalent.metaphlan$gtdb_family)) #12 in here 
length(unique(ps_melted_filtered.prevalent.metaphlan$OTU)) #12 in here 






#now take the OTU names from this 
 keepTaxa.metaphlan = unique(ps_melted_filtered.prevalent.metaphlan$OTU)



tax_glom_fam_reads_deseq.pruned.metaphlan <- prune_taxa(keepTaxa.metaphlan, tax_glom_fam_reads_deseq_metaphlan)
 
###Went from 74 to 18 taxa 


#now also remove samples that have zero counts 



phyloseq_richness_filter <- function(physeq, mintaxa = 10){
  sp <- estimate_richness(physeq, measures = "Observed")
  samples_to_keep <- rownames(sp)[ which(sp$Observed >= mintaxa) ]
  
  
  if(length(samples_to_keep) == 0){
    stop("All samples will be removed.\n")  
  }
  
  if(length(samples_to_keep) == nsamples(physeq)){
    cat("All samples will be preserved\n")
    res <- physeq
  }
  
  if(length(samples_to_keep) < nsamples(physeq)){
    res <- prune_samples(samples = samples_to_keep, x = physeq)
  }
 
  return(res)
}

tax_glom_fam_reads_deseq.metaphlan1 <- phyloseq_richness_filter(tax_glom_fam_reads_deseq.pruned.metaphlan, mintaxa = 1)

#still at 487 samples 





fam_reads_counts_deseq.metaphlan <- psmelt(otu_table(tax_glom_fam_reads_deseq.metaphlan1))


fam_reads_counts_deseq.meta.metaphlan <- data.frame(filename = unique(fam_reads_counts_deseq.metaphlan$Sample))
#sanity check - num individuals, diagnosis status, dysb vs. not 



fam_reads_counts_deseq.meta.metaphlan <- left_join(fam_reads_counts_deseq.meta.metaphlan, hmp2_metadata_phylo, by="filename")

length(unique(fam_reads_counts_deseq.meta.metaphlan$Participant.ID))
table(fam_reads_counts_deseq.meta.metaphlan$diagnosis.x)
table(fam_reads_counts_deseq.meta.metaphlan$dysbiosis_binary)

#49 individuals 
#140 non-IBD samples, 227 CD, 120 UC 
#371 Non, 116 dysbiotic samples 




#I believe that tax_glom agglomerates at a random OTU - so we'll just have to map the OTU name to its iPHOP designation later 


#use tiydrpivot wider to format into a useable matrix 

deseq_matrix_hmp_metaphlan <-  tidyr::pivot_wider(fam_reads_counts_deseq.metaphlan, names_from = OTU, values_from = Abundance)
deseq_matrix_hmp_metaphlan

#create variable sample_list (will need for later)
sample_list_metaphlan <- deseq_matrix_hmp_metaphlan$Sample
length(sample_list_metaphlan)

#switching the columns and rows so that each row is a different contig and each column is a different sample 
switch_matrix_deseq2_hmp_metaphlan <-  t(deseq_matrix_hmp_metaphlan)


#switch_matrix_deseq2_hmp <- as.data.frame(switch_matrix_deseq2_hmp)

# Assign the first row as column names
#colnames(switch_matrix_deseq2_hmp) <- switch_matrix_deseq2_hmp[1, ]

# Remove the first row
#switch_matrix_deseq2_hmp <- switch_matrix_deseq2_hmp[-1, ]

# If you need to convert 
#switch_matrix_deseq2_hmp <- as.matrix(switch_matrix_deseq2_hmp)

switch_matrix_deseq2_hmp.1.metaphlan <- switch_matrix_deseq2_hmp_metaphlan
#export this 
write.csv(switch_matrix_deseq2_hmp.1.metaphlan, "/Users/anshulsinha/Desktop/PBF_manuscript/data/metaphlan/deseq/matrix.csv") 


#dim(switch_matrix_deseq2_hmp)



```

```{r}
#reading in manually edited switched matrix

raw_counts2_deseq2_hmp.metaphlan <- read.csv("/Users/anshulsinha/Desktop/PBF_manuscript/data/metaphlan/deseq/matrix_switched.csv", check.names = FALSE)


#Formatting the rawcount2_deseq2 transposed matrix 



colnames(raw_counts2_deseq2_hmp.metaphlan)[1] <- "contig_ID"

raw_counts2_deseq2_hmp.metaphlan


#replace NA values with 0
raw_counts2_deseq2_hmp.metaphlan[is.na(raw_counts2_deseq2_hmp.metaphlan)] = 0
raw_counts2_deseq2_hmp.metaphlan

#naming that column "contig_ID"

contig_ID_deseq2_hmp_metaphlan <-  raw_counts2_deseq2_hmp.metaphlan$contig_ID

#Now I am generating a "sample index" so I can exclude "contig_ID" from our matrix 

sampleindex_deseq2_hmp_metaphlan <- grepl("\\d", colnames(raw_counts2_deseq2_hmp.metaphlan))
##of the column names, anything that contains a numeric 


#converting to a matrix and only including the sample index columns 
raw_counts_matrix_deseq2_hmp_metaphlan <- as.matrix(raw_counts2_deseq2_hmp.metaphlan[,sampleindex_deseq2_hmp_metaphlan])
raw_counts_matrix_deseq2_hmp_metaphlan


rownames(raw_counts_matrix_deseq2_hmp_metaphlan) <- contig_ID_deseq2_hmp_metaphlan

head(raw_counts_matrix_deseq2_hmp_metaphlan)


raw_counts_matrix_deseq2_hmp_metaphlan


```
```{r}
#metadata



metadata_df <- read.csv("/Users/anshulsinha/Desktop/IBD_prophages_aim/bioinformatics_aim/bioinformatics_HMP_2/prop_stats_outputs/combined_metadata.csv", header = TRUE, row.names = 1)
metadata_df
names(metadata_df)[names(metadata_df) == 'Sample_name'] <- 'filename'

#remove samples that have no dysbiosis scores- this brings us to 1595 samples 
metadata_df <- metadata_df[complete.cases(metadata_df$dysbiosis_binary), ]


#Need to filter out samples that DONT have both a yes and no 

# Filter the PS object so that we have  both  #Use the ps_object with reads (not length normalized reads)




#changing all columns to factor 
sample_mapping_hmp2 <- mutate_if(metadata_df, is.character, as.factor)
sample_mapping_hmp2 <- mutate_if(metadata_df, is.integer, as.factor)
sample_mapping_hmp2 

# Filter again to filter out any samples that have 0 counts or are in the common_ids list created earlier that includes patients with dysb and non-dysb valuees 




sample_mapping_hmp2_filtered <- sample_mapping_hmp2 %>% filter(filename %in% sample_list)


sample_mapping_hmp2_filtered <-  sample_mapping_hmp2_filtered %>% 
    select(filename, diagnosis.x, dysbiosis_binary, Participant.ID) %>% 
     remove_rownames  %>%
    column_to_rownames(var = "filename")


```

```{r}




#Put the columns of the count data in the same order as rows names of the sample mapping, then make sure it worked (TRUE)

raw_counts_matrix_deseq2_hmp_metaphlan <- raw_counts_matrix_deseq2_hmp_metaphlan[, unique(rownames(sample_mapping_hmp2_filtered))]

head(raw_counts_matrix_deseq2_hmp_metaphlan)
all(colnames(raw_counts_matrix_deseq2_hmp_metaphlan) == rownames(sample_mapping_hmp2_filtered))



sample_mapping_hmp2_filtered

length(unique(sample_mapping_hmp2_filtered$Participant.ID)) #comparing the 49 individuals who have dysbiotic and non samples 


```



```{r}
library(DESeq2)
#Use a simple paired design 
#basically treating that each sample has a non_dysbiotic and dysbiotic sample 


deseq2Data_hmp2_metaphlan <- DESeqDataSetFromMatrix(countData=raw_counts_matrix_deseq2_hmp_metaphlan, colData=sample_mapping_hmp2_filtered, design = ~ Participant.ID + dysbiosis_binary)


```

```{r}
#DE results - not using a nested design like with Duerkop data, so no need to rebuild the model matrix here 
#need to first estimate size factors to deal with zeroes 

dds_hmp2_metaphlan <-estimateSizeFactors(deseq2Data_hmp2_metaphlan, type = "poscounts")
dds_hmp2_metaphlan <- DESeq(dds_hmp2_metaphlan)





```

```{r}
deseq2_results_hmp_2_metaphlan <-  results(dds_hmp2_metaphlan, contrast=list("dysbiosis_binary_Yes_vs_No"))
# A couple things to note from this results table: 1) Entero and Muribac are NA for significance (believe this is related to outliers for Entero and low base mean for Muribac)
# 2) Barnsiella has a huge LFC and very significant despite its counts not really indicating an increase in the dysbiotic group


#ie see here 
plotCounts(dds_hmp2_metaphlan, gene = "Oscillospiraceae", 
                        intgroup = "dysbiosis_binary")



#ie see here 
plotCounts(dds_hmp2_metaphlan, gene = "Enterobacteriaceae", 
                        intgroup = "dysbiosis_binary")


plotCounts(dds_hmp2_metaphlan, gene = "Barnesiellaceae", 
                        intgroup = "dysbiosis_binary")
#see here no indication Barnsiellaceae is higher 

#and relative abundance 

tax_glom_fam_reads_deseq.metaphlan1
ps_rel_barn <- transform_sample_counts(tax_glom_fam_reads_deseq.metaphlan1, function(x) x / sum(x))  # Convert to relative abundance

# Convert phyloseq to a dataframe
df_barn <- psmelt(ps_rel_barn)

# Filter for the specific taxon
taxa_of_interest <- "Barnesiellaceae"

df_taxa_barn <- subset(df_barn, grepl("Barnesiellaceae", OTU))  # Adjust "Taxon" column as needed
ggplot(df_taxa_barn, aes(x = dysbiosis_binary, y = Abundance, color = dysbiosis_binary)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.5) +  # Boxplot for distribution
  geom_jitter(width = 0.2, size = 2, alpha = 0.7) +  # Jitter for individual points
  scale_y_continuous(labels = scales::percent_format(accuracy = 0.1)) +  # Convert to percentage
  theme_minimal() +
  labs(title = paste("Relative Abundance of", taxa_of_interest),
       y = "Relative Abundance (%)",
       x = "Dysbiosis Status") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

#lower rel ab visually in dysbiotic samples


#what proportion of Barnsiella have a 0 count in dysbiosis and not dysbiotic 
zero_counts <- aggregate(Abundance == 0 ~ dysbiosis_binary, data = df_taxa_barn, FUN = mean)

#higher proportion of dysbiotic samples have no Barnsiella! 




plotDispEsts(dds_hmp2_metaphlan)

# Extract dispersion estimates correctly
disp_table <- as.data.frame(mcols(dds_hmp2_metaphlan)[, c("baseMean", "dispGeneEst")])

# Check if values are numeric
str(disp_table)


# Log-transform mean and dispersion (avoid log10(0) issues)
disp_table$logMean <- log10(disp_table$baseMean + 1)
disp_table$logDisp <- log10(disp_table$dispGeneEst + 1)


# Custom ggplot2 dispersion plot
ggplot(disp_table, aes(x = logMean, y = logDisp)) +
  geom_point(alpha = 0.5) +
  labs(x = "Log10 Mean Expression", y = "Log10 Dispersion Estimate") +
  theme_minimal()




#due to inconsistencies between the abundance and LFC estimates, I'm going to use the LFC shrinkage 
```


```{r}
plotCounts(dds_hmp2_metaphlan, gene = "Oscillospiraceae", 
                        intgroup = "dysbiosis_binary")


plotCounts(dds_hmp2_metaphlan, gene = "Barnesiellaceae", 
                        intgroup = "dysbiosis_binary")

#barnsiella trend looks weird
```
```{r}
# https://hbctraining.github.io/DGE_workshop_salmon_online/lessons/05b_wald_test_results.html
#TO deal with these weird trends with Barnsiella (counts not agreeing at all with the LFC estimate, I will use LFC shrinkage - see above link)
# helps in cases with high dispersion and 
# Would also help with Muribaculaceae estimate 

# Apply fold change shrinkage


deseq2_results_hmp_2_metaphlan_shrunk <- lfcShrink(dds_hmp2_metaphlan, coef="dysbiosis_binary_Yes_vs_No", type="apeglm")


```


```{r}

#now should lets deal with the two Families that had "NA". Reasons outlined hereL could be genes with zero counts in all samples (not applicable), genes with extreme count outlier (maybe), genes with low mean normalized count (maybe )


#see if outlier counts could be driving this

plotCounts(dds_hmp2_metaphlan, gene = "Enterobacteriaceae", 
                        intgroup = "dysbiosis_binary")
# can see one high count value, could be responsible for the outlier detection

#lets ID this sample 


entero_counts_data <- plotCounts(dds_hmp2_metaphlan, gene = "Enterobacteriaceae", 
                        intgroup = "dysbiosis_binary", returnData = TRUE)
entero_counts_data$sample <- rownames(entero_counts_data)  # Add sample names
entero_counts_data[which.max(entero_counts_data$count), ]

#H4017_37_CD has a high value 

#lets look at whether this sample has anything "weird' going on.
ps_rel_entero <- transform_sample_counts(physeq_filtered_1500_metaphlan, function(x) x / sum(x))



ps_sample_H4017 <- subset_samples(ps_rel_entero, sample_names(ps_rel_entero) == "H4017_37_CD")


df_H4017 <- psmelt(ps_sample_H4017)

ggplot(df_H4017, aes(x = Sample, y = Abundance, fill = OTU)) + 
  geom_bar(stat = "identity") + 
  theme_minimal() +
  labs(title = "Relative Abundance of Sample1",
       y = "Relative Abundance",
       x = "Sample") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


#very high entero, but reasonable that a sample could have high amounts (especially in CD)


as.data.frame(readcount(tax_glom_fam_reads_deseq.metaphlan1))


#do same with Muribaculaceae 

plotCounts(dds_hmp2_metaphlan, gene = "Muribaculaceae", 
                        intgroup = "dysbiosis_binary")

#doesnt seem like its any outlier count, probably due to low counts 


```
```{r}
#will use a combination of LFC shrink and setting cookscutoff to deal with NAs and strange LFC values 
#first shrink LFC
deseq2_results_hmp_2_metaphlan_shrunk <- lfcShrink(dds_hmp2_metaphlan, coef="dysbiosis_binary_Yes_vs_No", type="normal", svalue = FALSE)

#results without cooks cutoff (outliers)

deseq2_results_hmp_2_metaphlan_not_shrunk <-  results(dds_hmp2_metaphlan, contrast=list("dysbiosis_binary_Yes_vs_No"), cooksCutoff = FALSE)


deseq2_results_hmp_2_metaphlan_not_shrunk
deseq2_results_hmp_2_metaphlan_shrunk
summary(deseq2_results_hmp_2_metaphlan_shrunk)
```
```{r}


tax_glom_fam_reads_deseq.metaphlan1_cleaned <- subset_samples(tax_glom_fam_reads_deseq.metaphlan1, sample_names(tax_glom_fam_reads_deseq.metaphlan1) != "H4017_37_CD")

#486 now 
fam_reads_counts_deseq.metaphlan_cleaned <- psmelt(otu_table(tax_glom_fam_reads_deseq.metaphlan1_cleaned))


fam_reads_counts_deseq.meta.metaphlan2 <- data.frame(filename = unique(fam_reads_counts_deseq.metaphlan_cleaned$Sample))
#sanity check - num individuals, diagnosis status, dysb vs. not 
fam_reads_counts_deseq.meta.metaphlan <- left_join(fam_reads_counts_deseq.meta.metaphlan, hmp2_metadata_phylo, by="filename")

length(unique(fam_reads_counts_deseq.meta.metaphlan$Participant.ID))
table(fam_reads_counts_deseq.meta.metaphlan$diagnosis.x)
table(fam_reads_counts_deseq.meta.metaphlan$dysbiosis_binary)

#49 individuals 
#140 non-IBD samples, 227 CD, 120 UC 
#371 Non, 116 dysbiotic samples 




#I believe that tax_glom agglomerates at a random OTU - so we'll just have to map the OTU name to its iPHOP designation later 


#use tiydrpivot wider to format into a useable matrix 

deseq_matrix_hmp_metaphlan_cleaned <-  tidyr::pivot_wider(fam_reads_counts_deseq.metaphlan_cleaned, names_from = OTU, values_from = Abundance)
deseq_matrix_hmp_metaphlan_cleaned

```



```{r}
#I don't think I can do both... I will use LFC shrink, but remove H4017_37_CD and then re-run the deseq workflow and see what happens



tax_glom_fam_reads_deseq.metaphlan1

tax_glom_fam_reads_deseq.metaphlan1_cleaned <- subset_samples(tax_glom_fam_reads_deseq.metaphlan1, sample_names(tax_glom_fam_reads_deseq.metaphlan1) != "H4017_37_CD")

#486 now 
fam_reads_counts_deseq.metaphlan_cleaned <- psmelt(otu_table(tax_glom_fam_reads_deseq.metaphlan1_cleaned))


fam_reads_counts_deseq.meta.metaphlan_cleaned2 <- data.frame(filename = unique(fam_reads_counts_deseq.metaphlan_cleaned$Sample))
#sanity check - num individuals, diagnosis status, dysb vs. not 
fam_reads_counts_deseq.meta.metaphlan.cleaned3 <- left_join(fam_reads_counts_deseq.meta.metaphlan_cleaned2, hmp2_metadata_phylo, by="filename")

length(unique(fam_reads_counts_deseq.meta.metaphlan.cleaned$Participant.ID))
table(fam_reads_counts_deseq.meta.metaphlan.cleaned$diagnosis.x)
table(fam_reads_counts_deseq.meta.metaphlan.cleaned$dysbiosis_binary)

#49 individuals 
#140 non-IBD samples, 226 CD, 120 UC 








#I believe that tax_glom agglomerates at a random OTU - so we'll just have to map the OTU name to its iPHOP designation later 


#use tiydrpivot wider to format into a useable matrix 

deseq_matrix_hmp_metaphlan_cleaned <-  tidyr::pivot_wider(fam_reads_counts_deseq.metaphlan_cleaned, names_from = OTU, values_from = Abundance)
deseq_matrix_hmp_metaphlan_cleaned

#create variable sample_list (will need for later)
sample_list_metaphlan_cleaned <- deseq_matrix_hmp_metaphlan_cleaned$Sample
length(deseq_matrix_hmp_metaphlan_cleaned)

#switching the columns and rows so that each row is a different contig and each column is a different sample 
switch_deseq_matrix_hmp_metaphlan_cleaned <-  t(deseq_matrix_hmp_metaphlan_cleaned)


#switch_matrix_deseq2_hmp <- as.data.frame(switch_matrix_deseq2_hmp)

# Assign the first row as column names
#colnames(switch_matrix_deseq2_hmp) <- switch_matrix_deseq2_hmp[1, ]

# Remove the first row
#switch_matrix_deseq2_hmp <- switch_matrix_deseq2_hmp[-1, ]

# If you need to convert 
#switch_matrix_deseq2_hmp <- as.matrix(switch_matrix_deseq2_hmp)

#export this 
write.csv(switch_deseq_matrix_hmp_metaphlan_cleaned, "/Users/anshulsinha/Desktop/PBF_manuscript/data/metaphlan/deseq/matrix2.csv") 


#dim(switch_matrix_deseq2_hmp)




```

```{r}
#reading in manually edited switched matrix

raw_counts2_deseq2_hmp.metaphlan_cleaned <- read.csv("/Users/anshulsinha/Desktop/PBF_manuscript/data/metaphlan/deseq/matrix2_switched.csv", check.names = FALSE)


#Formatting the rawcount2_deseq2 transposed matrix 



colnames(raw_counts2_deseq2_hmp.metaphlan_cleaned)[1] <- "contig_ID"

raw_counts2_deseq2_hmp.metaphlan_cleaned


#replace NA values with 0
raw_counts2_deseq2_hmp.metaphlan_cleaned[is.na(raw_counts2_deseq2_hmp.metaphlan_cleaned)] = 0
raw_counts2_deseq2_hmp.metaphlan_cleaned

#naming that column "contig_ID"

contig_ID_deseq2_hmp_metaphlan_cleaned <-  raw_counts2_deseq2_hmp.metaphlan_cleaned$contig_ID

#Now I am generating a "sample index" so I can exclude "contig_ID" from our matrix 

sampleindex_deseq2_hmp_metaphlan_cleaned <- grepl("\\d", colnames(raw_counts2_deseq2_hmp.metaphlan_cleaned))
##of the column names, anything that contains a numeric 


#converting to a matrix and only including the sample index columns 
raw_counts_matrix_deseq2_hmp_metaphlan_cleaned <- as.matrix(raw_counts2_deseq2_hmp.metaphlan_cleaned[,sampleindex_deseq2_hmp_metaphlan_cleaned])
raw_counts_matrix_deseq2_hmp_metaphlan_cleaned


rownames(raw_counts_matrix_deseq2_hmp_metaphlan_cleaned) <- contig_ID_deseq2_hmp_metaphlan_cleaned

head(raw_counts_matrix_deseq2_hmp_metaphlan_cleaned)


raw_counts_matrix_deseq2_hmp_metaphlan

```






```{r}
#metadata



metadata_df <- read.csv("/Users/anshulsinha/Desktop/IBD_prophages_aim/bioinformatics_aim/bioinformatics_HMP_2/prop_stats_outputs/combined_metadata.csv", header = TRUE, row.names = 1)
metadata_df
names(metadata_df)[names(metadata_df) == 'Sample_name'] <- 'filename'

#remove samples that have no dysbiosis scores- this brings us to 1595 samples 
metadata_df <- metadata_df[complete.cases(metadata_df$dysbiosis_binary), ]


#Need to filter out samples that DONT have both a yes and no 

# Filter the PS object so that we have  both  #Use the ps_object with reads (not length normalized reads)




#changing all columns to factor 
sample_mapping_hmp2 <- mutate_if(metadata_df, is.character, as.factor)
sample_mapping_hmp2 <- mutate_if(metadata_df, is.integer, as.factor)
sample_mapping_hmp2 

# Filter again to filter out any samples that have 0 counts or are in the common_ids list created earlier that includes patients with dysb and non-dysb valuees 




sample_mapping_hmp2_filtered <- sample_mapping_hmp2 %>% filter(filename %in% sample_list_metaphlan_cleaned)


sample_mapping_hmp2_filtered <-  sample_mapping_hmp2_filtered %>% 
    select(filename, diagnosis.x, dysbiosis_binary, Participant.ID) %>% 
     remove_rownames  %>%
    column_to_rownames(var = "filename")

```
```{r}

#Put the columns of the count data in the same order as rows names of the sample mapping, then make sure it worked (TRUE)

raw_counts_matrix_deseq2_hmp_metaphlan_cleaned <- raw_counts_matrix_deseq2_hmp_metaphlan_cleaned[, unique(rownames(sample_mapping_hmp2_filtered))]

#head(raw_counts_matrix_deseq2_hmp_metaphlan_cleaned)
all(colnames(raw_counts_matrix_deseq2_hmp_metaphlan_cleaned) == rownames(sample_mapping_hmp2_filtered))






```


```{r}
library(DESeq2)
#Use a simple paired design 
#basically treating that each sample has a non_dysbiotic and dysbiotic sample 


deseq2Data_hmp2_metaphlan_cleaned <- DESeqDataSetFromMatrix(countData=raw_counts_matrix_deseq2_hmp_metaphlan_cleaned, colData=sample_mapping_hmp2_filtered, design = ~ Participant.ID + dysbiosis_binary)



```

```{r}
#DE results - not using a nested design like with Duerkop data, so no need to rebuild the model matrix here 
#need to first estimate size factors to deal with zeroes 

dds_hmp2_metaphlan_cleaned <-estimateSizeFactors(deseq2Data_hmp2_metaphlan_cleaned, type = "poscounts")
dds_hmp2_metaphlan_cleaned <- DESeq(dds_hmp2_metaphlan_cleaned)





```
```{r}
#now Enterobacteriaceae is not NA!

deseq2_results_hmp_2_metaphlan_cleaned <-  results(dds_hmp2_metaphlan_cleaned, contrast=list("dysbiosis_binary_Yes_vs_No"))

#still need to shrink LFC 


deseq2_results_hmp_2_metaphlan_cleaned_shrink <- lfcShrink(dds_hmp2_metaphlan_cleaned, coef="dysbiosis_binary_Yes_vs_No", type="apeglm")





deseq2_results_hmp_2_clean_shrink <- as.data.frame(deseq2_results_hmp_2_metaphlan_cleaned_shrink)

deseq2_results_hmp_2_clean_shrink <- deseq2_results_hmp_2_clean_shrink %>% 
rownames_to_column(var = "contigname")
deseq2_results_hmp_2_clean_shrink


#read in the tax map 

metaphlan4.family.3.tax.map <- metaphlan4.family.3.tax
metaphlan4.family.3.tax.map$contigname <- metaphlan4.family.3.tax.map$clade_name



deseq2_results_hmp_2_comb_meta <- left_join(deseq2_results_hmp_2_clean_shrink, metaphlan4.family.3.tax.map, by= "contigname")






#significant values 

deseq2_results_hmp_2_comb_meta_sig <- subset(deseq2_results_hmp_2_comb_meta, padj < 0.05 & (log2FoldChange > 1 | log2FoldChange < -1))


deseq2_results_hmp_2_comb_meta_sig <- as.data.frame(deseq2_results_hmp_2_comb_meta_sig)






 library(EnhancedVolcano)

#in order to plot the cutoff of padj and not p-value, we need to give the pvalue column in the df the values from the padj column 


hmp_2_combined_deseq1_res2_df_changed_meta <- deseq2_results_hmp_2_comb_meta
hmp_2_combined_deseq1_res2_df_changed_meta$pvalue <- hmp_2_combined_deseq1_res2_df_changed_meta$padj


keyvals_col_con_hmp2_meta <- ifelse(
    hmp_2_combined_deseq1_res2_df_changed_meta$log2FoldChange < -1 & hmp_2_combined_deseq1_res2_df_changed_meta$padj < 0.05, 'orange',
      ifelse(hmp_2_combined_deseq1_res2_df_changed_meta$log2FoldChange > 1 & hmp_2_combined_deseq1_res2_df_changed_meta$padj < 0.05, 'darkgreen',
        'light grey'))
  keyvals_col_con_hmp2_meta[is.na(keyvals_col_con_hmp2_meta)] <- 'light grey'
  names(keyvals_col_con_hmp2_meta)[keyvals_col_con_hmp2_meta == 'darkgreen'] <- 'Enriched in Dysbiotic Samples'
  names(keyvals_col_con_hmp2_meta)[keyvals_col_con_hmp2_meta == 'light grey'] <- 'Non-significant'
  names(keyvals_col_con_hmp2_meta)[keyvals_col_con_hmp2_meta == 'orange'] <- 'Depleted in Dysbiotic Samples'

EV_col_con_meta <- EnhancedVolcano(hmp_2_combined_deseq1_res2_df_changed_meta, lab=NA , x = 'log2FoldChange',
    y = 'pvalue',  pCutoff = 0.05, cutoffLineWidth = 0.1, selectLab = rownames(hmp_2_combined_deseq1_res2_df_changed_meta)[which(names(keyvals_col_con_hmp2_meta) %in% c('Over-Abundant in Colitis', 'Over-Abundant in Control'))], pointSize = 2, gridlines.major = FALSE, gridlines.minor = FALSE, colCustom = keyvals_col_con_hmp2_meta,  legendPosition = 'right', legendLabSize = 12,legendIconSize = 4.0, title = "", axisLabSize = 15,    subtitle = "", caption = "", xlab = expression(Log[2]~"Fold-Change")
)

EV_col_con_meta
```



```{r}
#compare the LFCs between the PHF and L
deseq2_results_hmp_2_comb_meta 
deseq2_results_hmp_2_comb



#change the phf df 
deseq2_results_hmp_2_comb_filtered <- deseq2_results_hmp_2_comb %>%
  select(Family, log2FoldChange, padj)

deseq2_results_hmp_2_comb_filtered$LFC_phf <- deseq2_results_hmp_2_comb_filtered$log2FoldChange
deseq2_results_hmp_2_comb_filtered$padj_phf <- deseq2_results_hmp_2_comb_filtered$padj
deseq2_results_hmp_2_comb_filtered$Family <-  gsub("^f__", "", deseq2_results_hmp_2_comb_filtered$Family)
deseq2_results_hmp_2_comb_filtered <- deseq2_results_hmp_2_comb_filtered %>%
  select(Family, LFC_phf, padj_phf)

deseq2_results_hmp_2_comb_filtered

#change the metaphlan df 

deseq2_results_hmp_2_comb_meta_filtered <- deseq2_results_hmp_2_comb_meta %>%
  select(gtdb_family, log2FoldChange, padj)


deseq2_results_hmp_2_comb_meta_filtered$Family <- deseq2_results_hmp_2_comb_meta_filtered$gtdb_family
deseq2_results_hmp_2_comb_meta_filtered$LFC_meta <- deseq2_results_hmp_2_comb_meta_filtered$log2FoldChange
deseq2_results_hmp_2_comb_meta_filtered$padj_meta <- deseq2_results_hmp_2_comb_meta_filtered$padj


deseq2_results_hmp_2_comb_meta_filtered <- deseq2_results_hmp_2_comb_meta_filtered %>%
  select(Family, LFC_meta, padj_meta)


#now left join
deseq_compare <- left_join(deseq2_results_hmp_2_comb_filtered,deseq2_results_hmp_2_comb_meta_filtered, by = "Family" ) 
deseq_compare

 
deseq_compare_sig <- deseq_compare %>%
  filter(padj_phf < 0.05 | padj_meta < 0.05 & LFC_phf > 1 | LFC_meta > 1 | LFC_phf < -1 | LFC_meta < -1)
deseq_compare_sig



ggplot(deseq_compare, aes(x = LFC_phf, y = LFC_meta)) +
  geom_point(color = "blue", alpha = 0.7) +  # Scatter points
  theme_minimal() +  # Clean theme
  labs(title = "",
       x = "PHF LFC",
       y = "Metaphlan LFC") 






deseq_compare$ratio <- deseq_compare$LFC_meta/deseq_compare$LFC_phf



write.csv(deseq_compare, "/Users/anshulsinha/Desktop/PBF_manuscript/resubmission_02_2025/revised_figures/Tables/supplementary_table_1.csv")
deseq2_results_hmp_2_comb_meta_sig


deseq2_results_hmp_2_sig$Family




```












```{r}
#Build a relative abundance regression for different PHFs vs. metaphlan relative abundances


physeq_filtered_1500_metaphlan
subset_1500_phf <- subset_1500


#Lets tax_glom and convert to Family level

physeq_filtered_1500_metaphlan_fam <- tax_glom(physeq_filtered_1500_metaphlan, taxrank="gtdb_family", NArm = TRUE) 
subset_1500_phf_family <- tax_glom(subset_1500, taxrank="Family", NArm = TRUE) 


# convert to rel ab
physeq_rel_fam_metaphlan <- transform_sample_counts(physeq_filtered_1500_metaphlan_fam, function(x) x / sum(x))

physeq_rel_fam_phf <- transform_sample_counts(subset_1500_phf_family, function(x) x / sum(x))


#create a function that melts the relab ps_object, gives a df with relative abundance by family 
#for metaphlan

df_fun_metaphlan_relab <- function(ps, family) {
  
  df <- psmelt(ps)
  
  #select family of interest
  df_fam <- df[df$gtdb_family == family,]

  df_fam$meta_fam <- df_fam$gtdb_family
  df_fam$meta_abundance <- df_fam$Abundance
  
  df_fam_select <- df_fam %>%
    select(Sample, meta_fam, meta_abundance)
  df_fam_select
}

#and for PHF
df_fun_phf_relab <- function(ps, family) {
  
  df <- psmelt(ps)
  #remove f__
    df$Family <- gsub("^f__", "", df$Family)

  #select family of interest
  df_fam <- df[df$Family == family,]

  df_fam$phf_fam <- df_fam$Family
    df_fam$phf_abundance <- df_fam$Abundance
  
  df_fam_select <- df_fam %>%
    select(Sample, phf_fam, phf_abundance)
  
  
}



##Genereate relative abundance correlation plots###
###BACTEROIDACEAE


meta_bacteroidaceae_relab <-   df_fun_metaphlan_relab(physeq_rel_fam_metaphlan, "Bacteroidaceae")
phf_bacteroidaceae_relab <-  df_fun_phf_relab(physeq_rel_fam_phf, "Bacteroidaceae")



bacter_join_relab <- left_join(meta_bacteroidaceae_relab, phf_bacteroidaceae_relab, by = "Sample" )

# Create scatterplot
ggplot(bacter_join_relab, aes(x = meta_abundance, y = phf_abundance)) +
  geom_point(color = "blue", alpha = 0.7) +  # Scatter points
  theme_minimal() +  # Clean theme
  labs(title = "Relative abundance of Bacteroidaceae",
       x = "Host Family Abundance",
       y = "PHF Abundance") +
  xlim(0, 1) +  # Set x-axis limits
  ylim(0, 1)    # Set y-axis limits (optional)



####Tannerellaceae
meta_tannerellaceae_relab <-   df_fun_metaphlan_relab(physeq_rel_fam_metaphlan, "Tannerellaceae")
phf_tannerellaceae_relab <-  df_fun_phf_relab(physeq_rel_fam_phf, "Tannerellaceae")




tannerell_join_relab <- left_join(meta_tannerellaceae_relab, phf_tannerellaceae_relab, by = "Sample" )

# Create scatterplot
ggplot(tannerell_join_relab, aes(x = meta_abundance, y = phf_abundance)) +
  geom_point(color = "blue", alpha = 0.7) +  # Scatter points
  theme_minimal() +  # Clean theme
  labs(title = "Relative abundance of Tanerellaceae",
       x = "Host Family Abundance",
       y = "PHF Abundance") +
  xlim(0, 0.5) +  # Set x-axis limits
  ylim(0, 0.5)    # Set y-axis limits (optional)





####Tannerellaceae
meta_tannerellaceae_relab <-   df_fun_metaphlan_relab(physeq_rel_fam_metaphlan, "Tannerellaceae")
phf_tannerellaceae_relab <-  df_fun_phf_relab(physeq_rel_fam_phf, "Tannerellaceae")




tannerell_join_relab <- left_join(meta_tannerellaceae_relab, phf_tannerellaceae_relab, by = "Sample" )

# Create scatterplot
ggplot(tannerell_join_relab, aes(x = meta_abundance, y = phf_abundance)) +
  geom_point(color = "blue", alpha = 0.7) +  # Scatter points
  theme_minimal() +  # Clean theme
  labs(title = "Relative abundance of Tanerellaceae",
       x = "Host Family Abundance",
       y = "PHF Abundance") +
  xlim(0, 0.1) +  # Set x-axis limits
  ylim(0, 1)    # Set y-axis limits (optional)



#sanity check that coefficient isnt driven by outlier abundances

tannerell_join_relab_test <- tannerell_join_relab[tannerell_join_relab$meta_abundance < 0.25,]

cor.test(tannerell_join_relab_test$meta_ab, tannerell_join_relab_test$phf_ab, method = "spearman")

####Streptococcaeae
meta_barnes_relab <-   df_fun_metaphlan_relab(physeq_rel_fam_metaphlan, "Barnesiellaceae")
phf_barnes_relab <-  df_fun_phf_relab(physeq_rel_fam_phf, "Barnesiellaceae")




strep_join_relab <- left_join(meta_tannerellaceae_relab, phf_streptococcaceae_relab, by = "Sample" )

# Create scatterplot
ggplot(strep_join_relab, aes(x = meta_abundance, y = phf_abundance)) +
  geom_point(color = "blue", alpha = 0.7) +  # Scatter points
  theme_minimal() +  # Clean theme
  labs(title = "Relative abundance of Barnesiellaceae",
       x = "Host Family Abundance",
       y = "PHF Abundance") +
  xlim(0, 1) +  # Set x-axis limits
  ylim(0, 0.1)    # Set y-axis limits (optional)


```

```{r}

```








```{r}



###SPEARMAN'S CORRELATION OF RELATIVE ABUNDANCES####

# convert to rel ab
physeq_rel_fam_metaphlan <- transform_sample_counts(physeq_filtered_1500_metaphlan_fam, function(x) x / sum(x))

physeq_rel_fam_phf <- transform_sample_counts(subset_1500_phf_family, function(x) x / sum(x))





#get a list of metaphlan and phf families - filter for cases where we have both (ie - can only compare if we have a representative family for both)
physeq_rel_fam_metaphlan_melt <- psmelt(physeq_rel_fam_metaphlan)
physeq_rel_fam_phf_melt <- psmelt(physeq_rel_fam_phf)


#list of unique metaphlan fams
physeq_rel_fam_phf_melt$Family <- gsub("f__", "", physeq_rel_fam_phf_melt$Family)


names_unique_meta <- unique(physeq_rel_fam_metaphlan_melt$gtdb_family)
names_unique_phf <- unique(physeq_rel_fam_phf_melt$Family)

common_names <- intersect(names_unique_meta, names_unique_phf)
length(common_names) #33 that we can compare!
length(names_unique_meta)
length(names_unique_phf)
### select columns from each melted df that we need 
physeq_rel_fam_metaphlan_melt$meta_ab <- physeq_rel_fam_metaphlan_melt$Abundance
physeq_rel_fam_metaphlan_melt_select <- physeq_rel_fam_metaphlan_melt %>%
  select(Sample, gtdb_family, meta_ab)


physeq_rel_fam_metaphlan_melt_select <- physeq_rel_fam_metaphlan_melt_select %>%
  filter(gtdb_family %in% common_names)


### select columns from each melted df that we need 
physeq_rel_fam_phf_melt$phf_ab <- physeq_rel_fam_phf_melt$Abundance
physeq_rel_fam_phf_melt_select <- physeq_rel_fam_phf_melt %>%
  select(Sample, Family, phf_ab)

physeq_rel_fam_phf_melt_select <- physeq_rel_fam_phf_melt_select %>%
  filter(Family %in% common_names)




physeq_rel_fam_metaphlan_melt_select
physeq_rel_fam_phf_melt_select

# we have the same number of rows!  this would make sense (same number of families and samples) - as long as zero abundance rows are kept 
#sanity check 

# Arrange in ascending order by abundancen
df_sorted_meta <- physeq_rel_fam_metaphlan_melt_select %>% arrange(meta_ab) 

df_sorted_phf <- physeq_rel_fam_phf_melt_select %>% arrange(phf_ab) 

length(unique(df_sorted_phf$Family))
length(unique(df_sorted_meta$gtdb_family))

#there are the same number of unique families and there are also zeroes - loooks good

# change column in metaphlan


physeq_rel_fam_metaphlan_melt_select
colnames(physeq_rel_fam_metaphlan_melt_select) <- c("Sample", "Family", "meta_ab")
physeq_rel_fam_phf_melt_select




# Left join by two columns - selects for only same-same comparisons

joined_relative_abundance_df <- left_join(physeq_rel_fam_metaphlan_melt_select, physeq_rel_fam_phf_melt_select, by = c("Sample", "Family"))

#entero

joined_relative_abundance_df_entero <- joined_relative_abundance_df[joined_relative_abundance_df$Family == "Enterobacteriaceae",]
cor.test(joined_relative_abundance_df_entero$meta_ab, joined_relative_abundance_df_entero$phf_ab, method = "spearman")



# Compute Spearman correlation and p-value for each Family
cor_results <- joined_relative_abundance_df %>%
  group_by(Family) %>%
  summarise(
    spearman_cor = cor.test(meta_ab, phf_ab, method = "spearman")$estimate,
    p_value = cor.test(meta_ab, phf_ab, method = "spearman")$p.value
  )

cor_results
# Apply Benjamini-Hochberg (BH) correction
cor_results <- cor_results %>%
  mutate(adj_p_value = p.adjust(p_value, method = "BH"))
print(cor_results)


##arrange 
cor_results_arranged <- cor_results %>% arrange(-spearman_cor) 




```
```{r}

##adding some prevalence info here: 
df_hmp_virome_pbf_prevalence_cor <- df_hmp_virome_pbf_prevalence

df_hmp_virome_pbf_prevalence_cor$Family <- gsub("f__", "", df_hmp_virome_pbf_prevalence_cor$Family)
df_hmp_virome_pbf_prevalence_cor <- df_hmp_virome_pbf_prevalence_cor %>%
select(Family, rank_prev_ind, prevalence_ind)

#filter for just ones in correlation analyses
df_hmp_virome_pbf_prevalence_cor_filter <- df_hmp_virome_pbf_prevalence_cor %>%
  filter(Family %in% common_names)
  


df_hmp_virome_pbf_prevalence_cor_filter <- df_hmp_virome_pbf_prevalence_cor_filter %>%
  mutate(rank = rank(rank_prev_ind))



#calculate metaphlan prevalence info!
physeq_rel_fam_phf

physeq_rel_fam_metaphlan_melt_prev_s1 <- physeq_rel_fam_metaphlan_melt %>%
  select(Sample, gtdb_family, Abundance, Participant.ID)



# Calculate prevalence: proportion of individuals with rel_abundance > 0

# Compute prevalence at the individual level
physeq_rel_fam_metaphlan_melt_prev_s1_prev <- physeq_rel_fam_metaphlan_melt_prev_s1 %>%
  group_by(Participant.ID, gtdb_family) %>% 
  summarise(present = any(Abundance > 0), .groups = "drop") %>%  # Check if present in any sample
  group_by(gtdb_family) %>%
  summarise(prevalence = sum(present) / n_distinct(physeq_rel_fam_metaphlan_melt_prev_s1$Participant.ID))  # Prevalence per total individuals


# Step 2: Rank families so that the highest prevalence gets rank 1
prevalence_df_metaphlan <- physeq_rel_fam_metaphlan_melt_prev_s1_prev %>%
  mutate(rank_ind = rank(-prevalence))


#filter for just ones in correlation analyses
prevalence_df_metaphlan_filtered <- prevalence_df_metaphlan %>%
  filter(gtdb_family %in% common_names)

#re-rank 
  prevalence_df_metaphlan_filtered <- prevalence_df_metaphlan_filtered %>%
  mutate(rank = rank(rank_ind))
  

  
#select columns of interest 
prevalence_df_metaphlan_filtered$prevalence_metaphlan <- prevalence_df_metaphlan_filtered$prevalence
prevalence_df_metaphlan_filtered$Family <- prevalence_df_metaphlan_filtered$gtdb_family
prevalence_df_metaphlan_filtered$rank_ind_metaphlan <- prevalence_df_metaphlan_filtered$rank

  prevalence_df_metaphlan_filtered_select <- prevalence_df_metaphlan_filtered %>%
    select(Family, prevalence_metaphlan, rank_ind_metaphlan)
  
  
  
  df_hmp_virome_pbf_prevalence_cor_filter$prevalence_phf_ind <- df_hmp_virome_pbf_prevalence_cor_filter$prevalence_ind
    df_hmp_virome_pbf_prevalence_cor_filter$rank_ind_phf <- df_hmp_virome_pbf_prevalence_cor_filter$rank

  
  df_hmp_virome_pbf_prevalence_cor_filter_select <- df_hmp_virome_pbf_prevalence_cor_filter %>%
    select(Family, prevalence_phf_ind, rank_ind_phf)
  
  
joined_prevalence <- left_join(df_hmp_virome_pbf_prevalence_cor_filter_select,prevalence_df_metaphlan_filtered_select, by = "Family" )




```
```{r}
cor_results_arranged

joined_prevalence

join_spearman_prevalence <- left_join(cor_results_arranged, joined_prevalence, by = "Family")

#positive correlations
join_spearman_prevalence_sig_positive <- join_spearman_prevalence[join_spearman_prevalence$adj_p_value < 0.05 &  join_spearman_prevalence$spearman_cor > 0,]



#write table (Supplementary Table. S2)

join_spearman_prevalence_filter <- join_spearman_prevalence %>%
  select(Family, spearman_cor,adj_p_value, prevalence_phf_ind,prevalence_metaphlan )
  
  
  write.csv(join_spearman_prevalence_filter, "/Users/anshulsinha/Desktop/PBF_manuscript/resubmission_02_2025/revised_figures/Tables/supplementary_table_s2.csv")
```

```{r}

```


